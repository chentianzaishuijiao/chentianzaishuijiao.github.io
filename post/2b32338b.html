<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>JavaSE | 陈天在睡觉</title><meta name="author" content="陈天在睡觉"><meta name="copyright" content="陈天在睡觉"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="一、java语言概述1、软件开发介绍软件，即一系列按照特定顺序组织的计算机数据和指令的集合。有系统软件和应用软件之分。 常用的dos命令  123456789dir : 列出当前目录下的文件以及文件夹md : 创建目录rd : 删除目录cd : 进入指定目录cd.. : 退回到上一级目录cd\: 退回到根目录del : 删除文件exit : 退出 dos 命令行补充：echo javase&gt;">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaSE">
<meta property="og:url" content="http://example.com/post/2b32338b.html">
<meta property="og:site_name" content="陈天在睡觉">
<meta property="og:description" content="一、java语言概述1、软件开发介绍软件，即一系列按照特定顺序组织的计算机数据和指令的集合。有系统软件和应用软件之分。 常用的dos命令  123456789dir : 列出当前目录下的文件以及文件夹md : 创建目录rd : 删除目录cd : 进入指定目录cd.. : 退回到上一级目录cd\: 退回到根目录del : 删除文件exit : 退出 dos 命令行补充：echo javase&gt;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/%E5%8D%9A%E5%AE%A28.jpg">
<meta property="article:published_time" content="2023-01-14T16:00:00.000Z">
<meta property="article:modified_time" content="2023-01-15T00:15:04.952Z">
<meta property="article:author" content="陈天在睡觉">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/%E5%8D%9A%E5%AE%A28.jpg"><link rel="shortcut icon" href="/img/%E6%9F%BF%E5%AD%90.png"><link rel="canonical" href="http://example.com/post/2b32338b"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 陈天在睡觉","link":"链接: ","source":"来源: 陈天在睡觉","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JavaSE',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2023-01-15 08:15:04'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/font.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E5%A4%B4%E5%83%8F.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">6</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/%E5%8D%9A%E5%AE%A28.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">陈天在睡觉</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">JavaSE</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-01-14T16:00:00.000Z" title="发表于 2023-01-15 00:00:00">2023-01-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-15T00:15:04.952Z" title="更新于 2023-01-15 08:15:04">2023-01-15</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">58.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>201分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="JavaSE"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="一、java语言概述"><a href="#一、java语言概述" class="headerlink" title="一、java语言概述"></a>一、java语言概述</h1><h2 id="1、软件开发介绍"><a href="#1、软件开发介绍" class="headerlink" title="1、软件开发介绍"></a>1、软件开发介绍</h2><p>软件，即一系列按照特定顺序组织的计算机数据和指令的集合。有系统软件和应用软件之分。 常用的dos命令 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dir : 列出当前目录下的文件以及文件夹</span><br><span class="line">md : 创建目录</span><br><span class="line">rd : 删除目录</span><br><span class="line">cd : 进入指定目录</span><br><span class="line">cd.. : 退回到上一级目录</span><br><span class="line">cd\: 退回到根目录</span><br><span class="line">del : 删除文件</span><br><span class="line"><span class="built_in">exit</span> : 退出 dos 命令行</span><br><span class="line">补充：echo javase&gt;<span class="number">1.</span>doc</span><br></pre></td></tr></table></figure>

<p><strong>计算机语言：人与计算机交流的方式。</strong> </p>
<p>如果人要与计算机交流，那么就要学习计算机语言。C ,C++ ,Java,.net ,PHP , Kotlin，Python，Scala </p>
<h2 id="2、计算机编程语言介绍"><a href="#2、计算机编程语言介绍" class="headerlink" title="2、计算机编程语言介绍"></a>2、计算机编程语言介绍</h2><p><strong>第一代语言</strong> </p>
<p>机器语言。指令以二进制代码形式存在。 </p>
<p><strong>第二代语言</strong> </p>
<p>汇编语言。使用助记符表示一条机器指令 </p>
<p><strong>第三代语言：高级语言</strong> </p>
<p>C、Pascal、Fortran面向过程的语言 </p>
<p>C++面向过程&#x2F;面向对象 Java跨平台的纯面向对象的语言</p>
<p> .NET Python、Scala </p>
<h2 id="3、java语言概述"><a href="#3、java语言概述" class="headerlink" title="3、java语言概述"></a>3、java语言概述</h2><p> 是SUN(Stanford University Network，斯坦福大学网络公司 ) 1995年推出的一门高级编程语言。是一 种面向Internet的编程语言。Java一开始富有吸引力是因为Java程序可以在Web浏览器中运行。这些Java 程序被称为Java小程序（applet）。applet使用现代的图形用户界面与Web用户进行交互。 applet内嵌 在HTML代码中。随着Java技术在web方面的不断成熟，已经成为Web应用程序的首选开发语言。 </p>
<p>1991年 Green项目，开发语言最初命名为Oak (橡树) </p>
<p>1994年，开发组意识到Oak 非常适合于互联网 </p>
<p>1996年，发布JDK 1.0，约8.3万个网页应用Java技术来制作 </p>
<p>1997年，发布JDK 1.1，JavaOne会议召开，创当时全球同类会议规模之最 </p>
<p>998年，发布JDK 1.2，同年发布企业平台J2EE</p>
<p>1999年，Java分成J2SE、J2EE和J2ME，JSP&#x2F;Servlet技术诞生 </p>
<p>2004年，发布里程碑式版本：JDK 1.5，为突出此版本的重要性，更名为JDK 5.0 </p>
<p>2005年，J2SE -&gt; JavaSE，J2EE -&gt; JavaEE，J2ME -&gt; JavaME </p>
<p>2009年，Oracle公司收购SUN，交易价格74亿美元 </p>
<p>2011年，发布JDK 7.0 </p>
<p>2014年，发布JDK 8.0，是继JDK 5.0以来变化最大的版本 </p>
<p>2017年，发布JDK 9.0，最大限度实现模块化 </p>
<p>2018年3月，发布JDK 10.0，版本号也称为18.3 </p>
<p>2018年9月，发布JDK 11.0，版本号也称为18.9 </p>
<h2 id="4、java技术平台"><a href="#4、java技术平台" class="headerlink" title="4、java技术平台"></a>4、java技术平台</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106165903244.png" alt="image-20220106165903244"></p>
<h2 id="5、java使用领域"><a href="#5、java使用领域" class="headerlink" title="5、java使用领域"></a>5、java使用领域</h2><p><strong>企业级应用</strong>：主要指复杂的大企业的软件系统、各种类型的网站。Java的安全机制以及它的跨平台的优 势，使它在分布式系统领域开发中有广泛应用。应用领域包括金融、电信、交通、电子商务等。 移动领域应用：主要表现在消费和嵌入式领域，是指在各种小型设备上的应用，包括手机、PDA、机顶 盒、汽车通信设备等。 </p>
<p>诞生：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106165944094.png" alt="image-20220106165944094"></p>
<p>java之父James Gosling团队在开发”Green”项目时，发现C缺少垃圾回收系统，还有可移植的安全性、分 布程序设计和多线程功能。最后，他们想要一种易于移植到各种设备上的平台。java是一个纯粹面向对 象的语言。舍弃了c语言中容易引起错误的指针，增加了垃圾回收器，泛型，枚举等功能。 </p>
<h2 id="6、java主要特征"><a href="#6、java主要特征" class="headerlink" title="6、java主要特征"></a>6、java主要特征</h2><p>Java语言是易学的。Java语言的语法与C语言和C++语言很接近，使得大多数程序员很容易学习和使用 Java。 </p>
<p>Java语言是强制面向对象的。Java语言提供类、接口和继承等原语，为了简单起见，只支持类之间的单 继承，但支持接口之间的多继承并支持类与接口之间的实现机制（关键字为implements）。 </p>
<p>Java语言是分布式的。Java语言支持Internet应用的开发，在基本的Java应用编程接口中有一个网络应用 编程接口（java net），它提供了用于网络应用编程的类库，包括URL、URLConnection、Socket、 ServerSocket等。Java的RMI（远程方法激活）机制也是开发分布式应用的重要手段。</p>
<p> Java语言是健壮的。Java的强类型机制、异常处理、垃圾的自动收集等是Java程序健壮性的重要保证。 对指针的丢弃是Java的明智选择。 </p>
<p>Java语言是安全的。Java通常被用在网络环境中，为此，Java提供了一个安全机制以防恶意代码的攻 击。如：安全防范机制（类ClassLoader），如分配不同的名字空间以防替代本地的同名类、字节代码 检查。 </p>
<p>Java语言是体系结构中立的。Java程序（后缀为java的文件）在Java平台上被编译为体系结构中立的字节 码格式（后缀为class的文件），然后可以在实现这个Java平台的任何系统中运行。 </p>
<p>Java语言是解释型的。如前所述，Java程序在Java平台上被编译为字节码格式，然后可以在实现这个Java 平台的任何系统的解释器中运行。</p>
<p> Java是性能略高的。与那些解释型的高级脚本语言相比，Java的性能还是较优的。 </p>
<p>Java语言是原生支持多线程的。在Java语言中，线程是一种特殊的对象，它必须由Thread类或其子 （孙）类来创建。 </p>
<h2 id="7、java程序运行机制与运行过程"><a href="#7、java程序运行机制与运行过程" class="headerlink" title="7、java程序运行机制与运行过程"></a>7、java程序运行机制与运行过程</h2><p>Java语言的特点:	1）面向对象：两个基本概念：类和对象。三大特征：封装，继承，多态 </p>
<p>​								2）健壮：吸收了C&#x2F;C++语言的优点，但去掉了其影响程序健壮性的部分（如指针、内 存的申请与释放等），提供了一个相对安全的内存管理和访问机制 </p>
<p>​								3）跨平台：跨平台性：通过Java语言编写的应用程序在不同的系统平台上都可以运 行。Write once , Run Anywhere。原理：在操作系统上按照java虚拟机（JVM java Virtual Machine）. 由JVM来负责Java程序在该系统中的运行。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106170229323.png" alt="image-20220106170229323"></p>
<p>​		核心机制：JAVA虚拟机（JAVA Virtal Machine） 垃圾收集机制（Garbage Collection）</p>
<p>​		 java虚拟机 ：JVM 是一个虚拟的计算机，具有指令集并使用不同的存储区域。负责执行指令，管 理数据，内存，寄存器。对于不同的平台，有不同的虚拟机。只有操作系统是航有对应的java虚拟机， java程序才可在运行。java虚拟机机制屏蔽了底层运行平台的差别，实现了一次编译，到处运行。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106170409628.png" alt="image-20220106170409628"></p>
<p>​		垃圾回收：不再使用的内存空间应回收。Java 语言消除了程序员回收无用内存空间的责任：它 提供一种系统级线程跟踪存储空间的分配情况。并在JVM空闲时，检查并释放那些可被释放的存储空 间。垃圾回收在Java程序运行过程中自动进行，程序员无法精确控制和干预。</p>
<h2 id="8、java语言环境搭建"><a href="#8、java语言环境搭建" class="headerlink" title="8、java语言环境搭建"></a><strong>8、java语言环境搭建</strong></h2><p>下载JDK,安装JDK,配置环境变量。</p>
<p>验证是否成功 </p>
<p><strong>什么是JDK,JRE?</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106170500936.png" alt="image-20220106170500936"></p>
<p>JDK&#x3D;JRE+开发工具集 JRE&#x3D;JVM+JAVASE标准类库 </p>
<p>安装：傻瓜式安装，默认下一步即可。安装路径不能包含中文，空格等特殊字符。推荐再要安装的路径 下，创建好文件夹。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106170527913.png" alt="image-20220106170527913">\</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106170541021.png" alt="image-20220106170541021"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106170549286.png" alt="image-20220106170549286"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106170601891.png" alt="image-20220106170601891"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106170610266.png" alt="image-20220106170610266"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106170623344.png" alt="image-20220106170623344"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106170630923.png" alt="image-20220106170630923"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106170640512.png" alt="image-20220106170640512"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106170647950.png" alt="image-20220106170647950"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106170656498.png" alt="image-20220106170656498"></p>
<p><strong>配置环境变量</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106170749177.png" alt="image-20220106170749177"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106170757853.png" alt="image-20220106170757853"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106170807379.png" alt="image-20220106170807379"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106170848229.png" alt="image-20220106170848229"></p>
<p><strong>配置path</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106170906910.png" alt="image-20220106170906910"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106170919329.png" alt="image-20220106170919329"></p>
<p><strong>path:%JAVA_HOME%:取到配置JAVA_HOME环境变量的值</strong></p>
<p> <strong>检测是否成功</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106170948280.png" alt="image-20220106170948280"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106170955140.png" alt="image-20220106170955140"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106171003495.png" alt="image-20220106171003495"></p>
<h2 id="9、helloworld"><a href="#9、helloworld" class="headerlink" title="9、helloworld"></a>9、helloworld</h2><p>将 Java 代码<strong>编写</strong>到扩展名为 .java 的文件中。</p>
<p>通过 javac 命令对该 java 文件进行<strong>编译</strong>。</p>
<p>通过 java 命令对生成的 class 文件进行<strong>运行</strong>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106171133079.png" alt="image-20220106171133079"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106171140302.png" alt="image-20220106171140302"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106171147836.png" alt="image-20220106171147836"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106171201631.png" alt="image-20220106171201631"></p>
<p>​	编写第一个java程序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">System.out.println(“Hello World!”);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> 编译:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac Test.java</span><br></pre></td></tr></table></figure>

<p>有了java源文件，通过编译器将其编译成JVM可以识别的字节码文件。 </p>
<p>在该源文件目录下，通过javac编译工具对Test.java文件进行编译。 </p>
<p>如果程序没有错误，没有任何提示，但在当前目录下会出现一个Test.class文件，该文件称为字节码文 件，也是可以执行的java的程序。 </p>
<p>运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java Test</span><br></pre></td></tr></table></figure>

<p>有了可执行的java程序(Test.class字节码文件) </p>
<p>通过运行工具java.exe对字节码文件进行执行。出现提示：缺少一个名称为main的方法 </p>
<p>因为一个程序的执行需要一个起始点或者入口，所以在Test类中的加入public static void main(String[] args){ } </p>
<p>对修改后的Test.java源文件需要重新编译，生成新的class文件后，再进行执行。 </p>
<p>发现没有编译失败，但也没有任何效果，因为并没有告诉JVM要帮我们做什么事情，也就是没有可以具 体执行的语句。 </p>
<p>想要和JVM来个互动，只要在main方法中加入一句System.out.println(“Hello World”);因为程序进行改 动，所以再重新编译，运行即可 </p>
<p>现在文件的扩展名</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106171454564.png" alt="image-20220106171454564"></p>
<h2 id="10、常见问题及解决办法"><a href="#10、常见问题及解决办法" class="headerlink" title="10、常见问题及解决办法"></a>10、常见问题及解决办法</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106171532462.png" alt="image-20220106171532462"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106171539332.png" alt="image-20220106171539332"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106171549885.png" alt="image-20220106171549885"></p>
<p>源文件名不存在或者写错 当前路径错误 后缀名隐藏问题 </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106171834797.png" alt="image-20220106171834797"></p>
<p>类文件名写错，尤其文件名与类名不一致时，要小心类文件不在当前路径下，或者不在classpath指定 路径下 </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106171843436.png" alt="image-20220106171843436"></p>
<p>声明为public的类应与文件名一致，否知编译失败 </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106171852440.png" alt="image-20220106171852440"></p>
<p>编译失败，注意错误出现的行数，再到源代码中指定位置改错 </p>
<p>学习编程最容易犯的错是语法错误。Java要求你必须按照语法规则编写代码。 </p>
<p>如果你的程序违反了语法规则，例如：忘记了分号、大括号、引号，或者拼错了单词，java编译器都会 报语法错误。尝试着去看懂编译器会报告的错误信息 </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106171941060.png" alt="image-20220106171941060"></p>
<p>或使用转义字符实现换行</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106171956088.png" alt="image-20220106171956088"></p>
<h2 id="11、注释"><a href="#11、注释" class="headerlink" title="11、注释"></a>11、注释</h2><p>单行注释 &#x2F;&#x2F; 多行注释 &#x2F;**&#x2F; </p>
<p>文档注释 (java特有)</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106172027886.png" alt="image-20220106172027886"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106172040733.png" alt="image-20220106172040733">、</p>
<p>小结程序</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106172057909.png" alt="image-20220106172057909"></p>
<h2 id="12、良好的编程习惯"><a href="#12、良好的编程习惯" class="headerlink" title="12、良好的编程习惯"></a>12、良好的编程习惯</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106172125033.png" alt="image-20220106172125033"></p>
<h2 id="练习题："><a href="#练习题：" class="headerlink" title="练习题："></a>练习题：</h2><p>1、 java语言的特点是什么？</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106172142904.png" alt="image-20220106172142904"></p>
<p>2、System.out.println()与System.out.print()区别是什么？ </p>
<p>3、一个.java源文件中是否可以包括多个类？什么要求？ </p>
<p>4、Test类的文件名叫Demo.java </p>
<p>5、设置path的目的是什么？ </p>
<p>6、JDK JRE 和 JVM的关系是什么？ </p>
<p>7、源文件名是否必须和类名相同呢？如果不是，什么情况下相同 </p>
<p>8、程序中若只有一个public修饰的类，且此类包含main方法，那么类名和源文件名可否不一致？ </p>
<p>9、java注释方式有哪几种，格式是什么？ </p>
<p>10、GC是什么？为什么要有GC</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106172220977.png" alt="image-20220106172220977"></p>
<p>11、垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行 垃圾回收</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106172242190.png" alt="image-20220106172242190"></p>
<p>12、输出以下内容</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106172300143.png" alt="image-20220106172300143"></p>
<h1 id="二、数据类型变量与运算符"><a href="#二、数据类型变量与运算符" class="headerlink" title="二、数据类型变量与运算符"></a>二、数据类型变量与运算符</h1><h2 id="1、数据类型"><a href="#1、数据类型" class="headerlink" title="1、数据类型"></a>1、数据类型</h2><p>​				在生活中，使用的数据有大有小，有整数，也有小数，同时也会使用字母，或者汉字表示特定含 义。在Java中根据数据的不同特点，数据也分为不同的类型。Java语言是强类型语言，对于每一种数据 都定义了明确的具体数据类型，在内存总分配了不同大小的内存空间</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106172337347.png" alt="image-20220106172337347"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220110093928701.png" alt="image-20220110093928701"></p>
<p>注意：整数默认int,小数默认double。boolean类型的值只有true false </p>
<h2 id="2、标识符"><a href="#2、标识符" class="headerlink" title="2、标识符"></a>2、标识符</h2><p>自己起名字的地方都叫标识符。 </p>
<p>​		Java中的名称命名规范：可以包含数字，字母，_，$.但是开头不能是数字，不能是java中的关键字。 命名是区分大小写的。 </p>
<p><strong>包名：</strong>多单词组成时所有字母都小写：xxxyyyzzz </p>
<p><strong>类名、接口名：</strong>多单词组成时，所有单词的首字母大写：XxxYyyZzz。帕斯卡命名规则 </p>
<p><strong>变量名、方法名：</strong>多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写： xxxYyyZzz。驼峰命名规则 </p>
<p><strong>常量名：</strong>所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ </p>
<p>注意1：在起名字时，为了提高阅读性，要尽量有意义，“见名知意”。 </p>
<p>注意2：java采用unicode字符集，因此标识符也可以使用汉字声明，但是不建议使用 </p>
<h2 id="3、关键字与保留字"><a href="#3、关键字与保留字" class="headerlink" title="3、关键字与保留字"></a>3、关键字与保留字</h2><p>关键字(keyword)的定义和特点 </p>
<p>定义：<strong>被Java语言赋予了特殊含义，用做专门用途的字符串（单词）</strong> </p>
<p>特点：<strong>关键字中所有字母都为小写</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106172856220.png" alt="image-20220106172856220"></p>
<p> 字面值： true false null </p>
<p>保留字：现有Java版本尚未使用，但以后版本可能会作为关键字使用。自己命名标识符时要避免使用 这些保留字：goto const </p>
<h2 id="4、变量"><a href="#4、变量" class="headerlink" title="4、变量"></a>4、变量</h2><p>​			 1&gt; 概念：内存中的一个存储区域。该区域的数据可以在同一个类型范围内不断变化。变量是程序中 最基本的存储单元。包含：变量类型 变量名 值； </p>
<p>​			作用：用于在内存中保存数据的。 </p>
<p>​			注意：先声明再使用 </p>
<p>​			使用变量名来访问这块区域的数据 </p>
<p>​			变量的作用域：其定义所在的一对{ }内 </p>
<p>​			变量只有在其作用域内才有效 </p>
<p>​			同一个作用域内，不能定义重名的变量 </p>
<p>​			2&gt;使用 </p>
<p>​			声明变量： 数据类型 变量名; </p>
<p>​			赋值： 变量名&#x3D;值; </p>
<p>​			合并以上步骤：数据类型 变量名 &#x3D; 值； </p>
<p>​			变量除去按照数据类型来分后，还可以按照位置来分【了解，后面详解】</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106173207732.png" alt="image-20220106173207732"></p>
<p>​			3&gt; 整形变量：byte short int long </p>
<p>Java各整数类型有固定的表数范围和字段长度，不受具体OS的影响，以保证java程序的可移植性。 </p>
<p>java的整型常量默认为 int 型，声明long型常量须后加‘l’或‘L’ </p>
<p>java程序中变量通常声明为int型，除非不足以表示较大的数，才使用long</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220107140601383.png" alt="image-20220107140601383"></p>
<p>​			4&gt; 浮点类型：float、double </p>
<p>与整数类型类似，Java 浮点类型也有固定的表数范围和字段长度，不受具体操系统的影响。 浮点型常量有两种表示形式： </p>
<p>十进制数形式：如：5.12 512.0f .512 (必须有小数点） </p>
<p>科学计数法形式:如：5.12e2 512E2 100E-2 </p>
<p>float:单精度，尾数可以精确到7位有效数字。很多情况下，精度很难满足需求。</p>
<p>double:双精度，精度是float的两倍。通常采用此类型。 </p>
<p><strong>Java 的浮点型常量默认为double型，声明</strong>float型常量，须后加f或F。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106173404278.png" alt="image-20220106173404278"></p>
<p>​			5&gt;字符类型 char</p>
<p> char 型数据用来表示通常意义上“字符”(2字节) </p>
<p>Java中的所有字符都使用Unicode编码，故一个字符可以存储一个字母，一个汉字，或其他书面语的一 个字符。 </p>
<p>字符型变量的三种表现形式： </p>
<p>字符常量是用单引号(‘ ’)括起来的单个字符。例如：char c1 &#x3D; ‘a’; char c2 &#x3D; ‘中’; char c3 &#x3D; ‘9’;</p>
<p> Java中还允许使用转义字符‘\’来将其后的字符转变为特殊字符型常量。 </p>
<p>例如：char c3 &#x3D; ‘\n’; &#x2F;&#x2F; ‘\n’表示换行符 </p>
<p>直接使用 Unicode 值来表示字符型常量：‘\uXXXX’。其中，XXXX代表 一个十六进制整数。如：\u000a 表示 \n。 </p>
<p>char类型是可以进行运算的。因为它都对应有Unicode码。 </p>
<p><strong>扩展：</strong></p>
<p><strong>ascii 码</strong>在计算机内部，所有数据都使用<strong>二进制</strong>表示。每一个二进制位（bit）有 0 和 1 两种状 态，因此 8 个二进制位就可以组合出 <strong>256 种</strong>状态，这被称为一个字节（byte）。一个字节一共可以用来 表示 256 种不同的状态，每一个状态对应一个符号，就是 256 个符号，从0000000 到 11111111。 </p>
<p>ASCII码：上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规 定。这被称为ASCII码。ASCII码一共规定了<strong>128个</strong>字符的编码，比如空格“SPACE”是32（二进制 00100000），大写的字母A是65（二进制01000001）。这128个符号（包括32个不能打印出来的控制 符号），只占用了一个字节的后面7位，最前面的1位统一规定为0。 </p>
<p>ASCII编码表中，A&#x3D;65，a&#x3D;97</p>
<p><strong>缺点</strong>：不能表示所有字符。 相同的编码表示的字符不一样。</p>
<p> <strong>unicode码：</strong>乱码：世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此， 要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。 Unicode：<strong>一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，使用 Unicode 没有乱码的问题。</strong> </p>
<p><strong>Unicode 的缺点：</strong>Unicode 只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储：无 法区别 Unicode 和 ASCII：计算机无法区分三个字节表示一个符号还是分别表示三个符号。另外，我们 知道，英文字母只用一个字节表示就够了，如果unicode统一规定，每个符号用三个或四个字节表示， 那么每个英文字母前都必然有二到三个字节是0，这对于存储空间来说是极大的浪费。</p>
<p>​				6&gt;boolean类型：boolean类型数据只允许取值true和false，无null。 </p>
<p>不可以使用0或非 0 的整数替代false和true，这点和C语言不同。</p>
<p> Java虚拟机中没有任何供boolean值专用的字节码指令，Java语言表达所操作的boolean值，在编译之后 都使用java虚拟机中的int数据类型来代替：true用1表示，false用0表示。 </p>
<h2 id="5、类型转换"><a href="#5、类型转换" class="headerlink" title="5、类型转换"></a><strong>5、类型转换</strong></h2><p>​			1&gt;自动类型转换 </p>
<p>容量小的类型自动转换为容量大的数据类型。数据类型按容量大小排序为</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106173920283.png" alt="image-20220106173920283"></p>
<p>​	有多种类型的数据混合运算时，系统首先自动将所有数据转换成容量最大的那种数据类型，然后再进 行计算。</p>
<p> byte,short,char之间不会相互转换，他们三者在计算时首先转换为int类型。 </p>
<p>boolean类型不能与其它数据类型运算 </p>
<p>当把任何基本数据类型的值和字符串(String)进行连接运算时(+)，基本数据类型的值将自动转化为字符 串(String)类型 </p>
<p>​			2&gt;强制类型转换 </p>
<p>自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型。使用时要加上强制转换符： ()，但可能造成精度降低或溢出,格外要注意 。 </p>
<p>通常，字符串不能直接转换为基本类型，但通过基本类型对应的包装类则可以实现把字符串转换成基本 类型 </p>
<p>boolean类型不可以转换为其他的数据类型 </p>
<p>扩展：进制 所有数字在计算机底层都以<strong>二进制</strong>形式存在 </p>
<p>对于整数，有四种表示方式： </p>
<p><strong>二进制</strong>(binary)：0,1 ，满2进1.以0b或0B开头。 </p>
<p>​	二进制的整数有如下三种形式： </p>
<p>​	原码：直接将一个数值换成二进制数。最高位是符号位 </p>
<p>​	负数的反码：是对原码按位取反，只是最高位（符号位）确定为1。 </p>
<p>​	负数的补码：其反码加1。 </p>
<p>​	计算机以二进制补码的形式保存所有的整数。 </p>
<p>​	正数的原码、反码、补码都相同 </p>
<p>​	负数的补码是其反码+1</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106173933617.png" alt="image-20220106173933617"></p>
<p><strong>十进制</strong>(decimal)：0-9 ，满10进1。</p>
<p> <strong>八进制</strong>(octal)：0-7 ，满8进1. 以数字0开头表示。 </p>
<p><strong>十六进制</strong>(hex)：0-9及A-F，满16进1. 以0x或0X开头表示。此处的A-F不区分大小写。如：0x21AF +1&#x3D; 0X21B0</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106173954580.png" alt="image-20220106173954580"></p>
<h2 id="6、-运算符"><a href="#6、-运算符" class="headerlink" title="6、 运算符"></a>6、 运算符</h2><p>运算符是一种特殊的符号，用以表示数据的运算、赋值和比较等。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106174011615.png" alt="image-20220106174011615"></p>
<p>课堂讲解：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106174025758.png" alt="image-20220106174025758"></p>
<h2 id="练习："><a href="#练习：" class="headerlink" title="练习："></a>练习：</h2><p>1、在内存中存储本金1000元 显示内存中存储的数据的值 </p>
<p>2、 使用变量存储数据，实现个人简历信息的输出<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106174038013.png" alt="image-20220106174038013"></p>
<p>3、 输出Java课考试最高分：98.5 输出最高分学员姓名：张三 输出最高分学员性别：男 </p>
<p>4、从控制台输入学员王浩3门课程成绩，编写程序实现 Java课和SQL课的分数之差 3门课的平均分</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106174050004.png" alt="image-20220106174050004"></p>
<p>5、 根据天数（46）计算周数和剩余的天数 </p>
<p>6、已知圆的半径radius&#x3D; 1.5，求其面积 </p>
<p>7、键盘输入四位数字的会员卡号 使用“&#x2F;”和“%”运算符分解获得会员卡各个位上的数字 将各个位上数字 求和 </p>
<p>8、 根据分解后的数字之和，判断用户是否中奖<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106174117471.png" alt="image-20220106174117471"></p>
<p>9、 从控制台输入张三同学的成绩，与李四的成绩（80分）比较，输出“张三的成绩比李四的成绩高吗?” 的判断结果 </p>
<p>10、打印购物小票</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106174128902.png" alt="image-20220106174128902"></p>
<p>11、 为抵抗洪水，解放军战士连续作战89小时，编程计算共多少天零多少小时？ </p>
<p>12、 自定义一个整数，输出该数分别与1~10相乘的结果。 </p>
<p>13、思考，以下代码有区别吗？<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106174139732.png" alt="image-20220106174139732"></p>
<p>14、对两个数实行等量交换</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106174151200.png" alt="image-20220106174151200"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220108155136069.png" alt="image-20220108155136069"></p>
<h1 id="三、流程控制语句"><a href="#三、流程控制语句" class="headerlink" title="三、流程控制语句"></a>三、流程控制语句</h1><p>流程控制语句是用来控制程序中各语句执行顺序的语句，可以把语句组合成能完成一定功能的小逻辑模 块。 </p>
<p>其流程控制方式采用结构化程序设计中规定的三种基本流程结构，即：顺序结构，分支结构，循环结 构。 </p>
<p>顺序结构：程序从上到下逐行执行，中间没任何判断和跳转。 </p>
<p>分支结构：选择结构。有两类，一类是if，一类是switch </p>
<p>循环结构：while,do…while,for循环。 </p>
<h2 id="1、选择结构"><a href="#1、选择结构" class="headerlink" title="1、选择结构"></a>1、选择结构</h2><h3 id="1-if语句"><a href="#1-if语句" class="headerlink" title="1.if语句"></a>1.if语句</h3><p>有三种格式：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220108152638682.png" alt="image-20220108152638682"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220108152650310.png" alt="image-20220108152650310"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220108152659491.png" alt="image-20220108152659491"></p>
<h3 id="2、switch语句"><a href="#2、switch语句" class="headerlink" title="2、switch语句"></a>2、switch语句</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220108152728036.png" alt="image-20220108152728036"></p>
<p>switch(表达式)中表达式的值必须是下述几种类型之一：byte short char，int，枚举 (jdk 5.0)，String (jdk7.0)；</p>
<p> case子句中的值必须是常量，不能是变量名或不确定的表达式值； </p>
<p>同一个switch语句，所有case子句中的常量值互不相同； </p>
<p>break语句用来在执行完一个case分支后使程序跳出switch语句块；如果没有break，程序会顺序执行到 switch结尾 </p>
<p>default子句是可任选的。同时，位置也是灵活的。当没有匹配的case时，执行default。</p>
<h3 id="练习1-："><a href="#练习1-：" class="headerlink" title="练习1 ："></a><strong>练习1 ：</strong></h3><p>​		1、如果成绩在90分以上是A,80分以上是B,70分以上是C,60分以上是D,其他 E </p>
<p>​		2、今天是周末还是工作？如果是周末，如果气温大于36度，就游泳，否则就爬山，如果是工作日，看看天气好嘛？如果天气好，就去拜访客户，如果天气不好，就在单位查资料。</p>
<p>​		3、飞机票的原价是 5000元，12-3旺季 旺季头等舱打折扣9折，经济舱是8折 其余时间是淡季， 头等舱，打5折，经济舱打四折用户输入出行的月份，选择头等舱还是经济舱，请输出用户应支付的机票 的价格 请输入出行的月份: 3 请选择 1.头等舱 2.经济舱 您的机票的价格为:4500元 </p>
<p>​	4、如果考试考了第一名，奖励一个笔记本，如果第二名，奖励一个移动硬盘，如果第三名，奖励了一个U盘，否则没任何奖励。 </p>
<h3 id="练习2-："><a href="#练习2-：" class="headerlink" title="练习2 ："></a><strong>练习2 ：</strong></h3><p>​		1、输入今天星期几？一三五，吃鱼。二四六吃肉。日吃素 </p>
<p>​		2、商场搞活动，换购活动，1. 满50元，可以加两元换购一瓶矿泉水，2.满100元，可以加五元换 购一瓶矿泉水，3.满100元，加10元换购炒锅一个，4.满200元，可以加5元换购一瓶爽肤水，5.满200 元，加10元换购保温壶一个 0不换购。 </p>
<p>​		3、输入三个数，然后按照从小到大顺序输出三个数。 </p>
<p>​		4、输入一个四位数，如果这个四位数和随机生成的一个数相同，则终奖了 </p>
<h3 id="练习3："><a href="#练习3：" class="headerlink" title="练习3："></a><strong>练习3：</strong></h3><ol>
<li></li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220108152936000.png" alt="image-20220108152936000"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220108152948347.png" alt="image-20220108152948347"></p>
<ol start="2">
<li></li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220108153044952.png" alt="image-20220108153044952"></p>
<p>3、设计一个迷你计算器</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220108153101079.png" alt="image-20220108153101079"></p>
<p>3、从键盘分别输入判断一年是否是闰年的标准：</p>
<p>​		1）可以被4整除，但不可被100整除或 </p>
<p>​		2）可以被400 整除 </p>
<p>4、假设你想开发一个玩彩票的游戏，程序随机地产生一个两位数的彩票，提示用户输入一个两位数，然 后按照下面的规则判定用户是否能赢。 </p>
<p>​		1)如果用户输入的数匹配彩票的实际顺序，奖金10 000美元。 </p>
<p>​		2)如果用户输入的所有数字匹配彩票的所有数字，但顺序不一致，奖金 3 000美元。 </p>
<p>​		3)如果用户输入的一个数字仅满足顺序情况下匹配彩票的一个数字，奖金1 000美元。 </p>
<p>​		4)如果用户输入的一个数字仅满足非顺序情况下匹配彩票的一个数字，奖金500美元。 </p>
<p>​		5)如果用户输入的数字没有匹配任何一个数字，则彩票作废。</p>
<p> 提示：使用Math.random() 产生随机数</p>
<p> Math.random() 产生[0,1)范围的随机值 </p>
<p>Math.random() * 90：[0,90) </p>
<p>Math.random() * 90 + 10：[10,100) 即得到 [10,99] </p>
<p>使用(int)(Math.random() * 90 + 10)产生一个两位数的随机数。 </p>
<p>5、提供三个1-6的随机数，作为掷骰子得到的点数。</p>
<p>​		如果各个点数相同，则为豹子。 </p>
<p>​		如果三个骰子点数和，小于或等于9，则为“小”。 </p>
<p>​		如果三个骰子点数和，大于9，则为“大”。 </p>
<p>​		用户随机选择：押大、押小或者押豹子。通过判断，输出客户是否押正确。</p>
<p>​		 &#x2F;&#x2F;1、产生一个[1-6]的数 int a &#x3D; (int)(Math.random()*6+1); </p>
<p>6、编写一个程序，为一个给定的年份找出其对应的中国生肖。中国的生肖基于12年一个周期，每年用 一个动物代表：rat（鼠）、ox（牛）、tiger（虎）、rabbit（兔）、dragon（龙）、snake（蛇）、 horse（马）、sheep（羊）、monkey（候）rooster（鸡）、dog（狗）、pig（猪）。</p>
<p>​		提示：2019 年：猪 2019 % 12 &#x3D;&#x3D; 3 </p>
<p>7、随机生成一个100以内的数，猜数字游戏：从键盘输入数，如果大了提示，大了，如果小了，提示小 了，如果对了，就不再猜了，并统计一共猜了多少次？提示：随机数 </p>
<p>8、一个数如果恰好等于它的因子之和，这个数就称为”完数”。（因子：除去这个数本身的约数）例如 6&#x3D;1＋2＋3.编程 找出1000以内的所有完数 </p>
<p>9、输入两个正整数m和n，求其最大公约数和最小公倍数 </p>
<h3 id="switch与if比较"><a href="#switch与if比较" class="headerlink" title="switch与if比较"></a><strong>switch与if比较</strong></h3><p>if和switch语句很像，具体什么场景下，应用哪个语句呢？ </p>
<p>如果判断的具体数值不多，而且符合byte、short 、char、int、String、枚举等几种类型。虽然两个语 句都可以使用，建议使用swtich语句。因为效率稍高。 其他情况：对区间判断，对结果为boolean类型 判断，使用if，if的使用范围更广。也就是说，使用switch-case的，都可以改写为if-else。反之不成立。 </p>
<h2 id="2、循环结构"><a href="#2、循环结构" class="headerlink" title="2、循环结构"></a><strong>2、循环结构</strong></h2><p>在某些条件满足的情况下，反复执行特定代码的功能。有三种循环，分布是while 循环，do-while循环 以及for循环。</p>
<p>循环会有四要素：初始化变量，循环条件，循环操作，改变变量的值防止死循环。 </p>
<p>生活中的循环：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220108153437109.png" alt="image-20220108153437109"></p>
<h3 id="1-gt-while循环"><a href="#1-gt-while循环" class="headerlink" title="1&gt;while循环"></a>1&gt;while循环</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220108153451153.png" alt="image-20220108153451153"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220108153501638.png" alt="image-20220108153501638"></p>
<p>特点：先判断再执行； </p>
<h3 id="2-gt-do-while"><a href="#2-gt-do-while" class="headerlink" title="2&gt;do-while"></a>2&gt;do-while</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220108153515759.png" alt="image-20220108153515759"></p>
<p>特点：先执行再判断</p>
<p> while循环和do-while循环的区别 </p>
<h3 id="3-gt-for循环"><a href="#3-gt-for循环" class="headerlink" title="3&gt;for循环"></a>3&gt;for循环</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220108153546189.png" alt="image-20220108153546189"></p>
<h2 id="3、跳转语句"><a href="#3、跳转语句" class="headerlink" title="3、跳转语句"></a><strong>3、跳转语句</strong></h2><p>break:改变程序控制流 </p>
<p>用于do-while、while、for中时，可跳出循环而执行循环后面的语句 用在switch语句中</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220108153611270.png" alt="image-20220108153611270"></p>
<p>continue，只能用在循环里面。作用：跳过循环体中剩余的语句而执行下一次循环</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220108153634021.png" alt="image-20220108153634021"></p>
<p>return：并非专门用于结束循环的，它的功能是结束一个方法。 </p>
<p>当一个方法执行到一个return语句时，这个方法将被结束。</p>
<p> 与break和continue不同的是，return直接结束整个方法，不管这个return处于多少层循环之内 </p>
<h2 id="练习：-1"><a href="#练习：-1" class="headerlink" title="练习："></a>练习：</h2><p>​		1、打印1-100之间的所有奇数的和 </p>
<p>​		2、打印1~100之间所有是7的倍数的整数的个数及总和（体会设置计数器的思想） </p>
<p>​		3、输出所有的水仙花数，所谓水仙花数是指一个3位数，其各个位上数字立方和等于其本身 </p>
<p>​				例如：153 &#x3D; 111 + 333 + 555 </p>
<p>​		4、从键盘读入个数不确定的整数，并判断读入的正数和负数的个数，输入为0时结束程序 </p>
<p>​		5、用户登录系统，最多输入三次用户名与密码，提醒用户登录是否成功，以及还有几次机会。 </p>
<p>​		6、实现循环购物(第二章练习)</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220108153731332.png" alt="image-20220108153731332"></p>
<pre><code>     7、 假设一个简单的ATM机的取款过程是这样的：首先提示用户输入密码(password)，最多只能输入 三次，超过三次则提示用户“密码错误，请取卡”结束交易。如果用户密码正确，再提示用户输入金额 (amout)，ATM机只能输出100元的纸币，一次取钱要求最低0元，最高1000元，如果用户输入的金额符 合上述要求，则打印输出用户取的钱数，最后提示用户“交易完成，请取卡”，否则提示用户重新输入金 额。假设用户密码是111111。
 
     8、 编写JAVA程序，实现输出1--100之间所有不能被7整除的数，并求和要求：每输出4个数据换行显
</code></pre>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220108153754770.png" alt="image-20220108153754770"></p>
<p>​		9、求阶乘</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220108153811593.png" alt="image-20220108153811593"></p>
<p>​		 10、实现菜单循环</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220108153828521.png" alt="image-20220108153828521"></p>
<p>二重循环：打印九九乘法表</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220108153916237.png" alt="image-20220108153916237"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220111165134257.png" alt="image-20220111165134257"></p>
<h1 id="四、数组"><a href="#四、数组" class="headerlink" title="四、数组"></a>四、数组</h1><h2 id="1、数组的概述"><a href="#1、数组的概述" class="headerlink" title="1、数组的概述"></a>1、数组的概述</h2><p>在执行程序的过程中，经常需要存储大量的数据，例如，假设需要读取100个数，计它们的平均值，然 后找出有多少个数大于平均值。首先，程序读入这些书并且计算它们的平均值，然后将每个数与平均值 进行比较判断它是否大于平均值。为了完成这个任务，必须将全部的数据存储到变量中。必须声明100 个变量，并且重复书写100次几乎完全相同的代码。这样编写程序的方式似乎是不太现实的，那么该如 何解决这个问题呢？</p>
<p> Java和许多高级语言都提供了一种称作数据（array）的数据结构，可以用它来存储一个元素个数固定且 元素类型下相同的有序集。数组主要解决多变量多数据的存储问题，方便程序后期统一维护操作数据。 数组的本质是什么呢？数组就是一系列空间大小相等且地址连续的一片存储空间。为什么空间大小是相 等的呢？就是为了方便统一维护我们的数据，必须得保证数据之间的类型是一样的。为什么变量空间的 地址是连续的呢？地址连续切大小相等方便计算后续元素的具体物理内存地址。</p>
<p> 数组就是一片地址连续且空间大小一致的存储空间(但是每个空间存的还是其他数据的地址。数组存在于 堆内存中，但凡在堆中存储的数据都称之为对象。数组提供下标来访问数组当中的元素。数组变量存的 就是数组在堆内存中首元素的地址。数组通过下标来访问元素的具体计算方式是：所要访问数据的地址 &#x3D; 首元素地址 + 下标 * 数据类型大小。数组一旦定义下来，其长度不可改变；数组中有几个地址？就看 数组有几个元素空间（数组的长度）。创建数组时必须明确规定大小或内容。</p>
<h2 id="2、一维数组的使用"><a href="#2、一维数组的使用" class="headerlink" title="2、一维数组的使用"></a>2、一维数组的使用</h2><p><strong>创建数组只指定长度但不指定内容</strong> 数据类型[] 数组名 &#x3D; new 数据类型[长度]; </p>
<p><strong>创建数组指定内容</strong>(同时长度就确定了) </p>
<p>数据类型[] 数组名 &#x3D; new 数据类型[]{数据1, 数据2, 数据3, …, 数据n}; </p>
<p>数据类型[] 数组名 &#x3D; {数据1, 数据2, 数据3, …, 数据n} </p>
<p>数组默认值</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220108154111832.png" alt="image-20220108154111832"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220108154121749.png" alt="image-20220108154121749"></p>
<p>定义并用运算符new为之分配空间后，才可以引用数组中的每个元素；</p>
<p>数组元素的引用方式：数组名[数组元素下标] </p>
<p>数组元素下标可以是整型常量或整型表达式。如a[3] , b[i] , c[6*i];</p>
<p> 数组元素下标从0开始；长度为n的数组合法下标取值范围: 0 —&gt;n-1；如int a[]&#x3D;new int[3]; 可引用的数 组元素为a[0]、a[1]、a[2] </p>
<p>每个数组都有一个属性length指明它的长度，例如：a.length 指明数组a的长度(元素个数) </p>
<p>数组一旦初始化，其长度是不可变的 </p>
<h2 id="3、一维数组内存分析"><a href="#3、一维数组内存分析" class="headerlink" title="3、一维数组内存分析"></a>3、一维数组内存分析</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220108154207485.png" alt="image-20220108154207485"></p>
<p><strong>目前关注：方法区，虚拟机栈，堆</strong> </p>
<p>栈stack:局部变量 </p>
<p>堆heap:new出来的结构 </p>
<p>方法区：method area 静态域 常量池 类的元数据</p>
<h2 id="4、一维数组操作"><a href="#4、一维数组操作" class="headerlink" title="4、一维数组操作"></a><strong>4、一维数组操作</strong></h2><p>​		1&gt; 数组遍历 </p>
<p>​		2&gt;查找数组中的最大值和最小值</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220108154415032.png" alt="image-20220108154415032"></p>
<p>​	3&gt;查找元素在数组中是否存在</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220108154431147.png" alt="image-20220108154431147"></p>
<p>​		4&gt;数组倒着输出</p>
<p>​		5&gt;数组添加元素，修改元素，以及删除元素</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220108154447248.png" alt="image-20220108154447248"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220108154631184.png" alt="image-20220108154631184"></p>
<p>​		 6&gt;数组元素复制</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220108154645368.png" alt="image-20220108154645368"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220114095442324.png" alt="image-20220114095442324"></p>
<h3 id="练习：-2"><a href="#练习：-2" class="headerlink" title="练习："></a>练习：</h3><p>1&gt;循环录入8个成绩，查找到最大值最小值值，以及其位置 </p>
<p>2&gt;输入五个成绩，求总分，以及按照从小到大排序 </p>
<p>3&gt;给定一个数列3，4，12，56，45 用户输入要查找的数，判断该数在该数列中是否存在 </p>
<p>4&gt;用户输入十个汉字，分别统计 王，李，张的姓氏的个数，其他均认为是非法字符，统计非法字符的 个数 </p>
<p>5&gt;有五种水果，apple,pear,banana,orange,mango按英文字母排列 这五种水果 </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220113144029491.png" alt="image-20220113144029491"></p>
<p>6&gt;输入五句话，然后倒着输出 </p>
<p>7&gt;实现如下功能：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220108155235177.png" alt="image-20220108155235177"></p>
<p>8&gt;阅读代码，直接写出结果</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220108155248477.png" alt="image-20220108155248477"></p>
<p> 9&gt;从键盘读入学生成绩，找出最高分，并输出学生成绩等级。成绩&gt;&#x3D;最高分-10 等级为’A’ 成绩&gt;&#x3D;最高 分-20 等级为’B’ 成绩&gt;&#x3D;最高分-30 等级为’C’ 其余 等级为’D’</p>
<p>10&gt;打印斐波那契数列 1, 1, 2, 3, 5, 8, 13, 21, 34, 55 </p>
<p>11&gt;创建要给长度为6的int类型数组，要求数组元素的值再1-30之间，且随机赋值。同时要求数组元 素各不相同</p>
<p>12、数组反转：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220111175351166.png" alt="image-20220111175351166"></p>
<p> 13、数组查找【线性查找与二分查找】 </p>
<p>二分查找：数组是有序的。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220111175420442.png" alt="image-20220111175420442"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220111175427182.png" alt="image-20220111175427182"></p>
<h2 id="排序算法：十大内部排序算法"><a href="#排序算法：十大内部排序算法" class="headerlink" title="排序算法：十大内部排序算法"></a>排序算法：十大内部排序算法</h2><p> 选择排序【直接选择排序，堆排序】 </p>
<p>交换排序【冒泡排序，快速排序 (手写代码)】</p>
<p> 插入排序【直接插入排序，折半插入排序，希尔排序】 </p>
<p>归并排序 </p>
<p>桶式排序 </p>
<p>基数排序</p>
<p>1&gt;冒泡排序</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220108155318090.png" alt="image-20220108155318090"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220111175514841.png" alt="image-20220111175514841"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220111175520596.png" alt="image-20220111175520596"></p>
<p>2&gt; 选择排序</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220111175531687.png" alt="image-20220111175531687"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220111175539005.png" alt="image-20220111175539005"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220111175544789.png" alt="image-20220111175544789"></p>
<p>3&gt; 插入排序</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220111175601483.png" alt="image-20220111175601483"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220111175608424.png" alt="image-20220111175608424"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220111175614819.png" alt="image-20220111175614819"></p>
<p> 4&gt; 快速排序【使用递归】</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220111175913536.png" alt="image-20220111175913536"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220111175738797.png" alt="image-20220111175738797"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220111175749603.png" alt="image-20220111175749603"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220111175937662.png" alt="image-20220111175937662"></p>
<h2 id="5、二维数组"><a href="#5、二维数组" class="headerlink" title="5、二维数组"></a>5、二维数组</h2><p>Java 语言里提供了支持多维数组的语法。如果说可以把一维数组当成几何中的线性图形，那么二维数组 就相当于是一个表格，像右图Excel中的表格一样。对于二维数组的理解，我们可以看成是一维数组 array1又作为另一个一维数组array2的元素而存在。其实，从数组底层的运行机制来看，其实没有多维 数组。 </p>
<p>格式1（动态初始化）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220117145305390.png" alt="image-20220117145305390"></p>
<p>定义了名称为arr的二维数组二维数组中有3个一维数组 每一个一维数组中有2个元素一维数组的名称分别为arr[0], arr[1], arr[2]给第一个一维数组1脚标位赋值 为78写法是：arr[0][1] &#x3D; 78; </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220117145332628.png" alt="image-20220117145332628"></p>
<p>格式2（动态初始化）：</p>
<p>int[][] arr &#x3D; new int[3][];二维数组中有3个一维数组。每个一维数组都是默认初 始化值null (注意：区别于格式1） </p>
<p>可以对这个三个一维数组分别进行初始化arr[0] &#x3D; new int[3]; arr[1] &#x3D; new int[1]; arr[2] &#x3D; new int[2];</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220111180016545.png" alt="image-20220111180016545"></p>
<p>练习：1.打印杨辉三角<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220111180207529.png" alt="image-20220111180207529"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220111180217786.png" alt="image-20220111180217786"></p>
<h1 id="五、初步认识初始面向对象"><a href="#五、初步认识初始面向对象" class="headerlink" title="五、初步认识初始面向对象"></a>五、初步认识初始面向对象</h1><h2 id="1、面向对象和面向过程"><a href="#1、面向对象和面向过程" class="headerlink" title="1、面向对象和面向过程"></a>1、面向对象和面向过程</h2><p>面向过程也是解决问题的一种思想，当我们在解决问题时，会按照预先设定的想法和步骤，一步一步去 实现，而具体的每一步都需要我们去实现和操作。这些步骤相互调用和协作，完成我们的需求。上述描 述的每一个具体步骤我们都是参与者，并且需要面对具体的每一个步骤和过程，这就是面向过程最直接 的体现。通过上面简单的描述发现，面向过程，其实就是面向着具体的每一个步骤和过程，就是面对具 体的每一个功能函数。这些功能函数相互调用，完成需求。 </p>
<p>面向对象当不再面对具体的每一个方法时，发现操作也变的简单了很多。而封装具体功能的这类，是我 们需要面对的。而基于这个封装了具体功能的类，那怎么使用呢？当面向封装了具体功能类，若要使用 这个类，一般情况下，在Java中需要通过创建这个类的实体来使用。这个实体称之为对象。在开发中， 我们是在不断的找封装不同功能的类。基于这些类，创建其对象，使用这些对象完成相应的操作。通过 上面的讲解和分析得出：<strong>面向对象是基于面向过程，对象是将功能进行了封装。</strong>只要找到了具体的类， 创建出对象，就可以调用其中的具体功能。面向对象也是用来解决问题的一种思维模式。在以后开发 中，先找对象，调用对象中的具体功能。如果真的没有能够完成需求的对象，这时就自己创建对象，并 将所需的功能定义到对象中，方便以后使用。 </p>
<p>面向对象是一种更符合人们思考习惯的思想面向过程中更多的体现的是执行者，面向对象中更多的体现 是指挥者。指挥对象做事情面向对象将复杂的问题简单化在面向对象的世界中：万事皆对象。 </p>
<p>面向对象和面向过程，其实都是一种思想。面向对象是相对面向过程而言的。面向过程，强调的是功能 行为，以函数为最小单位，考虑怎么做。面向对象，将功能封装到对象中，强调具备了功能的对象，以 类&#x2F;对象为最小的单位，考虑谁来做。 </p>
<p>面向对象分析和设计的思路： </p>
<p>根据问题需要，选择问题所针对的现实世界中的实体。</p>
<p>从实体中寻找解决问题相关的属性和功能，这些属性和功能就形成的概念世界中的类。 </p>
<p>把抽象的实体用计算机语言进行描述，形成计算机世界中类的定义。即借助某种程序语言，把类构造成 计算机能够识别和处理的数据结构。 </p>
<p>把类实例化成计算机世界中的对象，对象是计算机世界中解决问题的最终工具。</p>
<h2 id="2、-类和对象的关系"><a href="#2、-类和对象的关系" class="headerlink" title="2、 类和对象的关系"></a>2、 类和对象的关系</h2><p>面向对象程序设计（OOP）就是使用对象进行程序设计。<strong>对象（Object）代表现实世界中可以明确标识 的一个实体。</strong>例如：一个学生、一张桌子、一个圆、一个按钮甚至是一笔贷款都可以看作是一个对象。 每个对象都有自己独特的标识、状态和行为。一个对象的状态（state，也称为特征（property）或者属 性（arrtibute））是由具有当前值的数据域来表示的。例如：圆对象具有一个数据域radius，它是标识 圆的属性。一个矩形对象具有数据域width和height，它们都是描述矩形的属性。我们一般把对象的特有 属性称之为成员变量。 </p>
<p>一个对象的行为（behavior，也称为动作（action））是由方法定义的。调用对象的一个方法就是要求 对象完成一个动作。例如：可以为圆对象定义一个名为getArea()和getPerimeter()的方法。圆对象可以 调用getArea()返回圆的面积，调用getPerimeter()返回它的周长。我们一般把对象的行为称之为成员函 数。 </p>
<p>使用一个通用类来定义同一类型的对象。类是一个模板、蓝本或者说是合约，用来定义对象的数据域是 什么以及方法是做什么的。一个对象是类的一个实例。可以从一个类中创建多个实例。创建实例的过程 称为实例化。对象和实例经常是可以互换的。 </p>
<p>类是用于描述现实事物的，它将现实事物进行抽象化，模板化描述。将事物的特点（属性）和行为封装 在其中。比如小汽车的图纸，图纸就是小汽车的模版。图纸上画着小汽车的各种特点和功能要求。 </p>
<p>Java类使用变量定义数据域，使用方法定义动作。除此之外，类还提供了一种称为构造方法 （constructor）的特殊类型的方法，调用它可以创建一个新对象。构造方法本身是可以完成任何动作 的，但是设计构造方法是为了完成初始化动作。</p>
<p>对象是现实生活中存在的具体的实例、个体。即生活看到每一个事物，以及我们想象中的任务抽象的概 念，都是某一类事物的实例和个体。而这些个体都属于某一类事物，即这些个体都是某一类事物中的具 体的实例。比如，小汽车就是一类事物，而小汽车又是基于小汽车图纸制造出来的真实个体。因此我们 生活中的每一个实物都可以理解为是某一类事物的中的一个个体。创建对象的，通过对象就可以调用具 体的属性和行为。 </p>
<p>类和对象是面向对象的核心概念。类是对一类事物的描述，是抽象的概念上的定义。对象是实际存在的 该类事物的每个个体，因而也称为实例。类是抽象的概念，对象是具体的概念。 </p>
<p>可以理解:类&#x3D;抽象概念的人，对象&#x3D;实实在在的某个人 </p>
<p>面向对象程序设计的重点是类的设计</p>
<p>类的设计，其实就是类的成员设计。常见的类的成员有：属性【类中的成员变量】，方法【行为，类中 的成员方法】。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220117145659074.png" alt="image-20220117145659074"></p>
<p>如果将对象比作汽车，那么类就是汽车的设计图纸。所以面向对象程序设计的重点是类的设计，而不是 对象的设计。<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220117145709494.png" alt="image-20220117145709494"></p>
<p>类是模子，规定对象将会拥有的属性和方法</p>
<h2 id="3、类的语法格式："><a href="#3、类的语法格式：" class="headerlink" title="3、类的语法格式："></a>3、类的语法格式：</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220117145732485.png" alt="image-20220117145732485"></p>
<p>java创建类的步骤： </p>
<p>定义类(考虑修饰符，类名) </p>
<p>编写类的属性(考虑修饰符，属性类型，属性名，初始化) </p>
<p>编写类的方法（考虑修饰符，返回值类型，方法名，形参等)。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220117145806016.png" alt="image-20220117145806016"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220117145838771.png" alt="image-20220117145838771"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220117145848947.png" alt="image-20220117145848947"></p>
<h3 id="练习：-3"><a href="#练习：-3" class="headerlink" title="练习："></a>练习：</h3><p>1、 创建一个汽车类，包含属性有 品牌 型号 价格 颜色 使用年限。打印输出车的信息 </p>
<p>2、创建一个人类，包含人的姓名，性别，年龄。包含的吃饭的方法，睡觉的方法 编写好类后，如何使用？需要创建类的对象以及调用属性和方法 </p>
<p>3、创建管理员类，包含属性 用户名和密码，有一个输出方法，打印输出管理员信息。[类的设 计] </p>
<p>[实现修改管理员密码，要求先登录，如果登录成功，有权限修改密码，否则不能修改 main] 。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220117145926714.png" alt="image-20220117145926714"></p>
<p>匿名对象：我们也可以不定义对象的引用，而直接调用这个对象的方法。这样的对象叫做匿名对象， 如：new Person().shout(); 如果对一个对象只需要进行一次方法调用，那么就可以使用匿名对象 。</p>
<p>4、编写学生类和教师类，并通过测试类创建对象进行测试</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220117150002147.png" alt="image-20220117150002147"></p>
<h2 id="4、成员变量"><a href="#4、成员变量" class="headerlink" title="4、成员变量"></a>4、成员变量</h2><p>成员变量又访问修饰符【后面详解】</p>
<p>可以是任意类型 </p>
<p>类中定义的变量称为成员变量，在方法中定义的变量是局部变量。成员变量和局部变量的区别。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220117150129394.png" alt="image-20220117150129394"></p>
<p>当一个对象被创建时，会对其中各种类型的成员变量自动进行初始化赋值。除了基本数据类型之外的变 量类型都是引用类型</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220117150151420.png" alt="image-20220117150151420"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220117150159549.png" alt="image-20220117150159549"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220117150213129.png" alt="image-20220117150213129"></p>
<h2 id="5、方法"><a href="#5、方法" class="headerlink" title="5、方法"></a>5、方法</h2><p>方法是类或对象行为特征的抽象，用来完成某个功能操作，在某些语言中也称为函数或过程。</p>
<p>将功能封装为方法的目的是，实现代码重用，简化代码。 </p>
<p>java中的方法不独立存在，所有的方法定义在类中。 </p>
<p>案例：榨汁机案例【举例】 </p>
<p>类的方法定义类的某种行为（或功能）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220117150253394.png" alt="image-20220117150253394"></p>
<p>方法分类: 按照有无返回值分类 ：1&gt; 无返回值 void 2&gt;有返回值 方法体最后加return。 </p>
<p>方法调用:方法是个黑匣子，完成某个特定的应用程序功能，并返回结果。方法通过方法名被调用。只有 被调用才会执行。 </p>
<p>调用方法就是执行方法中包含的语句。方法之间允许相互调用，不需要知道方法的具体实现，实现 宠重用，提高效率。 </p>
<p>方法之间存在相互调用，方法内部不能重复定义方法，只能调用另一个方法。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220117150334416.png" alt="image-20220117150334416"></p>
<p>方法重载：方法名相同，参数列表不同，与访问修饰符与返回值类型无关，形成方法的重载。 </p>
<p>如果一个方法调用自身，我们称为方法的递归调用。递归容易出现堆栈溢出，必须找到出口，结束 该方法的执行。 </p>
<p>方法递归包含了一种隐式的循环，它会重复执行某段代码，但这种重复执行无须循环控制。</p>
<p>递归一定要向已知方向递归，否则这种递归就变成了无穷递归，类似于死循环。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220117150425780.png" alt="image-20220117150425780"></p>
<h2 id="6、对象的创建和使用：内存解析"><a href="#6、对象的创建和使用：内存解析" class="headerlink" title="6、对象的创建和使用：内存解析"></a>6、对象的创建和使用：内存解析</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220117150442689.png" alt="image-20220117150442689"></p>
<p>堆（Heap），此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一 点在Java虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配。 </p>
<p>通常所说的栈（Stack），是指虚拟机栈。虚拟机栈用于存储局部变量等。局部变量表存放了编译期可知 长度的各种基本数据类型（boolean、byte、char 、 short 、 int 、 float 、 long 、double）、对象引 用（reference类型，它不等同于对象本身，是对象在堆内存的首地址）。 方法执行完，自动释放。 </p>
<p>方法区（Method Area），用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的 代码等数据。 </p>
<p>对象内存分析【初步】</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220117150516357.png" alt="image-20220117150516357"></p>
<h3 id="练习：-4"><a href="#练习：-4" class="headerlink" title="练习："></a>练习：</h3><p>1、创建客户类，有客户类型以及积分。现在回馈客户，如果是金卡积分在1000以上，或者是普 卡，积分在5000以上，可以获赠500积分。 </p>
<p>2、编写游客类，包括客户名和年龄，输出客户的门票价格，如果在12岁以下或60岁以上，门票 不要钱，否则门票打五折。【门票原价100元】 </p>
<p>3、编写一个Student类，包含name、gender、age、id、score属性，分别为String、String、 int、int、double类型。类中声明一个say方法，返回String类型，方法返回信息中包含所有属性值。 </p>
<p>4、创建Person类，有属性name,age,sex属性，调用study方法，输出客户信息，调用person的 showAage的方法，给age属性加1。 </p>
<p>5、利用面向对象的思想的编程方法，设计及时circle的圆面积和圆周长</p>
<p>6、创建银行客户类Account类，有卡号cid，余额 balance，密码password.有方法，返回卡号详 细信息，密码显示6个*。设计取钱和存钱的方法。该银行卡号是从属某个Customer类。其中Customer 类有姓名，身份证号，联系电话，家庭地址等属性，有say方法，可以输出个人信息。 </p>
<h2 id="7、对象数组"><a href="#7、对象数组" class="headerlink" title="7、对象数组"></a>7、对象数组</h2><p>数组的类型是自己定义的类的类型，也就是一组相关对象的集合。利用对象数组完成对学生信息的查 看，添加，修改，删除。</p>
<h3 id="练习：-5"><a href="#练习：-5" class="headerlink" title="练习："></a>练习：</h3><p>1、创建学术类，包含学号，姓名，年龄，成绩，创建5个学生，成绩右随机数生成。打印学生信 息，并按照成绩由小到大的顺序输出。 </p>
<p>2、设计计算器的类，可以实现两个数相加，三个数详解，四个数相加，若干个数详解</p>
<h2 id="8、动态参数"><a href="#8、动态参数" class="headerlink" title="8、动态参数"></a>8、动态参数</h2><p>JavaSE 5.0 中提供了Varargs(variable number of arguments)机制，允许直接定义能和多个实参相匹 配的形参。从而，可以用一种更简单的方式，来传递个数可变的实参。 </p>
<ol>
<li><p>声明格式：方法名(参数的类型名 …参数名) </p>
</li>
<li><p>可变参数：方法参数部分指定类型的参数个数是可变多个：0个，1个或多个 </p>
</li>
<li><p>可变个数形参的方法与同名的方法之间，彼此构成重载 </p>
</li>
<li><p>可变参数方法的使用与方法参数部分使用数组是一致的 </p>
</li>
<li><p>方法的参数部分有可变形参，需要放在形参声明的最后 </p>
</li>
<li><p>在一个方法的形参位置，最多只能声明一个可变个数形参</p>
</li>
</ol>
<h2 id="9、值传递和引用传递"><a href="#9、值传递和引用传递" class="headerlink" title="9、值传递和引用传递"></a>9、值传递和引用传递</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220117150938568.png" alt="image-20220117150938568"></p>
<p>形参是基本数据类型：将实参基本数据类型变量的“数据值”传递给形参 </p>
<p>形参是引用数据类型：将实参引用数据类型变量的“地址值”传递给形参</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220117151004539.png" alt="image-20220117151004539"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220117151022390.png" alt="image-20220117151022390"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220117151031703.png" alt="image-20220117151031703"></p>
<h3 id="练习：-6"><a href="#练习：-6" class="headerlink" title="练习："></a>练习：</h3><p>1、什么是方法重载 </p>
<p>2、java中参数传递的方式 </p>
<p>3、成员变量和局部变量的区别 </p>
<p>4、说说你对方法的理解</p>
<h1 id="六、封装"><a href="#六、封装" class="headerlink" title="六、封装"></a>六、封装</h1><h2 id="1、封装"><a href="#1、封装" class="headerlink" title="1、封装"></a>1、封装</h2><p>​		我们程序设计追求“高内聚，低耦合”。高内聚 ：类的内部数据操作细节自己完成，不允许外部干 涉；低耦合 ：仅对外暴露少量的方法用于使用。 </p>
<p>​		隐藏对象内部的复杂性，只对外公开简单的接口。便于外界调用，从而提高系统的可扩展性、可维 护性。通俗的说，把该隐藏的隐藏起来，该暴露的暴露出来。这就是封装性的设计思想。<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220117151210949.png" alt="image-20220117151210949"></p>
<p>面向对象特点–抽象 从许多事物中舍弃个别的、非本质的特征，抽取共同的、本质性的特征，就叫作抽 象。 抽象是形成类的必须手段。 面向对象就是对现实世界的一种抽象 使用面向对象的思想描述以上图 片</p>
<p>Java中通过将数据声明为私有的(private)，再提供公共的（public）方法:getXxx()<strong>和setXxx()<strong>实现 对该属性的操作，以实现下述</strong>目的：</strong></p>
<ul>
<li><p>隐藏一个类中不需要对外提供的实现细节； </p>
</li>
<li><p>使用者只能通过事先定制好的方法来访问数据，可以方便地加入控制逻辑，限制对属性的不合理操 作； </p>
</li>
<li><p>便于修改，增强代码的可维护性； </p>
</li>
<li><p>提高了代码的重用性 隐藏了实现细节，对外提供访问的方式。</p>
</li>
</ul>
<p>如在以前的代码中，将属性直接定义在类中，用户在创建对象的时候，可以给属性任意赋值，如 age，用户在创建对象的时候，赋值为-20，该值就是一个非法的值。此时可以使用封装。 </p>
<p><strong>封装的步骤：</strong></p>
<p>​		1)属性private </p>
<p>​		2)提供get&#x2F;set方法</p>
<p>​		3)在方法中加入流程控制语句 </p>
<p><strong>封装特点：</strong> </p>
<ul>
<li>隐藏一个类的实现细节；</li>
<li>调用者只能通过事先定制好的方法来访问数据，可以方便地加入控制逻辑，限制对属性的不合理操 作； </li>
<li>便于修改，增强代码的可维护性；</li>
</ul>
<p> 四种访问修饰符：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220117151447781.png" alt="image-20220117151447781"></p>
<p>对于class的权限修饰只可以用public和default(缺省)。 public类可以在任意地方被访问。 default 类只可以被同一个包内部的类访问</p>
<h3 id="练习：-7"><a href="#练习：-7" class="headerlink" title="练习："></a>练习：</h3><p>1、创建一个学生类，设置学生的成绩在0-100之间 </p>
<p>2、创建一个人类，人类的年龄在0-130之间</p>
<h2 id="2、构造方法"><a href="#2、构造方法" class="headerlink" title="2、构造方法"></a>2、构造方法</h2><p>在开发中经常需要在创建对象的同时明确对象的属性值，比如员工入职公司就要明确他的姓名、年 龄等属性信息。创建对象就要明确属性值，那怎么解决呢？也就是在创建对象的时候就要做的事情，当 使用new关键字创建对象时，怎么给对象的属性初始化值呢？这就要学习Java另外一门小技术，构造函 数。那什么是构造函数呢？从字面上理解即为构建创造时用的函数，即就是对象创建时要执行的函数。 既然是对象创建时要执行的函数，那么只要在new对象时，知道其执行的构造函数是什么，就可以在执 行这个函数的时候给对象进行属性赋值</p>
<p>构造方法特征：名字和类名保持一致，没有返回值类型 不能被static,final,等修饰，不能有return 语句</p>
<p>构造方法的作用：创建对象，对对象进行初始化。 带参构造方法可以给属性赋值。</p>
<p>语法格式：修饰符 	类名(参数列表){ </p>
<p>​									初始化语句; </p>
<p>​									}</p>
<p>隐式无参构造方法（系统默认提供） </p>
<p>显示定义一个或多个构造方法（无参，有参）</p>
<p><strong>注意：</strong></p>
<ul>
<li><p>Java语言中，每个类都至少有一个构造方法</p>
</li>
<li><p>一个类中如果没有定义构造方法，默认的有一个public修饰的无参的构造方法。 </p>
</li>
<li><p>在一个类中可以定义多个构造方法，形成方法的重载。 </p>
</li>
<li><p>如果在类中定义构造方法后，默认的无参构造方法就不存在了。</p>
</li>
<li><p>构造方法不能被继承</p>
</li>
</ul>
<p><strong>JavaBean:</strong></p>
<ul>
<li><p>是一种java语言写成的可重用组件 </p>
</li>
<li><p>所谓javaBean是指复合如下标准的java</p>
</li>
<li><p>类 类是公共的，public修饰</p>
</li>
<li><p>有一个无参的默认构造方法 </p>
</li>
<li><p>属性私有化，提供相应的get|set方法</p>
</li>
</ul>
<h2 id="3、this关键字"><a href="#3、this关键字" class="headerlink" title="3、this关键字"></a>3、this关键字</h2><p>this:代表当前对象 </p>
<p>可以通过this调用属性，方法，以及构造方法。 </p>
<p>通过this调用构造方法，必须放在语句的第一行。</p>
<p> 在java中，this关键字是比较难理解的，他在方法内部使用，即这个方法所属对象的应用。在 构造方法总使用，表示该构造方法正在初始化的对象。</p>
<p> 如果成员变量和局部变量同名的时候，可以使用this来区分。 </p>
<p><strong>总结：</strong></p>
<ul>
<li><p>可以在类的构造器中使用”this(形参列表)”的方式，调用本类中重载的其他的构造器！ </p>
</li>
<li><p>明确：构造器中不能通过”this(形参列表)”的方式调用自身构造器 </p>
</li>
<li><p>如果一个类中声明了n个构造器，则最多有 n - 1个构造器中使用了”this(形参列表)” </p>
</li>
<li><p>“this(形参列表)”必须声明在类的构造器的首行！ </p>
</li>
<li><p>在类的一个构造器中，最多只能声明一个”this(形参列表)”</p>
</li>
</ul>
<h2 id="4、-包与import"><a href="#4、-包与import" class="headerlink" title="4、 包与import"></a>4、 包与import</h2><p>package语句作为Java源文件的第一条语句，指明该文件中定义的类所在的包。(若缺省该语句， 则指定为无名包)。它的格式为：package xxx.xxx.xxx;</p>
<p> 包对应于文件系统中的目录，package语句中，用”.”来指明包(目录)的层次。 </p>
<p>包通常用小写单词标识，通常使用所在公司网址的倒置。com.openlab</p>
<p><strong>作用：</strong></p>
<ul>
<li>包帮助管理大型，将功能相近的类放到一个包中 </li>
<li>便于管理类 </li>
<li>解决类命名冲突问题 </li>
<li>控制访问权限</li>
</ul>
<p>使用import导入不同的包下的类</p>
<h3 id="练习：-8"><a href="#练习：-8" class="headerlink" title="练习："></a>练习：</h3><p>1、编写一个类Teacher，代表教员，要求如下：a) 具有属性：姓名，年龄，其中年龄不能 小于26岁，否则输出错误信息b) 具有方法：自我介绍，负责输出该教员的年龄，姓名c) 编写测试类 TeacherTest进行测试，看是否符合要求。 </p>
<p>2、编写一个类Teacher2，代表教员，要求如下a) 具有属性：姓名，年龄，性别和专业 b) 具有方法：自我介绍，负责输出该教员的年龄，姓名，性别和专业c) 具有两个带参的构造方法，第一个 构造方法中，设置教员的性别为男，专业为Java，其余属性的值由参数给定，第二个构造方法中，所有 属性的值都由参数给定d) 编写测试类Teacher2Test，分别以两种方式完成对两个Teacher2对象的初始 化工作，并分别调用它们的自我介绍方法，看看输出结果是否正确。 </p>
<p>3、使用面向对象的思想描述游戏中的怪物问题描述某公司要开发新游戏，请用面向对象的思 想设计怪物类，设定属性包括：怪物名字、生命值、攻击力、 防御力；方法包括：攻击的方法，防御的 方法.</p>
<p>​	要求：</p>
<ul>
<li>通过构造函数实现属性赋值 </li>
<li>攻击方法，描述攻击状态。内容包括怪物名字，生命值，攻 击力 </li>
<li>防御方法通过输入参数接收攻击力。需要判断，如果攻击力小 于防御力，伤害值&#x3D;0；反之伤害值&#x3D;攻击力 -防御力 根据伤害值情		况，显示不同的防御信息。内容包括怪物名字， 防御力，防御后的生命值.</li>
<li>编写测试方法，通过构造函数实例化怪物类的对象，并调用相关方法（测 试数据信息自定）运行效果：</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220117152232586.png" alt="image-20220117152232586"></p>
<p>4、简述你对this关键字的理解 </p>
<p>5、说说构造方法的特点</p>
<p>6、以下方法执行的结果是什么？</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220122195852734.png" alt="image-20220122195852734"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220122195900467.png" alt="image-20220122195900467"></p>
<h1 id="七、继承"><a href="#七、继承" class="headerlink" title="七、继承"></a>七、继承</h1><h2 id="1、继承的含义"><a href="#1、继承的含义" class="headerlink" title="1、继承的含义"></a>1、继承的含义</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220117152330642.png" alt="image-20220117152330642"></p>
<p>设计如下类：狗狗类 企鹅类 猫类。可以使用继承来简化代码。 </p>
<p>为什么需要继承：</p>
<p>​		多个类中存在相同的属性和行为的时候，讲这些内容抽取到一个单独的一个类 中。那么多个类无需再定义这些属性和行为，只要继		承即可。这个单独的类称作父类，其他类叫做子 类。可满足 is - a 的关系即可用继承实现。使用extends实现继承。</p>
<p><strong>作用:</strong></p>
<ul>
<li><p>使用继承的出现减少了代码冗余，提高的了代码的复用性。 </p>
</li>
<li><p>继承的出现，更有利于功能的扩展 </p>
</li>
<li><p>继承的出现让类和类之间产生了关系，提供了多态的前提。</p>
</li>
</ul>
<p>子类继承了父类，就继承了父类的方法和属性。</p>
<p>在子类中，可以使用父类中定义的方法和属性，也可以创建新的数据和方法。 </p>
<p>在java中，使用extends实现继承。子类继承父类，是对父类的扩展。 </p>
<p><strong>继承规则：</strong></p>
<ul>
<li>private修饰的不能继承。构造方法不继承。</li>
<li>java是单继承和多层继承。不能多继承。 </li>
<li>一个子类只能继承一个父类 </li>
<li>一个父类可以有多个子类。</li>
</ul>
<h3 id="练习：-9"><a href="#练习：-9" class="headerlink" title="练习："></a>练习：</h3><p>1、设计学生类，学生类继承自人类，人类中包含属性，姓名，性别，年龄，有输出人基本 信息的方法。学生继承了人类，还有属性，学号，成绩。同时也输出学生的信息</p>
<h2 id="2、super"><a href="#2、super" class="headerlink" title="2、super"></a>2、super</h2><p>super作用 </p>
<ul>
<li>在Java类中使用super来调用父类中的指定操作： </li>
<li>super可用于访问父类中定义的属性 </li>
<li>super可用于调用父类中定义的成员方法 </li>
<li>super可以用在子类构造器中调用父类中的构造器 <ul>
<li>尤其当父子类出现同名成员时，可以用super表明调用的是父类中的成员</li>
</ul>
</li>
<li>super的追溯不仅限于直接父类。 </li>
<li>super和this的用法相像，this代表本类对象的引用，super代表父类的内存空间的标识</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220122195938436.png" alt="image-20220122195938436"></p>
<p>通过super调用父类的构造器： </p>
<ul>
<li><p>子类中所有的构造器<strong>默认</strong>都会访问父类中<strong>空参数</strong>的构造器 </p>
</li>
<li><p>当父类中没有空参数的构造器时，子类的构造器必须通过this(参数列表)或者super(参数列表) 语句指定调用本类或者父类中相的构造器。同时，只能”二选一”，且必须放在构造器的首行 </p>
</li>
<li><p>如果子类构造方法即无显示调用父类活本类的其他构造方法，且父类中又没有无参构造方法， 则编译错误。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220122195957571.png" alt="image-20220122195957571"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220122200004912.png" alt="image-20220122200004912"></p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220122200017608.png" alt="image-20220122200017608"></p>
<p>父类的构造方法都会被执行到。 </p>
<p>this与super的区别</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220117152858990.png" alt="image-20220117152858990"></p>
<h2 id="3、方法重写"><a href="#3、方法重写" class="headerlink" title="3、方法重写"></a>3、方法重写</h2><p>在子类中可以根据需要对从父类中继承来的方法进行改造，也称为方法的重置、覆盖。在程序执 行时，子类的方法将覆盖父类的方法。</p>
<ol>
<li><p>子类重写的方法必须和父类被重写的方法具有相同的方法名称、参数列表 </p>
</li>
<li><p>子类重写的方法的返回值类型不能大于父类被重写的方法的返回值类型 </p>
</li>
<li><p>子类重写的方法使用的访问权限不能小于父类被重写的方法的访问权限子类不能重写父类 中声明为private权限的方法 </p>
</li>
<li><p>子类方法抛出的异常不能大于父类被重写方法的异常 </p>
</li>
<li><p>static方法是属于类的，子类无法覆盖父类的方法。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220122200044178.png" alt="image-20220122200044178"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220122200051484.png" alt="image-20220122200051484"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220122200100231.png" alt="image-20220122200100231"></p>
</li>
</ol>
<h3 id="练习"><a href="#练习" class="headerlink" title="练习:"></a>练习:</h3><p>1、某汽车租赁公司出租多种车辆，车型及租金情况如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220122200247448.png" alt="image-20220122200247448"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220122200259027.png" alt="image-20220122200259027"></p>
<h2 id="4、访问修饰符"><a href="#4、访问修饰符" class="headerlink" title="4、访问修饰符"></a>4、访问修饰符</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220117153045707.png" alt="image-20220117153045707"></p>
<h2 id="5、对象实例化过程"><a href="#5、对象实例化过程" class="headerlink" title="5、对象实例化过程"></a>5、对象实例化过程</h2><p>1&gt;子类继承父类后，就获取了父类中声明的属性和方法 </p>
<p>2&gt;创建子类的对象，再堆空间中，就会加载所有父类中声明的属性 </p>
<p>3&gt;当我们通过子类的构造方法创建子类对象时，我们一定会直接或间接的调用其父类的构造方法， 进而调用父类的构造方法，直到调用了Object类中的无参构造方法为止。真是因为加载过所有的父类结 构，所以才可以看到内存中有父类中的结构，子类对象才可以考虑进行调用。虽然子类调用了父类的构 造方法，但是并没有创建父类的对象。 </p>
<p>无论通过哪个构造器创建子类对象，需要保证先初始化父类。</p>
<h2 id="6、抽象类"><a href="#6、抽象类" class="headerlink" title="6、抽象类"></a>6、抽象类</h2><p>抽象类用abstract修饰。抽象类不能直接new对象。抽象类中的方法不一定都是抽象方法.</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220122200325590.png" alt="image-20220122200325590"></p>
<p><strong>抽象类的特点</strong></p>
<ol>
<li>抽象类和抽象方法都需要被abstract修饰。抽象方法一定要定义在抽象类中。 </li>
<li>抽象类不可以创建实例，原因：调用抽象方法没有意义。 </li>
<li>只有覆盖了抽象类中所有的抽象方法后，其子类才可以实例化。否则该子类还是一个抽象类。</li>
</ol>
<p>之所以继承，更多的是在思想，是面对共性类型操作会更简单</p>
<p><strong>细节问题：</strong></p>
<ol>
<li><p>抽象类一定是个父类？是的，因为不断抽取而来的。</p>
</li>
<li><p>抽象类是否有构造函数？有，虽然不能给自己的对象初始化，但是可以给自己的子类对象初始化。 抽象类和一般类的<strong>异同点：</strong></p>
<p>相同：它们都是用来描述事物的。它们之中都可以定义属性和行为。 </p>
<p>不同：一般类可以具体的描述事物。抽象类描述事物的信息不具体抽象类中可以多定义一个成员：抽象 函数。一般类可以创建对象，而抽象类不能创建对象。</p>
</li>
<li><p>抽象类中是否可以不定义抽象方法。是可以的，那这个抽象类的存在到底有什么意义呢？仅仅是不 让该类创建对象。 </p>
</li>
<li><p>抽象关键字abstract不可以和哪些关键字共存？final：fianl修饰的类是无法被继承的，而abstract 修饰的类一定要有子类.final修饰的方法无法被覆盖，但是abstract修饰的方法必须要被子类去实现 的。static：静态修饰的方法属于类的，它存在与静态区中，和对象就没关系了。而抽象方法没有 方法体，使用类名调用它没有任何意义。private：私有的方法子类是无法继承到的，也不存在覆 盖，而abstract和private一起使用修饰方法，abstract既要子类去实现这个方法，而private修饰子 类根本无法得到父类这个方法。互相矛盾。 </p>
</li>
<li><p>抽象类是不能使用new操作符来初始化的。但是，仍然可以定义它的构造方法，这构造函数在它的 子类的构造函数中调用。即使子类的父类是具体的，这个子类也可以是抽象的。不能使用new操作 符从一个抽象类创建一个实例，但是抽象类可以用作一种数据类型</p>
</li>
</ol>
<p>   <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220122200354260.png" alt="image-20220122200354260"></p>
<h2 id="7、抽象方法"><a href="#7、抽象方法" class="headerlink" title="7、抽象方法"></a>7、抽象方法</h2><p>用abstract修饰的方法是抽象方法。</p>
<p>抽象方法没有方法体。 </p>
<p>抽象方法没有方法体 抽象方法必须在抽象类里 </p>
<p>抽象方法必须在子类中被实现，除非子类是抽象类</p>
<p>抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模板，子类在抽象类的基础上进行 扩展、改造，但子类总体上会保留抽象类的行为方式。 </p>
<p><strong>解决的问题：</strong> 当功能内部一部分实现是确定的，一部分实现是不确定的。这时可以把不确定的部分暴露 出去，让子类去实现。</p>
<p>换句话说，在软件开发中实现一个算法时，整体步骤很固定、通用，这些步骤已经在父类中写好 了。但是某些部分易变，易变部分可以抽象出来，供不同子类实现。这就是一种模板模式</p>
<h2 id="8、final"><a href="#8、final" class="headerlink" title="8、final"></a>8、final</h2><p>final可以修饰属性，方法，类 </p>
<p>final修饰的属性是常量 </p>
<p>final修饰的方法，不能被重写，可以被继承</p>
<p>final修饰的类不能被继承</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220122200436562.png" alt="image-20220122200436562"></p>
<h3 id="练习：-10"><a href="#练习：-10" class="headerlink" title="练习："></a>练习：</h3><p>1、修改Pet类为抽象类，Pet类中的eat方法为抽象方法，输出Dog信息 </p>
<p>2、设计Bird、Fish类，都继承自抽象类Animal，实现其方法info()，并打印它们的信息</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220122200547931.png" alt="image-20220122200547931"></p>
<p>3、Engine(引擎),具有power(功率,整数)属性,相对应的setter和getter方法,work()方法:输出”xx功率 的发动机在运转”。Car(Engine轿车),具有Engine属性,相对应的setter和getter方法,run()方法，在方法中 判断Engine对象是否为null,选择输出”发动机发动不了”或者”xx功率的发动机在运转,汽车在跑”。Benz(奔 驰),继承Car类,重写run()方法Driver(驾驶员),具有属性name(姓名),相对应的setter和getter方 法,driveCar(Benz benz)方法,在方法中输出“xxx 在开车”，并调用benz的run()方法。</p>
<p>4、写一个名为 Account 的类模拟账户。该类的属性和方法如下图所示。该类包括的属性：账号 id，余额 balance，年利率 annualInterestRate；包含的方法：访问器方法（getter 和setter 方法）， 返回月利率的方法 getMonthlyInterest()，取款方法 withdraw()，存款方法deposit()。创建 Account 类 的一个子类 CheckAccount 代表可透支的账户，该账户中定义一个属性overdraft 代表可透支限额。在 CheckAccount 类中重写 withdraw 方法，其算法如下：如果（取款金额&lt;账户余额），可直接取款如果 （取款金额&gt;账户余额），计算需要透支的额度判断可透支额 overdraft 是否足够支付本次透支需要，如 果可以将账户余额修改为 0，冲减可透支金额如果不可以提示用户超过可透支额的限额</p>
<p>5、java类是否可以多继承，怎么实现多继承？</p>
<p>6、代码阅读</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220122200617859.png" alt="image-20220122200617859"></p>
<p> 7、代码阅读题</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220122200628540.png" alt="image-20220122200628540"></p>
<p> 8、编写一个Java应用程序，设计一个汽车类Vehicle，包含的属性有车轮个数wheels和车重weight。 小车类Car是Vehicle的子类，其中包含的属性有载人数loader。卡车类Truck是Car类的子类，其中包含 的属性有载重量payload。 </p>
<p>9、定义员工类Employee，包含姓名、工号和工资，包含计算奖金方法bonus，普通员工和经理都 是员工，计算奖金的方法为工资*奖金系数，普通员工的奖金系数为1.5（常量），经理为2（常量），分 别实现bonus方法，创建对象测试。 </p>
<p>10、封装一个西游记人物类Person：包含私有属性：姓名（name）、身高（height）、武器 （weapon）、种族（race），并提供get方法和set方法。在测试类中实例化三个对象：tangseng（唐 僧）、sunwukong（孙悟空）、baigujing（白骨精），分别设置他们的种族为：人族、仙族、妖族在 打印对象时，按照例如：“姓名：孙悟空；种族：仙族”的格式在控制台输出信息。提供一个技能方法 void skill()，这个方法根据当前对象name属性判断技能，如果是孙悟空，就打印“七十二变”，如果是唐 僧，就打印“紧箍咒”，如果是白骨精，就打印“九阴白骨爪”，在测试类中调用这个方法。 </p>
<p>11、阅读如下代码</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220122200655676.png" alt="image-20220122200655676"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220122200707738.png" alt="image-20220122200707738"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220122200714985.png" alt="image-20220122200714985"></p>
<h1 id="八、多态"><a href="#八、多态" class="headerlink" title="八、多态"></a>八、多态</h1><h2 id="1-多态"><a href="#1-多态" class="headerlink" title="1.多态"></a>1.多态</h2><p>生活中的多态：不同类型的打印机打印效果不同。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220117153605257.png" alt="image-20220117153605257"></p>
<p>同一种事物，由于条件不同，产生的结果也不同 </p>
<p>生活中的多态：同一个引用类型，使用不同的实例而执行不同操作 </p>
<p>父类的类型指向子类的实例</p>
<p>实现多态的方式称为–动态绑定 </p>
<p>指在执行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。 </p>
<p>多态的两种表现形式—重载与重写 </p>
<p>多态的<strong>必要条件</strong>： 要有继承 要有重写 <strong>父类的引用指向子类对象</strong> </p>
<p>父类更通用，子类更具体 </p>
<p>Pet pet &#x3D; new Dog();</p>
<p>Pet pet &#x3D; new Cat(); 这种方式称之为 <strong>向上转型</strong></p>
<p>子类转换为父类：在进行向上转型后，会发现 子类中特有的属性与方法已经丢失。此时需要进行<strong>向下转型</strong>（强制类型转化）。（容易抛出ClassCastException异常）。为了防止以上异常的出现，可以使用 <em><strong>instanceof</strong></em>判断该实例究竟是哪个类的类型。</p>
<p><strong>小结：</strong></p>
<ul>
<li>多态可以减少类中代码量，可以提高代码的可扩展性和可维护性 </li>
<li>向上转型——子类转换为父类，自动进行类型转换 </li>
<li>向下转型——父类转换为子类，结合instanceof运算符进行强制类型转换</li>
</ul>
<p><strong>实现多态的两种方式</strong> </p>
<ul>
<li><p>使用父类作为方法形参实现多态 </p>
</li>
<li><p>使用父类作为方法返回值实现多态 </p>
</li>
<li><p>类型转换</p>
</li>
</ul>
<p><strong>基本数据类型：</strong></p>
<ul>
<li><p>字节数小的数据类型可以自动转换成大的数据类型</p>
<p> 如long g&#x3D;20; double d&#x3D;12.0f</p>
</li>
<li><p>大的数据类型需要强制转换成小的数据类型 </p>
<p>如 floate f&#x3D;(float)12.0 int a&#x3D;(int)1200L</p>
</li>
</ul>
<p><strong>复合数据类型：</strong></p>
<ul>
<li><p>从子类到父类的类型转换可以自动进行</p>
</li>
<li><p>从父类到子类的类型转换必须通过强制类型转换实现</p>
</li>
<li><p>无继承关系的引用类型间的转换是非法的</p>
</li>
<li><p>在转换前如不确定，可以使用instanceof操作符测试一个对象的类型 Object类</p>
</li>
</ul>
<h2 id="2、Object类"><a href="#2、Object类" class="headerlink" title="2、Object类"></a>2、Object类</h2><p>Object类是所有的Java类的基类，如果一个类没有继承父类，此时默认继承Object类。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220122200906874.png" alt="image-20220122200906874"></p>
<h3 id="1、-x3D-x3D-与equals方法"><a href="#1、-x3D-x3D-与equals方法" class="headerlink" title="1、&#x3D;&#x3D; 与equals方法"></a>1、&#x3D;&#x3D; 与equals方法</h3><p>&#x3D;&#x3D;:是一个运算符。可以用在基本数据类型和引用数据类型的变量中。如果比较的是基本数据类型， 比较两个变量保存的值是否相等。如果比较的是引用数据类型，比较两个对象的地址值是否相等。也就 是两个引用是否指向同一个对象。</p>
<p> equals:是Object类中的方法。只能用在引用数据类型。在Object类中与&#x3D;&#x3D;是一样的，也是比较两个 对象的地址是否相等。但是String，Date,包装类 重写了equals方法，除去比较地址还会比较内容。 </p>
<p>我们自己的类也可以重写equals方法，会比较类中的属性是否相等。 </p>
<h4 id="练习：-11"><a href="#练习：-11" class="headerlink" title="练习："></a>练习：</h4><p>定义学生类，有属性，姓名，年龄，电话。如果属性都相等，我们则认为是同一个对象</p>
<h3 id="2、toString-方法"><a href="#2、toString-方法" class="headerlink" title="2、toString()方法"></a>2、toString()方法</h3><p>toString()方法，打印对象的时候，默认执行toString方法。</p>
<h3 id="重载和重写的区别："><a href="#重载和重写的区别：" class="headerlink" title="重载和重写的区别："></a><strong>重载和重写的区别：</strong></h3><p><strong>重载</strong>,发生在同一个类中的，方法名相同，参数列表不同。与访问修饰符和返回值类型无关。 </p>
<p><strong>重写</strong>, 发生在继承关系中的，子类重写父类的方法。方法名相同，参数列表相同，访问修饰符不能比父 类的严格。返回值类型相同或是父类方法返回值类型的子类。</p>
<p> <strong>重载</strong>，指允许存在多个同名方法，而这些方法的参数不同，编译器根据方法不同，对同名的方法做修 饰，对于编译器而言，这些同名方法就成了不同的方法，他们的调用地址在编译期就绑定了。重载是可 以包含父类和子类的，即子类可以重载父类的同名不同参数的方法。重载，在方法调用之前，编译器就 已经确定了所要调用的方法。称为静态绑定。</p>
<p><strong>重写</strong>，要等到方法调用那一刻，解释运行器才会确定所要调用的具体方法，称为动态绑定。</p>
<h3 id="练习：-12"><a href="#练习：-12" class="headerlink" title="练习："></a>练习：</h3><p>1、什么是多态，谈谈你堆多态的理解，多态情况下方法执行 </p>
<p>2、一个类可以有几个父类，一个父类可以由几个子类，子类能获取父类的构造方法吗？</p>
<p> 3、重写重载的区别</p>
<p> 4、super关键字 与this关键字 </p>
<p>5、抽象类和抽象方法 </p>
<p>6、final关键字 </p>
<p>7、多态是编译时行为还是运行时行为？【运行时行为】</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220122201142450.png" alt="image-20220122201142450"></p>
<p>8、编写Order类，有int型的orderId，String型的orderName，相应的getter()和setter()方法， 两个参数的构造器，重写父类的equals()方法：public boolean equals(Object obj)，并判断测试类中创 建的两个对象是否相等。</p>
<p> 9、父类GeometricObject代表几何形状，子类Circle代表圆形，MyRectangle代表矩形。定义一个 测试类GeometricTest，编写equalsArea方法测试两个对象的面积是否相等，编写 displayGeometricObject方法显示对象的面积。</p>
<p>10、编写立体图形类，SolidFigure，必须有属性高，定义圆柱体Cylinde,长方体Rectangular。实 现计算面机getArea和体积的方法getVolume。</p>
<h2 id="3、static关键字"><a href="#3、static关键字" class="headerlink" title="3、static关键字"></a>3、static关键字</h2><p> 有些属性和方法，希望无论有多少个对象，共享内存中的一份数据。此时可以用static修饰我们的数 和方法。 </p>
<p>static：静态的。可以修饰属性，方法，代码块以及内部类。 </p>
<p>static代表静态的。如果使用static声明属性，则该属性称之为称之为静态属性。使用static声明的属 性对所有的对象共享。static修饰的属性属于<strong>类级别</strong>的。对于静态的属性更推荐 使用类名. 的方式直接调 用 </p>
<p>static：可以修饰成员变量，叫做静态变量。 </p>
<p>没用static修饰的变量教实例变量，或非静态变量。</p>
<p> 实例变量：各个对象有自己的独立的非静态属性。一个对象实例属性值的更改，不会影响到其他 对象。</p>
<p>静态变量：属于类级别的，多个类的对象共享一个静态变量。当通过一个对象更改静态属性的时 候，其他对象获取的是修改后的结果。静态变量随着类的加载而加载，可以通过类名直接调用。静态变 量的加载早于对象的创建。<strong>类只会加载一次，静态变量也是加载一次，存在方法区的静态域中，方法区 中主要保存类的加载信息，静态域，常量池。</strong></p>
<p>画图理解：</p>
<p> static:可以修饰方法，叫做静态方法。也是随着类的加载来加载，也是可以通过类名.方式来调 用。静态方法只能调用静态成员。在静态方法内，不能使用this,super关键字。 </p>
<p>静态结构域类的结构的生命周期是相同的。 </p>
<p>属性被多个对象共享可以使用static修饰。 </p>
<p>单例模式:讲解</p>
<h2 id="4、代码块"><a href="#4、代码块" class="headerlink" title="4、代码块"></a>4、代码块</h2><p> 代码块分为三类，有 普通代码块 构造块 静态代码块</p>
<p>1） 普通代码块：普通代码块就是指直接在方法或语句中定义的代码块。(了解) </p>
<p>在方法中定义一个普通代码块。代码块中的num作用范围在大括号结束的时候，就完毕了。 </p>
<p>2） 构造块：是直接写在类中的代码块 </p>
<p>可以发现构造块的执行时间在构造方法之前。而且会发现在继续创建对象的时候，构造块还会执行。</p>
<ol>
<li>可以有输出语句。 </li>
<li>可以对类的属性、类的声明进行初始化操作。 </li>
<li>除了调用非静态的结构外，还可以调用静态的变量或方法。 </li>
<li>若有多个非静态的代码块，那么按照从上到下的顺序依次执行。 </li>
<li>每次创建对象的时候，都会执行一次。且先于构造器执行。</li>
</ol>
<p>3） 静态代码块：使用static关键字声明的代码块。在以上代码中加入静态代码块。 会发现静态代码块在构造块之前执行。 会发现，静态代码块只会加载一次。</p>
<ol>
<li><p>可以有输出语句。 </p>
</li>
<li><p>可以对类的属性、类的声明进行初始化操作。 </p>
</li>
<li><p>不可以对非静态的属性初始化。即：不可以调用非静态的属性和方法。 </p>
</li>
<li><p>若有多个静态的代码块，那么按照从上到下的顺序依次执行。</p>
</li>
<li><p>静态代码块的执行要先于非静态代码块</p>
</li>
<li><p>静态代码块随着类的加载而加载，且只执行一次。</p>
</li>
</ol>
<p>   <strong>提示：</strong>分别加入两个静态属性与两个非静态属性，给其中一个赋值。断点调试看整个代码的执行过程。 继承关系下的构造方法执行顺序</p>
<p>   <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220131095628326.png" alt="image-20220131095628326"></p>
<p>   继承关系下：父类静态资源-&gt;子类静态资源-&gt;父类非静态资源-&gt;父类构造方法-&gt;子类非静态资源-&gt;子类构造方法</p>
<h1 id="九、接口"><a href="#九、接口" class="headerlink" title="九、接口"></a>九、接口</h1><p>请大家使用面向对象的思想实现防盗门的功能,大家会怎么设计呢？ </p>
<p>可以借助接口实现。接口是用interface 修饰的。</p>
<p><strong>接口的特点：</strong> </p>
<ul>
<li>接口不可以被实例化 </li>
<li>实现类必须实现接口的所有方法 </li>
<li>实现类可以实现多个接口 </li>
<li>接口中的变量都是静态常量</li>
</ul>
<p>使用程序描述USB接口</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220117154100596.png" alt="image-20220117154100596"></p>
<p>接口表示一种能力，接口的能力体现在接口的方法上。</p>
<p><strong>面向接口编程</strong> </p>
<ul>
<li><p>在程序设计的时候，<em><strong>关心实现类有何能力，而不关心实现细节</strong></em> </p>
</li>
<li><p>如果继承用 is-a 的形式来形容，那么接口就是 has-a </p>
</li>
<li><p>一个人可以具有多项能力</p>
</li>
</ul>
<p><strong>接口的特点：</strong> </p>
<ul>
<li>一个类可以实现多个接口</li>
</ul>
<p><strong>接口有比抽象类更好的特性：</strong></p>
<ol>
<li><p>可以被多继承 </p>
</li>
<li><p>设计和实现完全分离</p>
</li>
<li><p>更自然的使用多态</p>
</li>
<li><p>更容易搭建程序框架</p>
</li>
<li><p>更容易更换实现</p>
</li>
</ol>
<p>Java中的接口 </p>
<p>属性全都是全局静态常量 </p>
<p>方法都是全局抽象方法 </p>
<p>无构造方法 </p>
<p>一个类可以实现多个接口，非抽象类实现接口时必须实现接口中的全部方法 </p>
<p>抽象类利于代码复用，接口利于代码维护. </p>
<p>接口可以继承接口，而且可以继承多个接口。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220117154420893.png" alt="image-20220117154420893"></p>
<p>JDK8中接口的新特点 </p>
<p>Java 8中，你可以为接口添加静态方法和默认方法。从技术角度来说，这是完全合法的，只是它看起来 违反了接口作为一个抽象定义的理念。 </p>
<p><strong>静态方法：</strong>使用 static 关键字修饰。可以通过接口直接调用静态方法，并执行其方法体。我们经常在相 互一起使用的类中使用静态方法。 </p>
<p><strong>默认方法：</strong>默认方法使用 default 关键字修饰。可以通过实现类对象来调用。我们在已有的接口中提供 新方法的同时，还保持了与旧版本代码的兼容性。 </p>
<p>若一个接口中定义了一个默认方法，而另外一个接口中也定义了一个同名同参数的方法（不管此方法是 否是默认方法），在实现类同时实现了这两个接口时，会出现：<strong>接口冲突</strong>。解决办法：实现类必须覆盖 接口中同名同参数的方法，来解决冲突。</p>
<p> 若一个接口中定义了一个默认方法，而父类中也定义了一个同名同参数的非抽象方法，则不会出现冲突 问题。因为此时遵守：<strong>类优先原则</strong>。接口中具有相同名称和参数的默认方法会被忽略。</p>
<h2 id="练习：-13"><a href="#练习：-13" class="headerlink" title="练习："></a>练习：</h2><p>1、牛犇有两个很好的朋友，一个是中国的王小强，喜欢吃四川菜，打太极一个是美国的约翰，喜 欢吃披萨，打橄榄球。每当朋友来拜访的时候，牛犇就会按照他们的喜欢招待他们。</p>
<p>2、1)下面关于接口的说法中不正确的是（）。</p>
<p>​		A．接口中所有的方法都是抽象的 </p>
<p>​		B．接口中所有的方法都是public访问权限</p>
<p>​		C．子接口继承父接口所用的关键字是implements</p>
<p>​		D．接口是Java中的特殊类，包含常量和抽象方法</p>
<p>​	2)Java语言接口间的继承关系是（）。</p>
<p>​	 	A．单继承 	B．多重继承 	C．不能继承 	D．不一定 </p>
<p>​	3)一个类实现接口的情况是（）。</p>
<p>​		A．一次可以实现多个接口 		B．一次只能实现一个接口 </p>
<p>​		C．不能实现接口 						D．不一定</p>
<p>3、接口【abstract class】和抽象类【interface】的区别</p>
<p>4、接口是否可继承接口? 抽象类是否可实现(implements)接口? 抽象类是否可继承实体类(concrete class)?</p>
<p> 5、代码阅读,以下代碼是否正確？</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220122201950144.png" alt="image-20220122201950144"></p>
<h1 id="十、内部类"><a href="#十、内部类" class="headerlink" title="十、内部类"></a>十、内部类</h1><p>在java中，允许一个类的定义位于另一个类的内部，前者称为内部类。 </p>
<p>内部类与外部封装他的类之间存在逻辑上的所属关系。</p>
<p>Inner class 一般用在定义他的类或语句块之内，在外边引用他时必须给出完整的名字。Inner class 的名字不能与包含他的类的名相同。</p>
<p> 当一个事物的内部，还有一个部分需要一个完整的结构进行描述，而这个内部的完整的结构又只为外 部事物提供服务，那么整个内部的完整结构最好使用内部类。 </p>
<p>在Java中，允许一个类的定义位于另一个类的内部，前者称为内部类，后者称为外部类。 </p>
<p>Inner class一般用在定义它的类或语句块之内，在外部引用它时必须给出完整的名称。 </p>
<p>Inner class的名字不能与包含它的外部类类名相同；</p>
<p> <strong>分类： 成员内部类</strong>（static成员内部类和非static成员内部类） 局部内部类不谈修饰符）、匿名内部 类</p>
<h2 id="1、成员内部类"><a href="#1、成员内部类" class="headerlink" title="1、成员内部类"></a>1、成员内部类</h2><p><strong>成员内部类作为类的成员的角色：</strong> </p>
<p>和外部类不同，Inner class还可以声明为<strong>private</strong>或<strong>protected</strong>； </p>
<p>可以调用外部类的结构 </p>
<p>Inner class 可以声明为<strong>static</strong>的，但此时就不能再使用外层类的非static的成员变量；</p>
<p> <strong>成员内部类作为类的角色：</strong> </p>
<p>可以在内部定义属性、方法、构造器等结构 </p>
<p>可以声明为<strong>abstract</strong>类 ，因此可以被其它的内部类继承 </p>
<p>可以声明为<strong>final</strong>的 </p>
<p>编译以后生成OuterClass$InnerClass.class字节码文件（也适用于局部内部类） </p>
<p><strong>【注意】</strong> </p>
<ol>
<li><p>非static的成员内部类中的成员不能声明为static的，只有在外部类或static的成员内部类中才可声 明static成员。 </p>
</li>
<li><p>外部类访问成员内部类的成员，需要“内部类.成员”或“内部类对象.成员”的方式 </p>
</li>
<li><p>成员内部类可以直接使用外部类的所有成员，包括私有的数据 </p>
</li>
<li><p>当想要在外部类的静态成员部分使用内部类时，可以考虑内部类声明为静态的</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220122202303024.png" alt="image-20220122202303024"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220122202309846.png" alt="image-20220122202309846"></p>
<p>Inner class可以声明为抽象类 ，因此可以被其它的内部类继承。也可以声明为final的。和外层类不 同，Inner class可以声明为private或protected；Inner class 可以声明为static的，但此时就不能 再使用外层封装类的非static的成员变量；（静态类的使用直接 ：A.C c &#x3D; <em><strong>new</strong></em> A.C();）非static的 内部类中的成员不能声明为static的，只有在顶层类或static的内部类中才可声明static成员； </p>
<p>为什么要使用内部类？在《Think in java》中有这样一句话：使用内部类最吸引人的原因是：每个 内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实 现，对于内部类都没有影响。 在我们程序设计中有时候会存在一些使用接口很难解决的问题，这个 时候我们可以利用内部类提供的、可以继承多个具体的或者抽象的类的能力来解决这些程序设计问 题。可以这样说，接口只是解决了部分问题，而内部类使得多重继承的解决方案变得更加完整。使 用内部类最大的优点就在于它能够非常好的解决多重继承的问题，但是如果我们不需要解决多重继 承问题，那么我们自然可以使用其他的编码方式，但是使用内部类还能够为我们带来<strong>如下特性</strong>（摘 自《Think in java》）：</p>
<p>1、内部类可以用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独 立。 </p>
<p>2、在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类。 </p>
<p>3、创建内部类对象的时刻并不依赖于外围类对象的创建。 </p>
<p>4、内部类并没有令人迷惑的“is-a”关系，他就是一个独立的实体。 </p>
<p>5、内部类提供了更好的封装，除了该外围类，其他类都不能访问。</p>
<p>成员内部类也是最普通的内部类，它是外围类的一个成员，所以他是可以无限制的访问外围类的所 有 成员属性和方法，尽管是private的，但是外围类要访问内部类的成员属性和方法则需要通过内 部类实例来访问.</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220122202418732.png" alt="image-20220122202418732"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220122202424887.png" alt="image-20220122202424887"></p>
<p>在成员内部类中要注意两点，<em><strong>第一</strong>：</em>成员内部类中不能存在任何static的变量和方法；<em><strong>第二</strong>：</em> 成员内部类是依附于外围类的，所以只有先创建了外围类才能够创建内部类。 </p>
<p>成员内部类之静态内部类 </p>
<p>static修饰的内部类我们称之为静态内部类，不过我们更喜欢称之为嵌套内部类。静态内部类与非 静态内部类之间存在一个最大的区别，我们知道非静态内部类在编译完成之后会隐含地保存着一个 引用，该引用是指向创建它的外围内，但是静态内部类却没有。没有这个引用就意味着：它的创建 是不需要依赖于外围类的。它不能使用任何外围类的非static成员变量和方法。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220122202503538.png" alt="image-20220122202503538"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220211205832822.png" alt="image-20220211205832822"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220211205845431.png" alt="image-20220211205845431"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220211205901809.png" alt="image-20220211205901809"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220211205911497.png" alt="image-20220211205911497"></p>
</li>
</ol>
<h2 id="2、局部内部类"><a href="#2、局部内部类" class="headerlink" title="2、局部内部类"></a>2、局部内部类</h2><p> 局部嵌套类，简称局部类，局部类所属范围：在块、构造器以及方法内，这里的块包括普通块和静 态块。局部类只在本块范围内有效。局部类是嵌套类，但不是成员类，而且有名称（不是匿名 类）。 只能在声明它的方法或代码块中使用，而且是先声明后使用。除此之外的任何地方都不能使用该类 但是它的对象可以通过外部方法的返回值返回使用，返回值类型只能是局部内部类的父类或父接口 类型</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220122202618825.png" alt="image-20220122202618825"></p>
<p>内部类仍然是一个独立的类，在编译之后内部类会被编译成独立的.class文件，但是前面冠以外部 类的类名和$符号，以及数字编号。、 只能在声明它的方法或代码块中使用，而且是先声明后使用。除此之外的任何地方都不能使用该 类。</p>
<p> 局部内部类可以使用外部类的成员，包括私有的。 </p>
<p>局部内部类可以使用外部方法的局部变量，但是必须是final的。由局部内部类和局部变量的声明周 期不同所致。</p>
<p> 局部内部类和局部变量地位类似，不能使用public,protected,缺省,private </p>
<p>局部内部类不能使用static修饰，因此也不能包含静态成员</p>
<h2 id="3、匿名内部类"><a href="#3、匿名内部类" class="headerlink" title="3、匿名内部类"></a>3、匿名内部类</h2><p> 匿名类，就是没有名称的类，其名称由Java编译器给出，一般是形如：外部类名称+$+匿名类顺 序，没有名称也就是其他地方就不能引用，不能实例化，只用一次，当然也就不能有构造器。 匿名类根据位于地方不同分为：成员匿名类和局部匿名类。</p>
<p> 匿名类不能使用任何关键字和访问控制符，匿名类和局部类访问规则一样，只不过内部类显式的定 义了一个类，然后通过new的方式创建这个局部类实例，而匿名类直接new一个类实例，没有定义 这个类。匿名类最常见的方式就是回调模式的使用，通过默认实现一个接口创建一个匿名类然后， 然后new这个匿名类的实例。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220122202803546.png" alt="image-20220122202803546"></p>
<h1 id="十一、异常"><a href="#十一、异常" class="headerlink" title="十一、异常"></a>十一、异常</h1><p>1、异常概述与体现结构 </p>
<p>​		异常：在Java语言中，将程序执行中发生的不正常情况称为“异常”。 (开发过程中的语法错误和逻 辑错误不是异常) </p>
<p>Java程序在执行过程中所发生的异常事件可分为两类： </p>
<p>​		1&gt;Error：Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。比 如：StackOverflowError和OOM。一般不编写针对性的代码进行处理。 </p>
<p>​		2&gt;Exception:其它因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行 处理。例如：空指针异常，数组下标越界异常。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220211210016410.png" alt="image-20220211210016410"></p>
<p>​		3&gt;Exception下异常又可以分为 运行时异常 和 编译时异常 </p>
<p>​		1)运行时异常是指编译器不要求强制处置的异常。一般是指编程时的逻辑错误，是程序员应该 积极避免其出现的异常。<strong>java.lang.RuntimeException</strong>类及它的子类都是运行时异常。对于这类异 常，可以不作处理，因为这类异常很普遍，若全处理可能会对程序的可读性和运行效率产生影响。 </p>
<p>​		2）是指编译器要求必须处置的异常。即程序在运行时由于外界因素造成的一般性异常。编译 器要求Java程序必须捕获或声明所有编译时异常。对于这类异常，如果程序不处理，可能会带来意想不 到的结果。 </p>
<p>2、异常处理机制 </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220211210125322.png" alt="image-20220211210125322"></p>
<p>​		Java采用的异常处理机制，是将异常处理的程序代码集中在一起，与正常的程序代码分开，使得 程序简洁、优雅，并易于维护 </p>
<p>​		1&gt;捕获异常 try-catch-finally：如果一个方法内抛出异常，该异常对象会被抛给调用者方法中处 理。如果异常没有在调用者方法中处理，它继续被抛给这个调用方法的上层方法。这个过程将一直继续 下去，直到异常被处理。这一过程称为捕获(catch)异常。 如果一个异常回到main()方法，并且main()也 不处理，则程序运行终止。 程序员通常只能处理Exception，而对Error无能为力。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220211210200278.png" alt="image-20220211210200278"></p>
<p>try捕获异常的第一步是用try{…}语句块选定捕获异常的范围，将可能出现异常的代码放在try语句块 中。 </p>
<p>catch (Exceptiontype e)在catch语句块中是对异常对象进行处理的代码。每个try语句块可以伴随 一个或多个catch语句，用于处理可能产生的不同类型的异常对象。 </p>
<p>捕获异常的有关信息：与其它对象一样，可以访问一个异常对象的成员变量或调用它的方法。 </p>
<p>getMessage() 获取异常信息，返回字符串 </p>
<p>printStackTrace() 获取异常类名和异常信息，以及异常出现在程序中的位置。返回值void。 </p>
<p>finally 捕获异常的最后一步是通过finally语句为异常处理提供一个统一的出口，使得在控制流转到 程序的其它部分以前，能够对程序的状态作统一的管理。 </p>
<p>不论在try代码块中是否发生了异常事件，catch语句是否执行，catch语句是否有异常，catch语句 中是否有return，finally块中的语句都会被执行。finally语句和catch语句是任选的。 </p>
<p>前面使用的异常都是RuntimeException类或是它的子类，这些类的异常的特点是：即使没有使用try 和catch捕获，Java自己也能捕获，并且编译通过( 但运行时会发生异常使得程序运行终止 )。</p>
<p>如果抛出的异常是IOException等类型的非运行时异常，则必须捕获，否则编译错误。也就是说，我 们必须处理编译时异常，将异常进行捕捉，转化为运行时异常 </p>
<ol>
<li>正常情况</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220211210307721.png" alt="image-20220211210307721"></p>
<ol start="2">
<li><p>异常情况</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220211210335833.png" alt="image-20220211210335833"></p>
</li>
<li><p>异常类型不匹配</p>
</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220211210343959.png" alt="image-20220211210343959"></p>
<ol start="4">
<li><p>finally：在try&#x2F;catch块后加入finally块，可以确保无论是否发生异常，finally块中的代码总能 被执行.</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220211210402237.png" alt="image-20220211210402237"></p>
</li>
</ol>
<p>2&gt;声明异常：声明抛出异常是Java中处理异常的第二种方式。 </p>
<p>如果一个方法(中的语句执行时)可能生成某种异常，但是并不能确定如何处理这种异常，则此方法 应显示地声明抛出异常，表明该方法将不对这些异常进行处理，而由该方法的调用者负责处理。在方法 声明中用throws语句可以声明抛出异常的列表，throws后面的异常类型可以是方法中产生的异常类型， 也可以是它的父类。 </p>
<p>3&gt;抛出异常Java程序的执行过程中如出现异常，会生成一个异常类对象，该异常对象将被提交给 Java运行时系统，这个过程称为抛出(throw)异常。 </p>
<p>3、自定义异常一般地，用户自定义异常类都是RuntimeException的子类。 自定义异常类通常需要 编写几个重载的构造器。 自定义异常需要提供serialVersionUID 自定义的异常通过throw抛出。 自定义 异常最重要的是异常类的名字，当异常出现时，可以根据名字判断异常类型。 </p>
<h2 id="练习：-14"><a href="#练习：-14" class="headerlink" title="练习："></a>练习：</h2><p>1、运行时异常与一般异常有何异同 </p>
<p>2、Java中的异常处理机制的简单原理和应用 </p>
<p>3、JAVA语言如何进行异常处理，关键字：throws,throw,try,catch,finally分别代表什么意义？在 try块中可以抛出异常吗？ </p>
<p>4、try {}里有一个return语句，那么紧跟在这个try后的finally {}里的code会不会被执行，什么时 候被执行，在return前还是后? </p>
<p>5、error和exception有什么区别。 </p>
<p>6、写出以下代码的运行结果</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220220200840313.png" alt="image-20220220200840313"></p>
<p>7、写出以下代码的结果</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220220200925619.png" alt="image-20220220200925619"></p>
<p> 8、写出程序结果</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220220200950637.png" alt="image-20220220200950637"></p>
<p>9、写出如下代码的运行结果</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220220201006466.png" alt="image-20220220201006466"></p>
<p> 10、写出如下代码的运行结果</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220220201020201.png" alt="image-20220220201020201"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220220201030946.png" alt="image-20220220201030946"></p>
<h1 id="十二、常用类"><a href="#十二、常用类" class="headerlink" title="十二、常用类"></a>十二、常用类</h1><h2 id="1、基本数据类和引用数据类型"><a href="#1、基本数据类和引用数据类型" class="headerlink" title="1、基本数据类和引用数据类型"></a>1、基本数据类和引用数据类型</h2><p>八种基本数据类型有对应的包装类型，认识基本数据类型与包装类型之间的转化。同时知道数组转化为 字符串，以及将字符串转化为数值类型。 </p>
<p><strong>装箱：</strong>将基本数据类型转化为包装类型称之为装箱</p>
<p>int i &#x3D; 500; Integer t &#x3D; new Integer(i); </p>
<p>Float f &#x3D; new Float(“4.56”); </p>
<p><strong>拆箱：</strong>将包装类型转化为基本数据类型称之为拆箱 </p>
<p>boolean b &#x3D; bObj.booleanValue(); </p>
<p><strong>字符串转换成基本数据类型</strong> </p>
<p>通过包装类的构造器实现：int i &#x3D; new Integer(“12”); </p>
<p>通过包装类的parseXxx(String s)静态方法：Float f &#x3D; Float.parseFloat(“12.1”); </p>
<p><strong>基本数据类型转换成字符串</strong> 调用字符串重载的valueOf()方法：String fstr &#x3D; String.valueOf(2.34f); </p>
<p>更直接的方式：String intStr &#x3D; 5 +</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220220201207616.png" alt="image-20220220201207616"></p>
<h3 id="练习：-15"><a href="#练习：-15" class="headerlink" title="练习："></a>练习：</h3><p>1、写出如下代码的结果</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220220201218906.png" alt="image-20220220201218906"></p>
<h2 id="2、String类"><a href="#2、String类" class="headerlink" title="2、String类"></a>2、String类</h2><p>String类代表字符串。Java程序中的所有字符串字面值都是此类的实例实现。String类是一个final 类，代表不可变的字符串。字符串是常量，用双引号引起来表示。他们的值在创建后不能更改。Sting对 象的字符串内容是存储在一个字符数组value[]中的。String如果直接赋值，是将字符串保存到方法区中 的常量池中。如果new,会在堆中，然后堆再指向方法区常量池中的字符串。字符串存储再常量池中的目 的是共享。<strong>只要其中有一个是变量，结果就在堆中</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">结论：</span><br><span class="line">常量与常量的拼接结果在常量池。且常量池中不会存在相同内容的常量.</span><br><span class="line">只要其中有一个是变量，结果就在堆中</span><br><span class="line">如果拼接的结果调用intern()方法，返回值就在常量池中</span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">说明：在字符串常量池中创建了一个字面量为<span class="string">&quot;a&quot;</span>的字符串。</span><br><span class="line">s1 = s1 + <span class="string">&quot;b&quot;</span>;</span><br><span class="line">说明：实际上原来的“a”字符串对象已经丢弃了，现在在堆空间中产生了一个字符串s1+<span class="string">&quot;b&quot;</span>（也就是<span class="string">&quot;ab&quot;</span>)。如果多次执行这些改变串内容的操作，会导致大量副本字符串对象存留在内存中，降低效率。如果这样的操作放到循环中，会极大影响程序的性能。</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">说明：直接在字符串常量池中创建一个字面量为<span class="string">&quot;ab&quot;</span>的字符串。</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span>;</span><br><span class="line">说明：s3指向字符串常量池中已经创建的<span class="string">&quot;ab&quot;</span>的字符串。</span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1.intern();</span><br><span class="line">说明：堆空间的s1对象在调用intern()之后，会将常量池中已经存在的<span class="string">&quot;ab&quot;</span>字符串赋值给s4。</span><br></pre></td></tr></table></figure>

<p>字符串常用方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">length</span><span class="params">()</span>：返回字符串的长度： <span class="keyword">return</span> value.length</span><br><span class="line"><span class="type">char</span> <span class="title function_">charAt</span><span class="params">(<span class="type">int</span> index)</span>： 返回某索引处的字符<span class="keyword">return</span> value[index]<span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>：判断是否是空字符串：<span class="keyword">return</span> value.length == <span class="number">0</span> String <span class="title function_">toLowerCase</span><span class="params">()</span>：使用默认语言环境，将 String 中的所有字符转换为小写</span><br><span class="line">String <span class="title function_">toUpperCase</span><span class="params">()</span>：使用默认语言环境，将 String 中的所有字符转换为大写</span><br><span class="line">String <span class="title function_">trim</span><span class="params">()</span>：返回字符串的副本，忽略前导空白和尾部空白</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>：比较字符串的内容是否相同</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">equalsIgnoreCase</span><span class="params">(String anotherString)</span>：与equals方法类似，忽略大小写</span><br><span class="line">String <span class="title function_">concat</span><span class="params">(String str)</span>：将指定字符串连接到此字符串的结尾。 等价于用“+”<span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(String anotherString)</span>：比较两个字符串的大小</span><br><span class="line">String <span class="title function_">substring</span><span class="params">(<span class="type">int</span> beginIndex)</span>：返回一个新的字符串，它是此字符串的从beginIndex开始截取到最后的一个子字符串。String <span class="title function_">substring</span><span class="params">(<span class="type">int</span> beginIndex, <span class="type">int</span> endIndex)</span> ：返回一个新字符串，它是此字符串从beginIndex开始截取到endIndex(不包含)的一个子字符串。</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">endsWith</span><span class="params">(String suffix)</span>：测试此字符串是否以指定的后缀结束</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String prefix)</span>：测试此字符串是否以指定的前缀开始</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String prefix, <span class="type">int</span> toffset)</span>：测试此字符串从指定索引开始的子字符串是否以指定前缀开始</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(CharSequence s)</span>：当且仅当此字符串包含指定的 <span class="type">char</span> 值序列时，返回 <span class="literal">true</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(String str)</span>：返回指定子字符串在此字符串中第一次出现处的索引</span><br><span class="line"><span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(String str, <span class="type">int</span> fromIndex)</span>：返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始</span><br><span class="line"><span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(String str)</span>：返回指定子字符串在此字符串中最右边出现处的索引</span><br><span class="line"><span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(String str, <span class="type">int</span> fromIndex)</span>：返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索</span><br><span class="line">注：indexOf和lastIndexOf方法如果未找到都是返回-<span class="number">1</span></span><br><span class="line">String <span class="title function_">replace</span><span class="params">(<span class="type">char</span> oldChar, <span class="type">char</span> newChar)</span>：返回一个新的字符串，它是通过用newChar 替换此字符串中出现的所有 oldChar 得到的。</span><br><span class="line">String <span class="title function_">replace</span><span class="params">(CharSequence target, CharSequence replacement)</span>：使用指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串。</span><br><span class="line">String <span class="title function_">replaceAll</span><span class="params">(String regex, String replacement)</span> ： 使用给定的replacement替换此字符串所有匹配给定的正则表达式的子字符串。</span><br><span class="line">String <span class="title function_">replaceFirst</span><span class="params">(String regex, String replacement)</span> ： 使用给定的replacement替换此字符串匹配给定的正则表达式的第一个子字符串。</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(String regex)</span>：告知此字符串是否匹配给定的正则表达式。</span><br><span class="line">String[] split(String regex)：根据给定正则表达式的匹配拆分此字符串。</span><br><span class="line">String[] split(String regex, <span class="type">int</span> limit)：根据匹配给定的正则表达式来拆分此字符串，最多不超过limit个，如果超过了，剩下的全部都放到最后一个</span><br></pre></td></tr></table></figure>

<p>String特点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String:字符串，使用一对<span class="string">&quot;&quot;</span>引起来表示。</span><br><span class="line"><span class="number">1.</span>String声明为<span class="keyword">final</span>的，不可被继承</span><br><span class="line"><span class="number">2.</span>String实现了Serializable接口：表示字符串是支持序列化的。</span><br><span class="line">		实现了Comparable接口：表示String可以比较大小</span><br><span class="line"><span class="number">3.</span>String内部定义了<span class="keyword">final</span> <span class="type">char</span>[] value用于存储字符串数据</span><br><span class="line"><span class="number">4.</span>String:代表不可变的字符序列。简称：不可变性。</span><br><span class="line">	体现：<span class="number">1.</span>当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。</span><br><span class="line">		 <span class="number">2.</span> 当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</span><br><span class="line">		 <span class="number">3.</span> 当调用String的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</span><br><span class="line">		 <span class="number">5.</span>通过字面量的方式（区别于<span class="keyword">new</span>）给一个字符串赋值，此时的字符串值声明在字符串常量池中。</span><br><span class="line">		 <span class="number">6.</span>字符串常量池中是不会存储相同内容的字符串的。</span><br></pre></td></tr></table></figure>

<h2 id="3、StringBuffer类"><a href="#3、StringBuffer类" class="headerlink" title="3、StringBuffer类"></a>3、StringBuffer类</h2><p>java.lang.StringBuffer代表<strong>可变的字符序列</strong>，JDK1.0中声明，可以对字符串内容进行增删，此时不会产 生新的对象。很多方法与String相同。作为参数传递时，方法内部可以改变值。 </p>
<p>StringBuffer类不同于String，其对象必须使用构造器生成。有三个构造器： </p>
<p>扩容问题:如果要添加的数据底层数组盛不下了，那就需要扩容底层的数组。 </p>
<p>​				默认情况下，扩容为原来容量的2倍 + 2，同时将原有数组中的元素复制到新的数组中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">指导意义：开发中建议大家使用：StringBuffer(<span class="type">int</span> capacity) 或</span><br><span class="line">StringBuilder(<span class="type">int</span> capacity)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer()：初始容量为<span class="number">16</span>的字符串缓冲区</span><br><span class="line">StringBuffer(<span class="type">int</span> size)：构造指定容量的字符串缓冲区</span><br><span class="line">StringBuffer(String str)：将内容初始化为指定字符串内容</span><br></pre></td></tr></table></figure>

<p>StringBuffer常用的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer <span class="title function_">append</span><span class="params">(xxx)</span>：<span class="comment">//提供了很多的append()方法，用于进行字符串拼接</span></span><br><span class="line">StringBuffer <span class="title function_">delete</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span> end)</span>：<span class="comment">//删除指定位置的内容</span></span><br><span class="line">StringBuffer <span class="title function_">replace</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end, String str)</span>：<span class="comment">//把[start,end)位置替换为str</span></span><br><span class="line">StringBuffer <span class="title function_">insert</span><span class="params">(<span class="type">int</span> offset, xxx)</span>：<span class="comment">//在指定位置插入xxx</span></span><br><span class="line">StringBuffer <span class="title function_">reverse</span><span class="params">()</span> ：<span class="comment">//把当前字符序列逆转</span></span><br></pre></td></tr></table></figure>

<h2 id="4、StringBuilder类"><a href="#4、StringBuilder类" class="headerlink" title="4、StringBuilder类"></a>4、StringBuilder类</h2><p>StringBuilder 和 StringBuffer 非常类似，均代表可变的字符序列，而且提供相关功能的方法也一样 面试题：对比String、StringBuffer、StringBuilder </p>
<p>String(JDK1.0)：不可变字符序列 </p>
<p>StringBuffer(JDK1.0)：可变字符序列、效率低、线程安全 </p>
<p>tringBuilder(JDK 5.0)：可变字符序列、效率高、线程不安全 </p>
<p>注意：作为参数传递的话，方法内部String不会改变其值，StringBuffer和StringBuilder会改变其值。 </p>
<p>String、StringBuffer、StringBuilder三者的异同？ </p>
<p>String:不可变的字符序列；底层使用char[]存储 </p>
<p>StringBuffer:可变的字符序列；线程安全的，效率低；底层使用char[]存储 </p>
<p>StringBuilder:可变的字符序列；jdk5.0新增的，线程不安全的，效率高；底层使用char[]存储。</p>
<h3 id="练习：-16"><a href="#练习：-16" class="headerlink" title="练习："></a>练习：</h3><p>1、画出内容结构</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String s1=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">String s2=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">String s3=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">s1+=<span class="string">&quot;world&quot;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2、String是可变的吗？String可以被继承吗？为什么？ </p>
<p>3、String s&#x3D;new String(“hello”);再内存中创建了几个对象？ </p>
<p>4、String,StringBuffer,StingBuilder三者对比 </p>
<p>5、说出String类常用的方法 </p>
<p>6、字符串反转，给定字符串，给定起始位置和结束位置，对字符串进行反转</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">reverse</span><span class="params">(String str,<span class="type">int</span> start,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">    <span class="type">char</span>[]arr= str.toCharArray();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=start,j=end;i&lt;j;i++,j--)&#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i]=arr[j];</span><br><span class="line">        arr[j]=c;</span><br><span class="line">    &#125;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(arr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> reverse(<span class="string">&quot;helloworld&quot;</span>,<span class="number">2</span>,<span class="number">8</span>);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>7、获取一个字符串再另一个字符串中出现的次数。比如“ab”在“abcccabddddabeeeeaaaaab“中出现的 次数”</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">(String mainWords,String subWords)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(mainWords.length()&gt;subWords.length())&#123;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> index;</span><br><span class="line">        <span class="type">int</span> mainLength=mainWords.length();</span><br><span class="line">        <span class="type">int</span> subLength=subWords.length();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> ((index=mainWords.indexOf(subWords))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            mainWords=mainWords.substring(index+subLength);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">   		 <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> getCount(<span class="string">&quot;abcccabddddabeeeeaaaaab&quot;</span>,<span class="string">&quot;ab&quot;</span>);</span><br><span class="line">        System.out.println(count);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">(String mainWords,String subWords)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(mainWords.length()&gt;subWords.length())&#123;</span><br><span class="line">            <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>((index=mainWords.indexOf(subWords,index))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            	count++;</span><br><span class="line">            	index+=subWords.length();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> 8、查找最大相同字串”aabbccadeahellocadfasfdas“,与字符串”aaellocc“最大相同字串是”elloc“。【只 有一个相同字符串】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getSameWord</span><span class="params">(String maxStr,String minStr)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;minStr.length();i++)&#123;</span><br><span class="line">        	<span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">0</span>,y=minStr.length()-i;y&lt;=minStr.length();x++,y++)&#123;</span><br><span class="line">       			<span class="type">String</span> <span class="variable">subStr</span> <span class="operator">=</span> minStr.substring(x,y);</span><br><span class="line">        		<span class="keyword">if</span>(maxStr.contains(subStr))&#123;</span><br><span class="line">        			<span class="keyword">return</span> subStr;</span><br><span class="line">        		&#125;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>9、写出以下代码的运行结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">sb.append(str);</span><br><span class="line">System.out.println(sb.length());</span><br><span class="line">System.out.println(sb);</span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(str);</span><br><span class="line">System.out.println(sb1);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="5、日期类型"><a href="#5、日期类型" class="headerlink" title="5、日期类型"></a>5、日期类型</h2><h3 id="1-gt-System类"><a href="#1-gt-System类" class="headerlink" title="1&gt;System类"></a>1&gt;System类</h3><p>System类提供的public static long currentTimeMillis()用来返回当前时间与1970年1月1日0时0分0秒之 间以毫秒为单位的时间差。<strong>此方法适于计算时间差。</strong> </p>
<h3 id="2-gt-java-util-Date类"><a href="#2-gt-java-util-Date类" class="headerlink" title="2&gt;java.util.Date类"></a>2&gt;java.util.Date类</h3><p>Date()：使用无参构造器创建的对象可以获取本地当前时间。 </p>
<p>Date(long date)： </p>
<p><strong>常用的方法：</strong> </p>
<p>getTime():返回自 1970 年 1 月 1 日 00:00:00 GMT 以来此 Date 对象表示的毫秒数。 </p>
<p>toString():把此 Date 对象转换为以下形式的 String： dow mon ddhh:mm:ss zzz yyyy 其中： dow 是 一周中的某一天 (Sun, Mon, Tue, Wed, Thu, Fri, Sat)，zzz是时间标准</p>
<h3 id="3-gt-SimpleDateFormat类"><a href="#3-gt-SimpleDateFormat类" class="headerlink" title="3&gt;SimpleDateFormat类"></a>3&gt;SimpleDateFormat类</h3><p>Date类的API不易于国际化，大部分被废弃了，java.text.SimpleDateFormat类是一个不与语言环境有 关的方式来格式化和解析日期的具体类。 </p>
<p>它允许进行格式化：日期文本、解析：文本日期 </p>
<p><strong>格式化： SimpleDateFormat()</strong> ：默认的模式和语言环境创建对象 </p>
<p><strong>public SimpleDateFormat(String pattern)：</strong>该构造方法可以用参数pattern指定的格式创建一个 对象，该对象调用： </p>
<p>**public String format(Date date)**：方法格式化时间对象date </p>
<p><strong>解析： public Date parse(String source)：</strong>从给定字符串的开始解析文本，以生成一个日期</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220220202002426.png" alt="image-20220220202002426"></p>
<h3 id="4-gt-java-util-Calendar-日历-类"><a href="#4-gt-java-util-Calendar-日历-类" class="headerlink" title="4&gt; java.util.Calendar(日历)类"></a>4&gt; java.util.Calendar(日历)类</h3><p>Calendar是一个抽象基类，主用用于完成日期字段之间相互操作的功能。 </p>
<p>获取Calendar实例的方法 </p>
<p>使用Calendar.getInstance()方法 调用它的子类GregorianCalendar的构造器。 </p>
<p>一个Calendar的实例是系统时间的抽象表示，通过get(int field)方法来取得想要的时间信息。比如 YEAR、MONTH、DAY_OF_WEEK、HOUR_OF_DAY 、MINUTE、SECOND</p>
<p>public void set(int field,int value) </p>
<p>public void add(int field,int amount) </p>
<p>public final Date getTime() </p>
<p>public final void setTime(Date date) </p>
<p><strong>注意</strong> </p>
<p>获取月份时：一月是0，二月是1，以此类推，12月是11 </p>
<p>获取星期时：周日是1，周二是2 ， 。。。。周六是7 </p>
<h2 id="6、Math类"><a href="#6、Math类" class="headerlink" title="6、Math类"></a>6、Math类</h2><p>java.lang.Math提供了一系列静态方法用于科学计算。其方法的参数和返回值类型一般为double型。 </p>
<h2 id="7、BigInteger与BigDecimal"><a href="#7、BigInteger与BigDecimal" class="headerlink" title="7、BigInteger与BigDecimal"></a>7、BigInteger与BigDecimal</h2><p>Integer类作为int的包装类，能存储的最大整型值为2 31-1，Long类也是有限的，最大为2 63-1。如果要 表示再大的整数，不管是基本数据类型还是他们的包装类都无能为力，更不用说进行运算了。 </p>
<p>java.math包的<strong>BigInteger</strong>可以表示不可变的任意精度的整数。BigInteger 提供所有 Java 的基本 整数操作符的对应物，并提供 java.lang.Math 的所有相关方法。另外，BigInteger 还提供以下运算：模 算术、GCD 计算、质数测试、素数生成、位操作以及一些其他操作。 </p>
<p>构造器 <strong>BigInteger</strong>(String val)：根据字符串构建BigInteger对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> BigInteger <span class="title function_">abs</span><span class="params">()</span>：返回此 BigInteger 的绝对值的 BigInteger。</span><br><span class="line">BigInteger <span class="title function_">add</span><span class="params">(BigInteger val)</span> ：返回其值为 (<span class="built_in">this</span> + val) 的 BigInteger</span><br><span class="line">BigInteger <span class="title function_">subtract</span><span class="params">(BigInteger val)</span> ：返回其值为 (<span class="built_in">this</span> - val) 的 BigInteger</span><br><span class="line">BigInteger <span class="title function_">multiply</span><span class="params">(BigInteger val)</span> ：返回其值为 (<span class="built_in">this</span> * val) 的 BigInteger</span><br><span class="line">BigInteger <span class="title function_">divide</span><span class="params">(BigInteger val)</span> ：返回其值为 (<span class="built_in">this</span> / val) 的 BigInteger。整数相除只保留整数部分。</span><br><span class="line">BigInteger <span class="title function_">remainder</span><span class="params">(BigInteger val)</span> ：返回其值为 (<span class="built_in">this</span> % val) 的 BigInteger。BigInteger[] divideAndRemainder(BigInteger val)：返回包含 (<span class="built_in">this</span> / val) 后跟(<span class="built_in">this</span> % val) 的两个 BigInteger 的数组。</span><br><span class="line">BigInteger <span class="title function_">pow</span><span class="params">(<span class="type">int</span> exponent)</span> ：返回其值为 (thisexponent) 的BigInteger。</span><br></pre></td></tr></table></figure>

<h3 id="BigDecimal类"><a href="#BigDecimal类" class="headerlink" title="BigDecimal类"></a>BigDecimal类</h3><p>一般的Float类和Double类可以用来做科学计算或工程计算，但在商业计算中，要求数字精度比较高， 故用到java.math.BigDecimal类。BigDecimal类支持不可变的、任意精度的有符号十进制定点数。 </p>
<h2 id="8、Comparable接口与Compator接口"><a href="#8、Comparable接口与Compator接口" class="headerlink" title="8、Comparable接口与Compator接口"></a>8、Comparable接口与Compator接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">class</span> <span class="title class_">student</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;student&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Integer score;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSex</span><span class="params">(String sex)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(Integer age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getScore</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setScore</span><span class="params">(Integer score)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">student</span><span class="params">(Integer id, String name, String sex, Integer age, Integer score)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(student s)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.age.compareTo(s.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="十三、线程"><a href="#十三、线程" class="headerlink" title="十三、线程"></a>十三、线程</h1><h2 id="1、基本概念"><a href="#1、基本概念" class="headerlink" title="1、基本概念"></a>1、基本概念</h2><p>​		程序：为了完成特定任务，用某种语言编写的一组指令的集合。是一段静态的代码，静态对象。 </p>
<p>​		进程：是程序的一次执行过程，或是正在运行的一个程序。是一个动态的过程。有他自身的产生， 存在和消亡的过程。【生命周期】程序是静态的，进程是动态的。进程做为资源的分配单位，系统在运 行时会为每个进程分配不同的内存区域。 </p>
<p>​		线程：线程是程序的执行单元。是程序使用CPU的最基本单位。一个进程的执行，是靠线程来走 的。</p>
<p>​		程序可以进一步细化为线程，是一个程序内部的一条执行路径。若一个进程同一时间并行执 行多个线程，就是支持多线程的。线程做为调度和执行的单位，每个线程拥有独立的运行栈和程序计算 器，线程切换的开销小。一个进程中的多个线程共享相同的内存单元|内存地址。他们从同一堆中分配对 象，可以访问相同的变量和对象。这就使得线程间通信更简洁，高效。但多个线程操作共享的系统资源 可能会带来安全隐患。 </p>
<p>​		单核CPU和多核CPU：单核CPU，其实是一种假的多线程。因为再一个时间单元内，也只能执行一 个线程的任务。因为CPU时间单元特别短，因此感觉不出来。多核的话，才能更好的发挥多线程的效 率。一个java程序java.exe,至少三个线程main()主线程，gc()垃圾回收线程，异常处理线程。如果发生异 常，会影响主线程。 </p>
<p>​		并行域并发：并行： 多个CPU同时执行多个任务。也就是 多人同时做不同的事情。 </p>
<p>​								并发：一个CPU(采用时间片)同时执行多个任务。比如，秒杀，多人做同一件事。 </p>
<p>​		多线程的优点：以单核CPU为例，只使用单个线程 先后完成多个任务（调用多个方法），肯定比 用多个线程来完成用的时间更短，为何仍徐多线程呢？多线程的优点：1&gt;提供应用程序的响应，对图形 化界面更有意义，可增强用户体验。提供计算机系统CPU的利用率。改善程序结构，将既长又复杂的进 程分为多个线程，独立运行，利用理解和修改。 </p>
<p>​		什么时候需要多线程呢？程序需要同时执行两个或多个任务 </p>
<p>​		程序需要实现一些需要等待的任务时，如用户输入，文件读写操作，网络操作，搜索等。 </p>
<p>​		需要一些后台执行的程序时。 </p>
<h2 id="2、-线程的创建和使用"><a href="#2、-线程的创建和使用" class="headerlink" title="2、 线程的创建和使用"></a>2、 线程的创建和使用</h2><p>​		之前的程序都是单线程的。 </p>
<p>​		方式一: JAVA语言的JVM允许程序运行多个线程，它通过java.lang.Thread类来体现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread01</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;i++) &#123;</span><br><span class="line">    		System.out.println(Thread.currentThread().getName()+<span class="string">&quot;---&quot;</span>+i);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread01Test</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread01</span> <span class="variable">thread01</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread01</span>();</span><br><span class="line">        thread01.setName(<span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">        <span class="comment">//thread01.run();//不会启动线程的，现在的程序还是单线程的程序</span></span><br><span class="line">        thread01.start();<span class="comment">//启动线程</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">MyThread01</span> <span class="variable">thread02</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread01</span>();</span><br><span class="line">        thread02.setName(<span class="string">&quot;线程2&quot;</span>);</span><br><span class="line">        thread02.start();<span class="comment">//启动线程</span></span><br><span class="line">        </span><br><span class="line">        thread01.start();<span class="comment">//启动线程</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;i++) &#123;</span><br><span class="line">        	System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>     Thread类的特点：每个线程都说通过某个特定的Thread对象的run()方法来完成操作的，经常把run() 方法的主体称为线程体。我们再使用的时候，是通过调用start()方法来启动这个线程的。 一个线程对象 只能调用一次start()方法启动线程。如果重复调用就会抛出异常&quot;IllegalThreadStateException&quot; 
</code></pre>
<p>​		方式二：实现Runnable接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread02</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThread02</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    		System.out.println(name + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread02</span> <span class="variable">thread01</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread02</span>(<span class="string">&quot;线程01&quot;</span>);</span><br><span class="line">        <span class="type">MyThread02</span> <span class="variable">thread02</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread02</span>(<span class="string">&quot;线程02&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(thread01);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(thread02);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="3、线程状态"><a href="#3、线程状态" class="headerlink" title="3、线程状态"></a>3、线程状态</h2><p>​		新建(New)：在程序中用构造方法创建了一个线程对象后，新的线程对象便处于新建状态，此 时，他已经有了相应的内存空间和其他资源，但还不处于可运行状态。 </p>
<p>​		就绪(Runnable)：新建线程对象后，可调用线程的start()方法就可以启动线程。当线程启动时， 线程进入就绪状态。此时，线程将进入线程队列排队，等待CPU服务，这表名他已经具备了运行条件 </p>
<p>​		运行(Running)：当就绪状态的线程被调用并获得处理器资源时，线程就进入了运行状态。此 时，自动调用该线程对象的run()方法。run()方法定义了该线程的操作和功能。 </p>
<p>​		阻塞(Blocked)：一个正在执行的线程在某些特殊情况下，如被认为挂起或需要执行耗时的输入&#x2F; 输出操作时，会让出CPU并暂时终止自己的行为，进入堵塞状态，在可执行状态下，如果调用 sleep(),suspend().wait()等方法，线程将进入堵塞状态。堵塞时，线程不能进入排队队列，只有当引起 堵塞的原因被消除后，线程才可以转入就绪状态。线程调用了sleep()方法主动放弃所占用的处理器资 源。线程调用了一个阻塞式IO方法,在该方法返回之前,该线程被阻塞。线程试图获得一个同步监视器,但 该同步监视器正被其它线程所持有。线程在等待某个通知(notify)。 </p>
<p>​		死亡(Dead)：线程调用stop()方法时或run()方法执行结束后，处于死亡状态。处于死亡状态的线 程不具备继续运行的能力。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220220202058387.png" alt="image-20220220202058387"></p>
<p><strong>一些方法：</strong> </p>
<h3 id="1-gt-join方法"><a href="#1-gt-join方法" class="headerlink" title="1&gt;join方法"></a>1&gt;join方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;i++)&#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+ <span class="string">&quot;:&quot;</span>+i);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">th1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(thread, <span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">th2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(thread, <span class="string">&quot;线程2&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">th3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(thread, <span class="string">&quot;线程3&quot;</span>);</span><br><span class="line">        th1.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        	th1.join();<span class="comment">//等待th1运行完毕后，其他线程才执行</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        	e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        th2.start();</span><br><span class="line">        th3.start();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;i++)&#123;</span><br><span class="line">       	 	System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-gt-sleep方法"><a href="#2-gt-sleep方法" class="headerlink" title="2&gt; sleep方法"></a>2&gt; sleep方法</h3><p>​		在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统 计时器和调度程序精度和准确性的影响。该线程不丢失任何监视器的所属权。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;i++)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+ <span class="string">&quot;:&quot;</span>+i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">        		Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        	&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        		e.printStackTrace();</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">th1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(thread, <span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">        th1.start();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;i++)&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-gt-Interrupt-线程被中断"><a href="#3-gt-Interrupt-线程被中断" class="headerlink" title="3&gt;Interrupt 线程被中断"></a>3&gt;Interrupt 线程被中断</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始执行：&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">       	 	Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        	System.out.println(<span class="string">&quot;线程被中断&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;程序结束:&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThreadTest</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">th1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(thread, <span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">        th1.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            th1.interrupt();<span class="comment">//线程直接被中断了。</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">       	 	e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4-gt-yield"><a href="#4-gt-yield" class="headerlink" title="4&gt; yield"></a>4&gt; yield</h3><p>​		暂停当前正在执行的线程对象，并执行其他线程。yield()应该做的是让当前运行线程 回到可运行状态，以允许具有相同优先级的其他线程获得运行机会。因此，使用yield()的目的是让相同 优先级的线程之间能适当的轮转执行。但是，实际中无法保证yield()达到让步目的，因为让步的线程还 有可能被线程调度程序再次选中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+i);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">run</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(run, <span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">            System.out.println(name+<span class="string">&quot;:&quot;</span>+i);</span><br><span class="line">            Thread.<span class="keyword">yield</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-gt-join方法"><a href="#5-gt-join方法" class="headerlink" title="5&gt;join方法"></a>5&gt;join方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;i++)&#123;</span><br><span class="line">    		System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+i);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThredTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">run</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">th1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(run, <span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">th2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(run, <span class="string">&quot;线程2&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">th3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(run, <span class="string">&quot;线程3&quot;</span>);</span><br><span class="line">        th1.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        	th1.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        	e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        th2.start();</span><br><span class="line">        th3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-gt-线程的优先级"><a href="#6-gt-线程的优先级" class="headerlink" title="6&gt;线程的优先级"></a>6&gt;线程的优先级</h3><p>​		线程默认优先级是5，可以自己设置线程的优先级。通过，setPriority()方 法来设置线程的优先级。优先级的范围是1-10.线程优先级高仅仅表示线程获取CPU时间片的几率高，但 是要在次数比较多，或者多此运行时才能看比较好的效果。 </p>
<p>线程分为两类，一类是守护线程，一类是用户线程。他们在几乎每个方面都说相同的，唯一的 区别是判断JVM何时离开。守护线程是用来服务用户线程的。通过在start()方法前调用 </p>
<p>thread.setDaemon(true)可以把一个用户线程变成守护线程。Java垃圾回收就是一个典型的守护线程。 弱JVM中都是守护线程，当前JVM将退出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">run</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">th1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(run, <span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">th2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(run, <span class="string">&quot;线程2&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">th3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(run, <span class="string">&quot;线程3&quot;</span>);</span><br><span class="line">        th1.setPriority(<span class="number">10</span>);</span><br><span class="line">        th3.setPriority(<span class="number">1</span>);</span><br><span class="line">        th1.start();</span><br><span class="line">        th2.start();</span><br><span class="line">        th3.start();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="4、同步域死锁"><a href="#4、同步域死锁" class="headerlink" title="4、同步域死锁"></a>4、同步域死锁</h2><p>​		创建三个窗口买票，总票数为60张票。按照之前的代码，会发现代码出现问题，又相同的票或者 负数出现。出现问题的原因是当某个线程操作车票的过程中，操作尚未完成，其他线程进入，也操作了 该车票。如何解决？当一个线程a在操作ticket的时候，其他线程不能参与进来，直到线程a操作完成， 其他线程才可以操作。可以采用同步解决该问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(同步监视器)&#123;</span><br><span class="line">		<span class="comment">//需要被同步的代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> 操作共享数据的代码，即为需要被同步的代码，不能多包含也不能少包含。</p>
<p> 共享数据：多个线程共同操作的变量 </p>
<p>同步监视器：俗称，锁。任何一个类的对象，都可以充当锁，但是要去必须多个线程公用一把锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tickets</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">60</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (num &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() +	<span class="string">&quot;再售&quot;</span> + num);</span><br><span class="line">                    num--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TicketsTest</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">Tickets</span> <span class="variable">run</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tickets</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">th1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(run,<span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">th2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(run,<span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">th3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(run,<span class="string">&quot;窗口3&quot;</span>);</span><br><span class="line">        th1.start();</span><br><span class="line">        th2.start();</span><br><span class="line">        th3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​		同步的特点：前提：多个线程。 </p>
<p>​		解决问题的时候要注意:多个线程使用的是同一个锁对象。</p>
<p>​		同步的好处：同步的出现解决了多线程的安全问题。 </p>
<p>​		同步弊端：当线程相当多时，因为每个线程都会去判断同步上的锁，这是很耗费资源的，无形中会 降低程序的运行效率。 </p>
<p>synchronized： 同步，需要被同步的代码。 </p>
<p>​	同步方法，仍然需要同步监视器，只是不需要显示声明 </p>
<p>​	非静态的同步方法，同步监视器是this </p>
<p>​	静态的同步方法，同步监视器是 当前类本身。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Singleton singleton;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton==<span class="literal">null</span>)&#123;</span><br><span class="line">        	singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Singleton singleton;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton==<span class="literal">null</span>)&#123;</span><br><span class="line">       		<span class="keyword">synchronized</span>(Singletion.class)&#123;</span><br><span class="line">        		<span class="keyword">if</span>(singleton==<span class="literal">null</span>)&#123;</span><br><span class="line">        			singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        		&#125;</span><br><span class="line">        	&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	死锁 : 不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源， 就形成了死锁。出现死锁后，不会出现异常，不会出现提升，只是所有的线程都处于阻塞状态，无法继 续。解决办法：专门的算法，原则。尽量减少同步资源的定义，尽量避免嵌套同步。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLock</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> String s1=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Lock1</span> <span class="variable">lock1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Lock1</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(lock1);</span><br><span class="line">        </span><br><span class="line">        <span class="type">Lock2</span> <span class="variable">lock2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Lock2</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(lock2);</span><br><span class="line">        </span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lock2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Lock2执行&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (DeadLock.s2) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Lock2持有s2的锁&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (DeadLock.s1) &#123;</span><br><span class="line">                    	System.out.println(<span class="string">&quot;Lock2持有s1锁&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lock1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Lock1执行&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (DeadLock.s1) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Lock1持有s1的锁&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (DeadLock.s2) &#123;</span><br><span class="line">                    	System.out.println(<span class="string">&quot;Lock1持有s2锁&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如何避免死锁呢？加锁顺序（线程按照一定的顺序加锁）。加锁时限（线程尝试获取锁的时候加上一定 的时限，超过时限则放弃对该锁的请求，并释放自己占有的锁）。死锁检测。</p>
<p> Lock(锁): 从JDK5.0开始，java提供了更强大的线程同步机制。通过显示定义同步锁对象来实现同步。同 步锁使用Lock对象充当。该接口是控制多个线程对共享资源进行访问的公交。锁提供了对共享资源的独 占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象。 </p>
<p>ReentrantLock类实现了Lock接口，他拥有与synchronized相同的并发性盒内存语义，再实现线程安全 的控制中，比较常用的RenntrantLock可以显示的加锁和释放锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Window</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="comment">//1.实例化ReentrantLock</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//2.调用锁定方法lock()</span></span><br><span class="line">                	System.out.println(Thread.currentThread().getName() +<span class="string">&quot;：售票，票号为：&quot;</span> + ticket);</span><br><span class="line">                	ticket--;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                	<span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//3.调用解锁方法：unlock()</span></span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Window</span> <span class="variable">w</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Window</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(w);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(w);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(w);</span><br><span class="line">        </span><br><span class="line">        t1.setName(<span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">        t2.setName(<span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">        t3.setName(<span class="string">&quot;窗口3&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<pre><code>     synchronized与lock的异同：二者都可以解决线程安全问题。synchronized机制再执行完相应的同 步代码以后，自动的释放同步监视器。Lock需要手动的启动同步（lock()），同时结束同步也需要手动的 实现（unlock()） 
</code></pre>
<h3 id="练习：-17"><a href="#练习：-17" class="headerlink" title="练习："></a>练习：</h3><p>两个用户分布向一个账户存3000元，每次存1000，存3次。每次存款后打印账户余额</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> balance;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBalance</span><span class="params">(<span class="type">int</span> balance)</span> &#123;</span><br><span class="line">    	<span class="built_in">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">inMoney</span><span class="params">(<span class="type">int</span> money)</span>&#123;</span><br><span class="line">    	<span class="built_in">this</span>.balance = <span class="built_in">this</span>.balance+money;</span><br><span class="line">        </span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;存款，卡中余额：&quot;</span>+balance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Customer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    Account account;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Customer</span><span class="params">(Account account)</span> &#123;</span><br><span class="line">    	<span class="built_in">this</span>.account = account;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">        	<span class="keyword">try</span> &#123;</span><br><span class="line">        		Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        	&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        		e.printStackTrace();</span><br><span class="line">        	&#125;</span><br><span class="line">       	 	account.inMoney(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CustomerTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Account</span> <span class="variable">account</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Account</span>();</span><br><span class="line">        <span class="type">Customer</span> <span class="variable">cus1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Customer</span>(account);</span><br><span class="line">        cus1.setName(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        <span class="type">Customer</span> <span class="variable">cus2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Customer</span>(account);</span><br><span class="line">        cus2.setName(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        cus1.start();</span><br><span class="line">        cus2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5、线程之间的通信"><a href="#5、线程之间的通信" class="headerlink" title="5、线程之间的通信"></a>5、线程之间的通信</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.openlab.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintNum</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        </span><br><span class="line">    	<span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            </span><br><span class="line">    		<span class="keyword">try</span> &#123;</span><br><span class="line">   				 Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                </span><br><span class="line">    			<span class="comment">// wait();</span></span><br><span class="line">    		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    			e.printStackTrace();</span><br><span class="line">   			 &#125;</span><br><span class="line">    	<span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;</span><br><span class="line">            notify();</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">100</span>)&#123;</span><br><span class="line">            	<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+i);</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">        		wait();</span><br><span class="line">        	&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        		e.printStackTrace();</span><br><span class="line">       		&#125;</span><br><span class="line">        &#125;</span><br><span class="line">     	</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PrintNumTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">PrintNum</span> <span class="variable">run</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintNum</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">th1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(run,<span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">th2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(run,<span class="string">&quot;线程2&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">th3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(run,<span class="string">&quot;线程3&quot;</span>);</span><br><span class="line">        th1.start();</span><br><span class="line">        th2.start();</span><br><span class="line">        th3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>wait方法，一旦执行，线程进入阻塞状态，并释放对象的锁。 </p>
<p>notify方法，一旦执行，会唤醒等待的线程，如果有多个线程，唤醒优先级高的 </p>
<p>notifyAll方法，会 唤醒所有等待的线程。 </p>
<p>这三个方便必须再同步方法或同步代码块中使用。 </p>
<p>sleep和wait方法的异同？相同点：一旦执行方法，都可以使得当前的线程进入阻塞状态。</p>
<p> 不同点：两个方法声明的位置不同，Thread中是sleep方法。Object类中是wait方法。 </p>
<p>调用的范围不同：sleep方法可以再任何需要的场景下调用。wait必须在同步代码块中运行。如果两个方 法都用在同步代码块或同步方法中，sleep不会释放对象锁。wait方法会释放锁。 </p>
<p>生产者与消费者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 工厂</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">		<span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span>];<span class="comment">//生产者生产的物品放入该数组中，消费者从该数组中取值</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//记录生产者生产一个，或消费者消费一个</span></span><br><span class="line">		<span class="comment">//1.生产东西</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">setProduct</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">if</span>(index==<span class="number">1</span>) &#123;<span class="comment">//生产者已经生产，但是消费者未消费</span></span><br><span class="line">					<span class="built_in">this</span>.wait(<span class="number">3000</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">            arr[<span class="number">0</span>]=num;<span class="comment">//生产的东西保存，以便消费者消费</span></span><br><span class="line">            System.out.println(<span class="string">&quot;生产者生产:&quot;</span>+arr[<span class="number">0</span>]);</span><br><span class="line">            <span class="built_in">this</span>.notify();<span class="comment">//通知消费者消费</span></span><br><span class="line">            index++;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//2.取东西</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">getProduct</span><span class="params">()</span> &#123;</span><br><span class="line">        	<span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(index==<span class="number">0</span>) &#123;</span><br><span class="line">               		 <span class="built_in">this</span>.wait();<span class="comment">//如果发现index==0说明还未生产好，需要等待</span></span><br><span class="line">                &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        		e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        System.out.println(<span class="string">&quot;消费者消费:&quot;</span>+arr[<span class="number">0</span>]);</span><br><span class="line">        index--;</span><br><span class="line">        <span class="comment">//this.notify();//通知生产者生产</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Product</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">	<span class="type">Factory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Product</span><span class="params">(Factory factory)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">		<span class="built_in">this</span>.factory = factory;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++) &#123;</span><br><span class="line">    		factory.setProduct(i);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">	<span class="type">Factory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Customer</span><span class="params">(Factory factory)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.factory = factory;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">   		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++) &#123;</span><br><span class="line">    		factory.getProduct();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Factory</span> <span class="variable">fa</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Factory</span>();</span><br><span class="line">        <span class="type">Product</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Product</span>(fa);</span><br><span class="line">        p.start();</span><br><span class="line">        <span class="type">Customer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Customer</span>(fa);</span><br><span class="line">        c.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6、其他创建线程方式"><a href="#6、其他创建线程方式" class="headerlink" title="6、其他创建线程方式"></a>6、其他创建线程方式</h2><h3 id="1-gt-实现Callable接口"><a href="#1-gt-实现Callable接口" class="headerlink" title="1&gt; 实现Callable接口"></a>1&gt; 实现Callable接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建一个实现Callable的实现类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumThread</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&#123;</span><br><span class="line">	<span class="comment">//2.实现call方法，将此线程需要执行的操作声明在call()中</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">    		<span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                sum += i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sum;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadNewTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//3.创建Callable接口实现类的对象</span></span><br><span class="line">		<span class="type">NumThread</span> <span class="variable">numThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NumThread</span>();</span><br><span class="line">		<span class="comment">//4.将此Callable接口实现类的对象作为传递到FutureTask构造器中，创建FutureTask的对象</span></span><br><span class="line">		<span class="type">FutureTask</span> <span class="variable">futureTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>(numThread);</span><br><span class="line">		<span class="comment">//5.将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()</span></span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask).start();</span><br><span class="line">        </span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//6.获取Callable中call方法的返回值</span></span><br><span class="line">			<span class="comment">//get()返回值即为FutureTask构造器参数Callable实现类重写的call()的返回值。</span></span><br><span class="line">			<span class="type">Object</span> <span class="variable">sum</span> <span class="operator">=</span> futureTask.get();</span><br><span class="line">			System.out.println(<span class="string">&quot;总和为：&quot;</span> + sum);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">   			e.printStackTrace();</span><br><span class="line">   		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-gt-线程池"><a href="#2-gt-线程池" class="headerlink" title="2&gt;线程池:"></a>2&gt;线程池:</h3><p>经常创建和销毁，使用量特别大的资源，比如并发情况下的线程，对性能影响很大。如何 解决？提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁的创建 销毁，实现重复利用。使用线程池的 好处：提高响应速度，减少了创建新线程的时间，奖励资源消耗， 重复利用线程池中的线程，不需要每次都创建。便于线程管理。有一些属性：corePoolSize:核心池的大 小，maxnumPoolSize:最大线程数，keeAliveTime:线程没有任务时最多保持多长时间会终止。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumberThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt;= <span class="number">100</span>;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">				System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> +i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumberThread1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt;= <span class="number">100</span>;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(i % <span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">				System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> +i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//1. 提供指定线程数量的线程池</span></span><br><span class="line">		<span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">		<span class="type">ThreadPoolExecutor</span> <span class="variable">service1</span> <span class="operator">=</span> (ThreadPoolExecutor) service;</span><br><span class="line">		<span class="comment">//设置线程池的属性</span></span><br><span class="line">		<span class="comment">// System.out.println(service.getClass());</span></span><br><span class="line">		<span class="comment">// service1.setCorePoolSize(15);</span></span><br><span class="line">		<span class="comment">// service1.setKeepAliveTime();</span></span><br><span class="line">        </span><br><span class="line">		<span class="comment">//2.执行指定的线程的操作。需要提供实现Runnable接口或Callable接口实现类的对象</span></span><br><span class="line">		service.execute(<span class="keyword">new</span> <span class="title class_">NumberThread</span>());<span class="comment">//适合适用于Runnable</span></span><br><span class="line">		service.execute(<span class="keyword">new</span> <span class="title class_">NumberThread1</span>());<span class="comment">//适合适用于Runnable</span></span><br><span class="line">        </span><br><span class="line">		<span class="comment">// service.submit(Callable callable);//适合使用于Callable</span></span><br><span class="line">		<span class="comment">//3.关闭连接池</span></span><br><span class="line">		service.shutdown();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="十四、枚举和注解"><a href="#十四、枚举和注解" class="headerlink" title="十四、枚举和注解"></a>十四、枚举和注解</h1><h2 id="1、枚举"><a href="#1、枚举" class="headerlink" title="1、枚举"></a>1、枚举</h2><p><strong>当需要定义一组常量时，强烈建议使用枚举类</strong> </p>
<p>枚举类的实现 JDK1.5之前需要自定义枚举类 JDK 1.5 新增的 <strong>enum 关键字</strong>用于定义枚举类 </p>
<p>若枚举只有一个对象, 则可以作为一种单例模式的实现方式。 </p>
<p><strong>枚举类的属性</strong> </p>
<p><strong>枚举类对象的属性不应允许被改动, 所以应该使用 private final 修饰</strong> </p>
<p>枚举类的使用 private final 修饰的属性应该在构造器中为其赋值若枚举类显式的定义了带参数的构造器, 则在列出枚举值时也必须对应的传入参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Day</span> &#123;</span><br><span class="line">	MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">SeasonEnum</span> &#123;</span><br><span class="line">SPRING(<span class="string">&quot;Spring&quot;</span>,<span class="string">&quot;春意盎然&quot;</span>),</span><br><span class="line">SUMMER(<span class="string">&quot;Summer&quot;</span>,<span class="string">&quot;烈日炎炎&quot;</span>),</span><br><span class="line">AUTUMN(<span class="string">&quot;Autumn&quot;</span>,<span class="string">&quot;秋高气爽&quot;</span>),</span><br><span class="line">WINTER(<span class="string">&quot;Winter&quot;</span>,<span class="string">&quot;寒风凛冽&quot;</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line"><span class="keyword">private</span> <span class="title function_">SeasonEnum</span><span class="params">(String seasonName, String seasonDesc)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.seasonName = seasonName;</span><br><span class="line"><span class="built_in">this</span>.seasonDesc = seasonDesc; &#125;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getSeasonName</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> seasonName; &#125;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getSeasonDesc</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> seasonDesc; &#125; &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">SeansEnum</span> <span class="keyword">implements</span> <span class="title class_">info</span>&#123;</span><br><span class="line">	SPRING(<span class="string">&quot;Spring&quot;</span>,<span class="string">&quot;春意盎然&quot;</span>)&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;春天，春意盎然&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">    SUMMER(<span class="string">&quot;Summer&quot;</span>,<span class="string">&quot;烈日炎炎&quot;</span>)&#123;</span><br><span class="line">    	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">    		System.out.println(<span class="string">&quot;夏天，夏日炎炎&quot;</span>);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    AUTUMN(<span class="string">&quot;Autumn&quot;</span>,<span class="string">&quot;秋高气爽&quot;</span>)&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        	System.out.println(<span class="string">&quot;秋天，秋高气爽&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    WINTER(<span class="string">&quot;Winter&quot;</span>,<span class="string">&quot;寒风凛冽&quot;</span>)&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        	System.out.println(<span class="string">&quot;冬天，冰雪皑皑&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SeansEnum</span><span class="params">(String seasonName, String seasonDesc)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.seasonName = seasonName;</span><br><span class="line">        <span class="built_in">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonName</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> seasonName;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonDesc</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">info</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">SeansEnum</span> <span class="variable">autumn</span> <span class="operator">=</span> SeansEnum.AUTUMN;</span><br><span class="line">		autumn.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="2、注解"><a href="#2、注解" class="headerlink" title="2、注解"></a>2、注解</h2><p>从 JDK 5.0 开始, Java 增加了对元数据(MetaData) 的支持, 也就是Annotation(注解)</p>
<p> Annotation 其实就是代码里的<strong>特殊标记</strong>, 这些标记可以在编译, 类加载, 运行时被读取, 并执行相应的处 理。通过使用 Annotation, 程序员可以在不改变原有逻辑的情况下, 在源文件中嵌入一些补充信息。代码 分析工具、开发工具和部署工具可以通过这些补充信息进行验证或者进行部署。 </p>
<p>Annotation 可以像修饰符一样被使用, 可用于修饰包,类, 构造器,方法,成员变量, 参数,局部变量的声明, 这 些信息被保存在 Annotation 的 “name&#x3D;value” 对中 </p>
<p>常见注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>: 限定重写父类方法, 该注解只能用于方法</span><br><span class="line"><span class="meta">@Deprecated</span>: 用于表示所修饰的元素(类, 方法等)已过时。通常是因为所修饰的结构危险或存在更好的选择</span><br><span class="line"><span class="meta">@SuppressWarnings</span>: 抑制编译器警告</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>JDK中的元注解 </p>
<p>JDK 的元 Annotation 用于修饰其他 Annotation 定义。</p>
<p>JDK5.0提供了4个标准的meta-annotation类型，分别是：Retention Target Documented Inherited。 </p>
<p>@Retention: 只能用于修饰一个 Annotation 定义, 用于指定该 Annotation 的生命周期, @Rentention 包含一个 RetentionPolicy 类型的成员变量, 使用@Rentention 时必须为该 value 成员变量指定值: </p>
<p>**RetentionPolicy.SOURCE:**在源文件中有效（即源文件保留），编译器直接丢弃这种策略的注释 </p>
<p>**RetentionPolicy.CLASS:**在class文件中有效（即class保留） ， 当运行 Java 程序时, JVM 不会保留注 解。 这是默认值 </p>
<p><strong>RetentionPolicy.RUNTIME:<strong>在运行时有效（即运行时保留），</strong>当运行 Java</strong> 程序时, JVM 会保留注释。 程序可以通过反射获取该注释。 </p>
<p><strong>@Target:</strong> 用于修饰 Annotation 定义, 用于指定被修饰的 Annotation 能用于修饰哪些程序元素。 </p>
<p>@Target 也包含一个名为 value 的成员变量。 </p>
<h1 id="十五、集合"><a href="#十五、集合" class="headerlink" title="十五、集合"></a>十五、集合</h1><p>数组在内存存储方面的特点：数组初始化以后，长度就确定了。数组声明的类型，就决定了进行元素初 始化时的类型数组在存储数据方面的弊端：数组初始化以后，长度就不可变了，不便于扩展。数组中提 供的属性和方法少，不便于进行添加、删除、插入等操作，且效率不高。同时无法直接获取存储元素的 个数。数组存储的数据是有序的、可以重复的。—-&gt;存储数据的特点单一，Java 集合类可以用于存储数 量不等的多个<strong>对象</strong>，还可用于保存具有映射关系的关联数组。保存数据的时候，需要考虑使用集合。 </p>
<p>Java 集合可分为 Collection 和 Map 两种体系。Collection接口：单列数据，定义了存取一组对象的方法 的集合List：元素有序、可重复的集合。Set：元素无序、不可重复的集合。Map接口：双列数据，保存 具有映射系“key-value对”的集合。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220220202502317.png" alt="image-20220220202502317"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220220202508889.png" alt="image-20220220202508889"></p>
<h2 id="1、Collection接口"><a href="#1、Collection接口" class="headerlink" title="1、Collection接口"></a>1、Collection接口</h2><p>既然Collection接口是集合中的顶层接口，那么它中定义的所有功能子类都可以使用。查阅API中描述的 Collection接口。Collection 层次结构 中的根接口。Collection 表示一组对象，这些对象也称为 collection 的元素。一些 collection 允许有重复的元素，而另一些则不允许。一些 collection 是有序 的，而另一些则是无序的。这里我们不关心具体创建的Collection中的那个子类对象，这里重点演示的是 Collection接口中的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>:确保此 collection 包含指定的元素（可选操作）。</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span>:将指定 collection 中的所有元素都添加到此collection 中（可选操作）。</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>:移除此 collection 中的所有元素（可选操作）。</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span>:如果此 collection 包含指定的元素，则返回 <span class="literal">true</span> 。</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span>:如果此 collection 包含指定 collection 中的所有元素，则返回 <span class="literal">true</span> 。</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span>:比较此 collection 与指定对象是否相等。</span><br><span class="line"><span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>:返回此 collection 的哈希码值。</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>:如果此 collection 不包含元素，则返回 <span class="literal">true</span> 。</span><br><span class="line">Iterator <span class="title function_">iterator</span><span class="params">()</span>:返回在此 collection 的元素上进行迭代的迭代器。</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span>:从此 collection 中移除指定元素的单个实例，如果存在的话（可选操作）。</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span>:移除此 collection 中那些也包含在指定collection 中的所有元素（可选操作）。</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span>:仅保留此 collection 中那些也包含在指定collection 的元素（可选操作）。</span><br><span class="line"><span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>:返回此 collection 中的元素数。</span><br><span class="line">Object[] toArray():返回包含此 collection 中所有元素的数组。</span><br><span class="line">T[] toArray(T[] a):返回包含此 collection 中所有元素的数组；返回数组的运行时类型与指定数组的运行时类型相同。</span><br></pre></td></tr></table></figure>

<h2 id="2、迭代器的使用"><a href="#2、迭代器的使用" class="headerlink" title="2、迭代器的使用"></a>2、迭代器的使用</h2><p>Iterator原理由于集合容器有很多，每个容器都有自身的数据存储结构，即每个容器自身最清楚自己中数 据是如何存储的，容器这么多，每个容器数据存储又不相同，这时就在它们之间找取出元素的共性进行 了抽取，抽取出集合容器取出元素的共同特点。在取元素之前先要判断集合中有没有元素，如果有，就 把这个元素取出来，继续在判断，如果还有就再取出来。一直把集合中的所有元素全部取出。这种取出 方式专业术语称为迭代。集合中把这种取元素的方式描述在Iterator接口中。</p>
<p><strong>注意</strong>：在进行集合元素取出时，如果集合中已经没有元素了，还继续使用迭代器的next方法，将会发生 java.util.NoSuchElementException没有这个元素异常。 </p>
<h2 id="3、List接口常用接口"><a href="#3、List接口常用接口" class="headerlink" title="3、List接口常用接口"></a>3、List接口常用接口</h2><p>鉴于Java中数组用来存储数据的局限性，我们通常使用List替代数组。一个有序集合（也被称为序列）。 此接口的用户在列表中的每个元素都被插入的地方有精确的控制。用户可以通过它们的整数索引（在列 表中的位置）访问元素，并在列表中搜索元素。 与set不同的是，列表通常允许重复元素。 </p>
<p>List集合类中<strong>元素有序、且可重复</strong>，集合中的每个元素都有其对应的顺序索引。 </p>
<p>List容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素。 </p>
<p>JDK API中List接口的实现类常用的有：ArrayList、LinkedList和Vector。 </p>
<p>List方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> ：在列表的指定位置插入指定元素（可选操作）。</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span> index, Collection&lt;? extends E&gt; c)</span> ：将指定collection 中的所有元素都插入到列表中的指定位置。</span><br><span class="line">E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> ：返回列表中指定位置的元素。</span><br><span class="line"><span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span> ：返回此列表中第一次出现的指定元素的索引；如果此列表不包含该元素，则返回 -<span class="number">1</span>。</span><br><span class="line"><span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(Object o)</span> ：返回此列表中最后出现的指定元素的索引；如果列表不包含此元素，则返回 -<span class="number">1</span>。</span><br><span class="line">ListIterator <span class="title function_">listIterator</span><span class="params">()</span> ：返回此列表元素的列表迭代器（按适当顺序）。</span><br><span class="line">E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> ：移除列表中指定位置的元素（可选操作）。</span><br><span class="line">E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> ：用指定元素替换列表中指定位置的元素（可选操作）。</span><br><span class="line">List <span class="title function_">subList</span><span class="params">(<span class="type">int</span> fromIndex, <span class="type">int</span> toIndex)</span> ：返回列表中指定的 fromIndex （包括 ）和toIndex （不包括）之间的部分视图。</span><br><span class="line"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> E&gt; c)</span> ：分类列表使用提供的 Comparator比较元素。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>List Iterator介绍</strong> </p>
<p>在迭代过程中，使用了集合的方法对元素进行操作。导致迭代器并不知道集合中的变化，容易引发数据 的不确定性。解决：在迭代时，不要使用集合的方法操作元素。那么想要在迭代时对元素操作咋办？可 以使用迭代器的方法操作。可是很遗憾：迭代器Iterator的方式只有 hasNext() ,next(),remove();Iterator 有一个子接ListIterator可以完成该问题的解决。如何获取该子接口对象呢？通过List接口中的 listIterator()就可以获取。 </p>
<p><strong>List 实现子类</strong> </p>
<p>Collection接口：单列集合，用来存储一个一个的对象。 </p>
<p>List接口：存储有序的、可重复的数据。 –&gt;“动态”数组,替换原有的数组。 </p>
<p>ArrayList：作为List接口的主要实现类；线程不安全的，效率高；底层使用Object[] elem。entData存 储 </p>
<p>LinkedList：对于频繁的插入、删除操作，使用此类效率比ArrayList高；底层使用双向链表存储。 </p>
<p>Vector:作为List接口的古老实现类，线程安全的，效率低。底层使用Object[] elementData存储。</p>
<p> <strong>ArrayList</strong> List 接口的大小可变数组的实现。实现了所有可选列表操作，并允许包括 null 在内的所有元 素。 </p>
<p>每个 ArrayList 实例都有一个容量 。该容量是指用来存储列表元素的数组的大小。它总是至少等于列表 的大小。随着向 ArrayList 中不断添加元素，其容量也自动增长。此实现不是同步的。 </p>
<p><strong>ArrayList</strong>的JDK1.8之前与之后的实现区别？ </p>
<p>JDK1.7：ArrayList像饿汉式，直接创建一个初始容量为10的数组 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">		<span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">												initialCapacity);</span><br><span class="line">		<span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">		ensureCapacityInternal(size + <span class="number">1</span>); <span class="comment">// Increments modCount!!</span></span><br><span class="line">		elementData[size++] = e;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">		modCount++;</span><br><span class="line">		<span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        	grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        	newCapacity = minCapacity;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        	newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> ArrayList list &#x3D; new ArrayList();&#x2F;&#x2F;底层创建了长度是10的Object[]数组elementData </p>
<p>list.add();&#x2F;如果此次的添加导致底层elementData数组容量不够，则扩容。 </p>
<p>默认情况下，扩容为原来的容量的1.5倍，同时需要将原有数组中的数据复制到新的数组中。 </p>
<p>结论：建议开发中使用带参的构造器：ArrayList list &#x3D; new ArrayList(int capacity)</p>
<p>JDK1.8：ArrayList像懒汉式，一开始创建一个长度为0的数组，当添加第一个元素时再创建一个始容量 为10的数组。默认扩容是原来的1.5倍。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>); <span class="comment">// Increments modCount!!</span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        	minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        	grow(minCapacity);</span><br><span class="line">	&#125;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        	newCapacity = minCapacity;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        	newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>LinkedList</strong> List 接口的链接列表实现。实现所有可选的列表操作，并且允许所有元素（包括 null ）。 除了实现 List 接口外， LinkedList 类还为在列表的开头及结尾 get 、 remove 和 insert 元素提供了统一 的命名方法。这些操作允许将链接列表用作堆栈、<strong>队列</strong>或<strong>双端队列</strong>。所有操作都是按照双重链接列表的 需要执行的。在列表中编索引的操作将从开头或结尾遍历列表（从靠近指定索引的一端）。 </p>
<p>LinkedList list &#x3D; new LinkedList(); 内部声明了Node类型的first和last属性，默认值为null。 </p>
<p>list.add(123);&#x2F;&#x2F;将123封装到Node中，创建了Node对象。</p>
<p>Node定义为：体现了LinkedList的双向链表的说法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">	Node&lt;E&gt; next;</span><br><span class="line">	Node&lt;E&gt; prev;</span><br><span class="line">    </span><br><span class="line">	Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">		<span class="built_in">this</span>.item = element;</span><br><span class="line">		<span class="built_in">this</span>.next = next;</span><br><span class="line">		<span class="built_in">this</span>.prev = prev;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(E e)</span>:将指定元素插入此列表的开头。</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(E e)</span>:将指定元素添加到此列表的结尾。</span><br><span class="line">E <span class="title function_">removeFirst</span><span class="params">()</span>:移除并返回此列表的第一个元素。</span><br><span class="line">E <span class="title function_">removeLast</span><span class="params">()</span>:移除并返回此列表的最后一个元素。</span><br><span class="line">E <span class="title function_">getFirst</span><span class="params">()</span>:返回此列表的第一个元素。</span><br><span class="line">E <span class="title function_">getLast</span><span class="params">()</span>:返回此列表的最后一个元素。</span><br><span class="line"><span class="type">boolean</span> ow <span class="title function_">erFirst</span><span class="params">(E e)</span>:在此列表的开头插入指定的元素。</span><br><span class="line"><span class="type">boolean</span> ow <span class="title function_">erLast</span><span class="params">(E e)</span>:在此列表的末尾插入指定的元素。</span><br><span class="line">E <span class="title function_">pollFirst</span><span class="params">()</span>:获取并移除此列表的第一个元素；如果此列表为空，则返回 <span class="literal">null</span> 。 E</span><br><span class="line"><span class="title function_">pollLast</span><span class="params">()</span> ：获取并移除此列表的最后一个元素；如果此列表为空，则返回 <span class="literal">null</span> 。 E</span><br><span class="line"><span class="title function_">peekFirst</span><span class="params">()</span> ：获取但不移除此列表的第一个元素；如果此列表为空，则返回 <span class="literal">null</span> 。 E</span><br><span class="line"><span class="title function_">peekLast</span><span class="params">()</span> ：获取但不移除此列表的最后一个元素；如果此列表为空，则返回 <span class="literal">null</span> 。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>Vector</strong> 是一个古老的集合，JDK1.0就有了。大多数操作与ArrayList相同，区别之处在于Vector是线程 安全的。 </p>
<p>在各种list中，最好把ArrayList作为缺省选择。当插入、删除频繁时，使用LinkedList；Vector总是比 ArrayList慢，所以尽量避免使用。 </p>
<p>请问ArrayList&#x2F;LinkedList&#x2F;Vector的异同？谈谈你的理解？ArrayList底层是什么？扩容机制？Vector和 ArrayList的最大区别?</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ArrayList和LinkedList的异同</span><br><span class="line">二者都线程不安全，相对线程安全的Vector，执行效率高。</span><br><span class="line">此外，ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。对于新增和删除操作add(特指插入)和remove，LinkedList比较占优势，因为ArrayList要移动数据。</span><br><span class="line">ArrayList和Vector的区别</span><br><span class="line">Vector和ArrayList几乎是完全相同的,唯一的区别在于Vector是同步类(<span class="keyword">synchronized</span>)，属于强同步类。因此开销就比ArrayList要大，访问要慢。正常情况下,大多数的Java程序员使用ArrayList而不是Vector,因为同步完全可以由程序员自己来控制。Vector每次扩容请求其大小的<span class="number">2</span>倍空间而ArrayList是<span class="number">1.5</span>倍。Vector还有一个子类Stack。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>List接口的常用方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">list.add(<span class="number">1</span>);</span><br><span class="line">list.add(<span class="number">2</span>);</span><br><span class="line">list.add(<span class="number">3</span>);</span><br><span class="line">list.remove(<span class="number">2</span>);<span class="comment">//索引</span></span><br><span class="line">list.remove(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">2</span>));<span class="comment">//2这个值</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>小结：</strong> </p>
<p>Collection接口：单列集合，用来存储一个一个的对象 </p>
<p>List接口：<strong>存储有序的、可重复的数据。</strong> –&gt;“<em>动态</em>**”数组,替换原有的数组</p>
<p>ArrayList：作为List接口的主要实现类；线程不安全的，效率高；底层使用Object[ ] elementData存 储 </p>
<p>LinkedList：对于频繁的插入、删除操作，使用此类效率较高；底层使用双向链表存储 </p>
<p>Vector：作为List接口的古老实现类；线程安全的，效率低；底层使用Object[ ] elementData存储 ArrayList list &#x3D; new ArrayList(); 底层在创建对象时就创建了长度是10的Object[ ]数组elementData list.add(123);&#x2F;&#x2F;elementData[0] &#x3D; new Integer(123); … </p>
<p>list.add(11);&#x2F;&#x2F;如果此次的添加导致底层elementData数组容量不够，则扩容。</p>
<p> 默认情况下，扩容为原来的容量的1.5倍，同时需要将原有数组中的数据复制到新的数组中。</p>
<p> <strong>结论</strong>：建议开发中使用带参的构造器：ArrayList list &#x3D; new ArrayList(int capacity) </p>
<p>2.2 jdk 8中ArrayList的变化： </p>
<p>ArrayList list &#x3D; new ArrayList();&#x2F;&#x2F;底层Object[ ] elementData初始化为{}.并没有创建长度为10的数组 源码分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class	access</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 如果是无参构造器时，实际也创建了对象，就是没有长度而已</span></span><br><span class="line"><span class="comment">    * 此时只是private static final Object[]	DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span></span><br><span class="line"><span class="comment">    * 赋值给了Object数组</span></span><br><span class="line"><span class="comment">    * 当在第一次调用add方法添加元素时确定了数组长度</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 当为有参构造器时</span></span><br><span class="line"><span class="comment">    * 参数为想要创建数组的长度</span></span><br><span class="line"><span class="comment">    * 此时将会创建一个数组长度为传进来的长度</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        	<span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        	<span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       	 	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+	initialCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">list.add(<span class="number">123</span>);<span class="comment">//第一次调用add()时，底层才创建了长度10的数组，并将数据123添加到	elementData[0]</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 此时数组在第一次添加元素时，而是通过扩容机制来给数组确定长度，而第一次给数组</span></span><br><span class="line"><span class="comment">    * 扩容的大小为10</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>); <span class="comment">// Increments modCount!!</span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220314205442157.png" alt="image-20220314205442157"></p>
<p>后续的添加和扩容操作与jdk 7 无异。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220315173400374.png" alt="image-20220315173400374"></p>
<p><strong>小结</strong>：jdk7中的ArrayList的对象的创建类似于单例的饿汉式（以上来就创建），而jdk8中的ArrayList的 对象的创建类似于单例的懒汉式，延迟了数组的创建，节省内存。 </p>
<p>LinkedList源码分析 </p>
<p>LinkedList list &#x3D; new LinkedList(); 内部声明了Node类型的first和last属性，默认值为null </p>
<p>list.add(123);&#x2F;&#x2F;将123封装到Node中，创建了Node对象。 </p>
<p>其中，Node定义为：体现了LinkedList的双向链表的说法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">        E item;</span><br><span class="line">        Node&lt;E&gt; next;<span class="comment">//后</span></span><br><span class="line">        Node&lt;E&gt; prev;<span class="comment">//前</span></span><br><span class="line">        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="built_in">this</span>.item = element;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">        <span class="built_in">this</span>.prev = prev;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>Vector的源码分析</em>：jdk7和jdk8中通过Vector()构造器创建对象时，底层都创建了长度为10的数组。 </p>
<p>在扩容方面，默认扩容为原来的数组长度的2倍。 </p>
<p>源码分析：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220314205635875.png" alt="image-20220314205635875"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">list.add(<span class="number">1</span>);</span><br><span class="line">list.add(<span class="number">2</span>);</span><br><span class="line">list.add(<span class="number">3</span>);</span><br><span class="line">list.remove(<span class="number">2</span>);<span class="comment">//2 是索引</span></span><br><span class="line">list.remove(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">2</span>));<span class="comment">//2是值</span></span><br></pre></td></tr></table></figure>

<h2 id="4、Set接口"><a href="#4、Set接口" class="headerlink" title="4、Set接口"></a>4、Set接口</h2><p>Set接口是Collection的子接口，set接口没有提供额外的方法 Set 集合不允许包含相同的元素，如果试把 两个相同的元素加入同一个Set 集合中，则添加操作失败。Set 判断两个对象是否相同不是使用 &#x3D;&#x3D; 运算 符，而是根据 equals() 方法。 </p>
<p><strong>HashSet：</strong>HashSet 是 Set 接口的典型实现，大多数时候使用 Set 集合时都使用这个实现类。HashSet 按 Hash 算法来存储集合中的元素，因此具有很好的存取、查找、删除性能。 </p>
<p><strong>HashSet 具有以下特点：</strong>不能保证元素的排列顺序。HashSet 不是线程安全的。集合元素可以是 null </p>
<p><strong>HashSet 集合判断两个元素相等的标准：</strong>两个对象通过 hashCode() 方法比较相等，并且两个对象的 equals() 方法返回值也相等。 对于存放在Set容器中的对象，对应的类一定要重写equals()和 hashCode(Object obj)方法，以实现对象相等规则。即：“相等的对象必须具有相等的散列码”。 </p>
<p>向HashSet中添加元素的过程：当向 HashSet 集合中存入一个元素时，HashSet 会调用该对象的 hashCode() 方法来得到该对象的 hashCode 值，然后根据 hashCode 值，通过某种散列函数决定该对 象在 HashSet 底层数组中的存储位置。（这个散列函数会与底层数组的长度相计算得到在数组中的下 标，并且这种散列函数计算还尽可能保证能均匀存储元素，越是散列分布，该散列函数设计的越好） </p>
<p>如果两个元素的hashCode()值相等，会再继续调用equals方法，如果equals方法结果为true，添加失 败；如果为false，那么会保存该元素，但是该数组的位置已经有元素了，那么会通过链表的方式继续链 接。 </p>
<p>如果两个元素的 equals() 方法返回 true，但它们的 hashCode() 返回值不相等，hashSet 将会把它们存 储在不同的位置，但依然可以添加成功。 </p>
<p>HashSet底层也是数组，初始容量为16，当如果使用率超过0.75，（16*0.75&#x3D;12）就会扩大容量为原来 的2倍。（16扩容为32，依次为64,128….等）。 </p>
<p>重写equals方法的基本原则： </p>
<p>当一个类有自己特有的“逻辑相等”概念,当改写equals()的时候，总是要改写hashCode()，根据一个类的 equals方法（改写后），两个截然不同的实例有可能在逻辑上是相等的，但是，根据 Object.hashCode()方法，它们仅仅是两个对象。违反了“相等的对象必须具有相等的散列码”。所以 复写 equals方法的时候一般都需要同时复写hashCode方法。通常参与计算hashCode的对象的属性也应该参 与到equals()中进行计算。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer pid;</span><br><span class="line">    <span class="keyword">private</span> String pname;</span><br><span class="line">    <span class="keyword">private</span> String psex;</span><br><span class="line">    <span class="keyword">private</span> Integer page;</span><br><span class="line">    ......</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) o;</span><br><span class="line">        <span class="keyword">if</span> (pid != <span class="literal">null</span> ? !pid.equals(person.pid) : person.pid != <span class="literal">null</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (pname != <span class="literal">null</span> ? !pname.equals(person.pname) : person.pname !=</span><br><span class="line">        <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (psex != <span class="literal">null</span> ? !psex.equals(person.psex) : person.psex != <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> page != <span class="literal">null</span> ? page.equals(person.page) : person.page ==</span><br><span class="line">        <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> pid != <span class="literal">null</span> ? pid.hashCode() : <span class="number">0</span>;</span><br><span class="line">    result = <span class="number">31</span> * result + (pname != <span class="literal">null</span> ? pname.hashCode() : <span class="number">0</span>);</span><br><span class="line">    result = <span class="number">31</span> * result + (psex != <span class="literal">null</span> ? psex.hashCode() : <span class="number">0</span>);</span><br><span class="line">    result = <span class="number">31</span> * result + (page != <span class="literal">null</span> ? page.hashCode() : <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1001</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;f&quot;</span>,<span class="number">23</span>);</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1000</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;m&quot;</span>,<span class="number">24</span>);</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1004</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;f&quot;</span>,<span class="number">18</span>);</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1003</span>,<span class="string">&quot;e&quot;</span>,<span class="string">&quot;m&quot;</span>,<span class="number">27</span>);</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1003</span>,<span class="string">&quot;e&quot;</span>,<span class="string">&quot;m&quot;</span>,<span class="number">27</span>);</span><br><span class="line">    System.out.println(p4);</span><br><span class="line">    System.out.println(p5);</span><br><span class="line">    HashSet&lt;Person&gt; hashSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    hashSet.add(p1);</span><br><span class="line">    hashSet.add(p2);</span><br><span class="line">    hashSet.add(p3);</span><br><span class="line">    hashSet.add(p4);</span><br><span class="line">    p4.setPid(<span class="number">1111</span>);</span><br><span class="line">    System.out.println(p4);</span><br><span class="line">    hashSet.add(p5);</span><br><span class="line">    System.out.println(<span class="string">&quot;------------------&quot;</span>);</span><br><span class="line">    System.out.println(p4);</span><br><span class="line">    System.out.println(p5);</span><br><span class="line">    hashSet.add(p4);</span><br><span class="line">    System.out.println(hashSet.size());<span class="comment">//6</span></span><br><span class="line">    System.out.println(p4.equals(p5));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220314220431423.png" alt="image-20220314220431423"></p>
<p><strong>LinkedHashSet：</strong>LinkedHashSet 是 HashSet 的子类。LinkedHashSet 根据元素的 hashCode 值来决 定元素的存储位置，但它同时使用双向链表维护元素的次序，这使得元素看起来是以插入顺序保存的。 </p>
<p>LinkedHashSet插入性能略低于 HashSet，但在迭代访问 Set 里的全部元素时有很好的性能。 </p>
<p>LinkedHashSet 不允许集合元素重复。 </p>
<p><strong>TreeSet:<strong>TreeSet 是 SortedSet 接口的实现类，TreeSet 可以确保集合元素处于排序状态。TreeSet底层 使用</strong>红黑树</strong>结构存储数据。 </p>
<p>排序：<strong>自然排序</strong>：TreeSet 会调用集合元素的 compareTo(Object obj) 方法来比较元 素之间的大小关系，然后将集合元素按升序(默认情况)排列如果试图把一个对象添加到 TreeSet 时，则 该对象的类必须实现 Comparable 接口。</p>
<p>实现 Comparable 的类必须实现 compareTo(Object obj) 方法，两个对象即通过compareTo(Object obj) 方法的返回值来比较大小。 </p>
<p>Comparable 的典型实现：BigDecimal、BigInteger 以及所有的数值型对应的包装类：按它们对应的数 值大小进行比较。Character：按字符的 unicode值来进行比较。Boolean：true 对应的包装类实例大于 false 对应的包装类实例。String：按字符串中字符的 unicode 值进行比较。Date、Time：后边的时 间、日期比前面的时间、日期大。</p>
<h2 id="5、Map接口"><a href="#5、Map接口" class="headerlink" title="5、Map接口"></a>5、Map接口</h2><p>Map与Collection并列存在。用于保存具有<strong>映射关系</strong>的数据:key-value。Map 中的 key 和 value 都可以 是任何引用类型的数据。Map 中的 key 用Set来存放，<strong>不允许重复</strong>，即同一个 Map 对象所对应的类，须 重写hashCode()和equals()方法。常用String类作为Map的“键”。key 和 value 之间存在单向一对一关 系，即通过指定的 key 总能找到唯一的确定的 value。Map接口的常用实现类：HashMap、TreeMap、 LinkedHashMap和Properties。其中，HashMap是 Map 接口使用频率最高的实现类。 </p>
<p>Map接口常用的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">添加、删除、修改操作：</span><br><span class="line">Object <span class="title function_">put</span><span class="params">(Object key,Object value)</span>：将指定key-value添加到(或修改)当前map对象中<span class="keyword">void</span> <span class="title function_">putAll</span><span class="params">(Map m)</span>:将m中的所有key-value对存放到当前map中</span><br><span class="line">Object <span class="title function_">remove</span><span class="params">(Object key)</span>：移除指定key的key-value对，并返回value</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>：清空当前map中的所有数据</span><br><span class="line">    </span><br><span class="line">元素查询的操作：</span><br><span class="line">Object <span class="title function_">get</span><span class="params">(Object key)</span>：获取指定key对应的value</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(Object key)</span>：是否包含指定的key</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">containsValue</span><span class="params">(Object value)</span>：是否包含指定的value</span><br><span class="line"><span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>：返回map中key-value对的个数</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>：判断当前map是否为空</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>：判断当前map和参数对象obj是否相等</span><br><span class="line">    </span><br><span class="line">元视图操作的方法：</span><br><span class="line">Set <span class="title function_">keySet</span><span class="params">()</span>：返回所有key构成的Set集合</span><br><span class="line">Collection <span class="title function_">values</span><span class="params">()</span>：返回所有value构成的Collection集合</span><br><span class="line">Set <span class="title function_">entrySet</span><span class="params">()</span>：返回所有key-value对构成的Set集合</span><br></pre></td></tr></table></figure>

<p><strong>HashMap:<strong>HashMap是 Map 接口</strong>使用频率最高</strong>的实现类。允许使用null键和null值，与HashSet一样， 不保证映射的顺序。所有的key构成的集合是Set:无序的、不可重复的。所以，key所在的类要重写： equals()和hashCode()所有的value构成的集合是Collection:无序的、可以重复的。所以，value所在的 类要重写：equals()一个key-value构成一个entry。所有的entry构成的集合是Set:无序的、不可重复 的。HashMap <strong>判断两个 key 相等的标准</strong>是：两个 key 通过 equals() 方法返回 true，hashCode 值也相 等。HashMap <strong>判断两个 value</strong>相等的标准是：两个 value 通过 equals() 方法返回 true。 </p>
<p>JDK 7及以前版本：HashMap是数组+链表结构(即为链地址法) </p>
<p>JDK 8版本发布以后：HashMap是数组+链表+红黑树实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HashMap的内部存储结构其实是数组和链表的结合。当实例化一个HashMap时，系统会创建一个长度为Capacity的Entry数组，这个长度在哈希表中被称为容量(Capacity)，在这个数组中可以存放元素的位置我们称之为“桶”(bucket)，每个bucket都有自己的索引，系统可以根据索引快速的查找bucket中的元素。</span><br><span class="line">每个bucket中存储一个元素，即一个Entry对象，但每一个Entry对象可以带一个引用变量，用于指向下一个元素，因此，在一个桶中，就有可能生成一个Entry链。而且新添加的元素作为链表的head。</span><br><span class="line">添加元素的过程：向HashMap中添加entry1(key，value)，需要首先计算entry1中key的哈希值(根据key所在类的hashCode()计算得到)，此哈希值经过处理以后，得到在底层Entry[]数组中要存储的位置i。如果位置i上没有元素，则entry1直接添加成功。如果位置i上已经存在entry2(或还有链表存在的entry3，entry4)，则需要通过循环的方法，依次比较entry1中key和其他的entry。如果彼此hash值不同，则直接添加成功。如果hash值不同，继续比较二者是否equals。如果返回值为<span class="literal">true</span>，则使用entry1的value去替换equals为<span class="literal">true</span>的entry的value。如果遍历一遍以后，发现所有的equals返回都为<span class="literal">false</span>,则entry1仍可添加成功。entry1指向原有的entry元素。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">	JDK1<span class="number">.8</span>之前</span><br><span class="line">	HashMap的扩容</span><br><span class="line">	当HashMap中的元素越来越多的时候，hash冲突的几率也就越来越高，因为数组的长度是固定的。所以为了提高查询的效率，就要对HashMap的数组进行扩容，而在HashMap数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算</span><br><span class="line">	其在新数组中的位置，并放进去，这就是resize。那么HashMap什么时候进行扩容呢？ 当HashMap中的元素个数超过数组大小(数组总大小length,不是数组中个数size)*loadFactor 时 ， 就 会 进行 数 组 扩 容 ， loadFactor 的默认 值(DEFAULT_LOAD_FACTOR)为<span class="number">0.75</span>，这是一个折中的取值。也就是说，默认情况下，数组大(DEFAULT_INITIAL_CAPACITY)为<span class="number">16</span>，那么当HashMap中元素个数</span><br><span class="line">	超过<span class="number">16</span>*<span class="number">0.75</span>=<span class="number">12</span>（这个值就是代码中的threshold值，也叫做临界值）的时候，就把数组的大小扩展为 <span class="number">2</span>*<span class="number">16</span>=<span class="number">32</span>，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知HashMap中元素的个数，那么预设元素的个数能够有效的提高HashMap的性能。</span><br><span class="line">	JDK1<span class="number">.8</span>之后</span><br><span class="line">	HashMap的内部存储结构其实是数组+链表+树的结合。当实例化一个HashMap时，会初始化</span><br><span class="line">initialCapacity和loadFactor，在put第一对映射关系时，系统会创建一个长度为initialCapacity的Node数组，这个长度在哈希表中被称为容量(Capacity)，在这个数组中可以存放元素的位置我们称之为“桶”(bucket)，每个bucket都有自己的索引，系统可以根据索引快速的查找bucket中的元素。每个bucket中存储一个元素，即一个Node对象，但每一个Node对象可以带一个引用变量next，用于指向下一个元素，因此，在一个桶中，就有可能生成一个Node链。也可能是一个一个TreeNode对象，每一个TreeNode对象可以有两个叶子结点left和right，因此，在一个桶中，就有可能生成一个TreeNode树。而新添加的元素作为链表的last，或树的叶子结点。</span><br><span class="line">	那么HashMap什么时候进行扩容和树形化呢?</span><br><span class="line">	当HashMap中的元素个数超过数组大小(数组总大小length,不是数组中个size)*loadFactor 时， 就会进行数组扩容 ，loadFactor 的默认 值 (DEFAULT_LOAD_FACTOR)为<span class="number">0.75</span>，这是一个折中的取值。也就是说，默认情况下，数组大小(DEFAULT_INITIAL_CAPACITY)为<span class="number">16</span>，那么当HashMap中元素个数超过<span class="number">16</span>*<span class="number">0.75</span>=<span class="number">12</span>（这个值就是代码中的threshold值，也叫做临界值）的时候，就把数组的大小扩展为 <span class="number">2</span>*<span class="number">16</span>=<span class="number">32</span>，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知HashMap中元素的个数，那么预设元素的个数能够有效的提高HashMap的性能。 当HashMap中的其中一个链的对象个数如果达到了<span class="number">8</span>个，此时如果capacity没有达到<span class="number">64</span>，那么HashMap会先扩容解决，如果已经达到了<span class="number">64</span>，那么这个链会变成树，结点类型由Node变成TreeNode类型。当然，如果当映射关系被移除后，下次resize方法时判断树的结点个数低于<span class="number">6</span>个，也会把树再转为链表。</span><br><span class="line">        </span><br><span class="line">总结：JDK1<span class="number">.8</span>相较于之前的变化：</span><br><span class="line"><span class="number">1.</span><span class="type">HashMap</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();<span class="comment">//默认情况下，先不创建长度为16的数组</span></span><br><span class="line"><span class="number">2.</span>当首次调用map.put()时，再创建长度为<span class="number">16</span>的数组</span><br><span class="line"><span class="number">3.</span>数组为Node类型，在jdk7中称为Entry类型</span><br><span class="line"><span class="number">4.</span>形成链表结构时，新添加的key-value对在链表的尾部（七上八下）</span><br><span class="line"><span class="number">5.</span>当数组指定索引位置的链表长度&gt;<span class="number">8</span>时，且map中的数组的长度&gt; <span class="number">64</span>时，此索引位置上的所有keyvalue对使用红黑树进行存储</span><br></pre></td></tr></table></figure>

<p><strong>LinkedHashMap：</strong>LinkedHashMap 是 HashMap 的子类在HashMap存储结构的基础上，使用了一对 双向链表来记录添加元素的顺序与LinkedHashSet类似，LinkedHashMap 可以维护 Map 的迭代顺序： 迭代顺序与 Key-Value 对的插入顺序一致。 </p>
<p><strong>TreeMap:</strong> TreeMap存储 Key-Value 对时，需要根据 key-value 对进行排序。TreeMap 可以保证所有的 Key-Value 对处于<strong>有序</strong>状态。TreeSet底层使用<strong>红黑树</strong>结构存储数据。TreeMap 的 Key 的排序：<strong>自然排 序</strong>：TreeMap 的所有的 Key 必须实现 Comparable 接口，而且所有的 Key 应该是同一个类的对象，否 则将会抛出ClasssCastException。<strong>定制排序</strong>：创建 TreeMap 时，传入一个 Comparator 对象，该对象 负责对TreeMap 中的所有 key 进行排序。此时不需要 Map 的 Key 实现Comparable 接口TreeMap判断 两个<strong>key相等的标准</strong>：两个key通过compareTo()方法或者compare()方法返回0。 </p>
<p>**Hashtable:**Hashtable是个古老的 Map 实现类，JDK1.0就提供了。不同于HashMap，Hashtable是线 程安全的。Hashtable实现原理和HashMap相同，功能相同。底层都使用哈希表结构，查询速度快，很 多情况下可以互用。 与HashMap不同，Hashtable 不允许使用 null 作为 key 和 value。与HashMap一 样，Hashtable 也不能保证其中 Key-Value 对的顺序。Hashtable判断两个key相等、两个value相等的 标准，与HashMap一致。 **Properties:**Properties 类是 Hashtable 的子类，该对象用于处理属性文件由于属性文件里的 key、 value 都是字符串类型，所以 Properties 里的 key 和 value 都是字符串类型存取数据时，建议使用 setProperty(String key,String value)方法和getProperty(String key)方法 </p>
<p>总结：Map集合 </p>
<p>一、Map的实现类的结构： </p>
<p>Map:双列数据，存储key-value对的数据 。 </p>
<p>HashMap:作为Map的主要实现类；线程不安全的，效率高；存储null的key和value </p>
<p>LinkedHashMap:保证在遍历map元素时，可以按照添加的顺序实现遍历。 </p>
<p>原因：在原有的HashMap底层结构基础上，添加了一对指针，指向前一个和后一个元素。对于频繁 的遍历操作，此类执行效率高于HashMap。 </p>
<p>源码分析</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220314220552497.png" alt="image-20220314220552497"></p>
<p>该构造方法中，并没有立即创建Entry数组。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220314220613212.png" alt="image-20220314220613212"></p>
<p>调用put方法</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220314221430005.png" alt="image-20220314221430005"></p>
<p>Properties:Properties 类是 Hashtable 的子类，该对象用于处理属性文件由于属性文件里的 key、 value 都是字符串类型，所以 Properties 里的 key 和 value 都是字符串类型存取数据时，建议使用 setProperty(String key,String value)方法和getProperty(String key)方法。 </p>
<p>TreeMap:保证按照添加的key-value对进行排序，实现排序遍历。此时考虑key的自然排序或定制 排序。底层使用红黑树。 </p>
<p>代码实现排序：<strong>Comparator接口</strong>和<strong>Comparable接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 默认的从小到大</span></span><br><span class="line"><span class="comment">    * 如果想进行从大到小则this.name.compareTo(user.name)</span></span><br><span class="line"><span class="comment">    * 前加一个负号</span></span><br><span class="line"><span class="comment">    * compareTo比较并不是equals</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * Comparator接口下的方法是：（定制排序）</span></span><br><span class="line"><span class="comment">    * 		int compare(T o1, T o2);</span></span><br><span class="line"><span class="comment">    * Comparable接口下的方法是：（treeSet中默认的排序所实现的接口，也是自然排序）</span></span><br><span class="line"><span class="comment">    * 		int compareTo(Object o)</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * 共性：</span></span><br><span class="line"><span class="comment">    * 		Integer.compare(user1.age, user2.age);这种方式适合比较数字</span></span><br><span class="line"><span class="comment">    * 此方法是Comparator接口下的方法</span></span><br><span class="line"><span class="comment">    * 		user1.compareTo(user2.name);这种适合比较字符</span></span><br><span class="line"><span class="comment">    * 此方法是Comparable接口下的方法</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">compare</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Comparator&lt;Object&gt; comparator = <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Object&gt;() &#123;</span><br><span class="line">            <span class="comment">//匿名实现</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">        		<span class="keyword">if</span>(o1 <span class="keyword">instanceof</span> User &amp;&amp; o2 <span class="keyword">instanceof</span> User) &#123;</span><br><span class="line">                    <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> (User)o1;</span><br><span class="line">                    <span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> (User)o1;</span><br><span class="line">                    <span class="comment">// return Integer.compare(user1.age, user2.age);</span></span><br><span class="line">                    <span class="keyword">return</span> user1.compareTo(user2.name);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span>(o <span class="keyword">instanceof</span> User) &#123;</span><br><span class="line">            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User)o;</span><br><span class="line">            compare = -<span class="built_in">this</span>.name.compareTo(user.name);</span><br><span class="line">            <span class="keyword">if</span>(compare == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// return this.age.compareTo(user.age);</span></span><br><span class="line">                <span class="comment">//compare方法是Integer包装类自己定义的，并非Comparable接口下的方法</span></span><br><span class="line">                <span class="keyword">return</span> Integer.compare(<span class="built_in">this</span>.age, user.age);</span><br><span class="line">          	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> compare;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="6-、Collections工具类"><a href="#6-、Collections工具类" class="headerlink" title="6.、Collections工具类"></a>6.、Collections工具类</h2><p>Collections 是一个操作 Set、List 和 Map 等集合的工具类 </p>
<p>Collections 中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作， </p>
<p>还提供了对集合对象设置不可变、对集合对象实现同步控制等方法 </p>
<p>排序操作：（均为<strong>static方法）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">reverse(List)：反转 List 中元素的顺序</span><br><span class="line">shuffle(List)：对 List 集合元素进行随机排序</span><br><span class="line">sort(List)：根据元素的自然顺序对指定 List 集合元素按升序排序</span><br><span class="line">sort(List，Comparator)：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序</span><br><span class="line">swap(List，<span class="type">int</span>， <span class="type">int</span>)：将指定 list 集合中的 i 处元素和 j 处元素进行交换</span><br></pre></td></tr></table></figure>

<p><strong>常用方法：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Object <span class="title function_">max</span><span class="params">(Collection)</span>：根据元素的自然顺序，返回给定集合中的最大元素</span><br><span class="line">Object <span class="title function_">max</span><span class="params">(Collection，Comparator)</span>：根据 Comparator 指定的顺序，返回</span><br><span class="line">给定集合中的最大元素</span><br><span class="line">Object <span class="title function_">min</span><span class="params">(Collection)</span></span><br><span class="line">Object <span class="title function_">min</span><span class="params">(Collection，Comparator)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">frequency</span><span class="params">(Collection，Object)</span>：返回指定集合中指定元素的出现次数</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">copy</span><span class="params">(List dest,List src)</span>：将src中的内容复制到dest中 <span class="type">boolean</span></span><br><span class="line"><span class="title function_">replaceAll</span><span class="params">(List list，Object oldVal，Object newVal)</span>：使用新值替换</span><br><span class="line">List 对象的所有旧值</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    ......</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) o;</span><br><span class="line">        <span class="keyword">if</span> (!id.equals(person.id)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> name.equals(person.name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> id.hashCode();</span><br><span class="line">        result = <span class="number">31</span> * result + name.hashCode();</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123; </span><br><span class="line">        <span class="type">HashSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>(); </span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1001</span>,<span class="string">&quot;AA&quot;</span>); </span><br><span class="line">        <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1002</span>,<span class="string">&quot;BB&quot;</span>); </span><br><span class="line">        set.add(p1); </span><br><span class="line">        set.add(p2); </span><br><span class="line">        System.out.println(set); </span><br><span class="line">        p1.setName(<span class="string">&quot;CC&quot;</span>); set.remove(p1); </span><br><span class="line">        System.out.println(set); </span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1001</span>,<span class="string">&quot;CC&quot;</span>)); </span><br><span class="line">        System.out.println(set); </span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1001</span>,<span class="string">&quot;AA&quot;</span>)); </span><br><span class="line">        System.out.println(set); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="练习-1"><a href="#练习-1" class="headerlink" title="练习:"></a>练习:</h2><p>1、集合Collection中存储的如果是自定义类的对象，需要自定义类重写哪个方法？为什么？ </p>
<p>2、ArrayList,LinkedList,Vector三者的相同点和不同点 </p>
<p>3、List接口的常用方法有哪些 </p>
<p>4、Set存储数据的特点是什么？有哪些实现类，简述各实现类的特点 </p>
<p>5、如何去除list中重复的数据 </p>
<p>6、创建一个List集合的对象，添加几个数字，反转对象中元素的顺序；根据元素的自然顺序排序 </p>
<p>7、一组数列A[25,36,17,23,14] ,一组数列B[10,8,25,36,14,72] 将两个数列合并，重复只出现一次， 并按照从小到打输出 </p>
<p>8、随机生成五组双色球彩票，双色球规则，是这样的 红号是1-33 取六个不重复的，蓝号是1-16 取一个。 </p>
<p>9、课堂演示是学生管理系统，分别采用三个集合实现 </p>
<p>10、发的业务图片尝试实现[]</p>
<h1 id="十六、泛型"><a href="#十六、泛型" class="headerlink" title="十六、泛型"></a>十六、泛型</h1><p> 集合容器类在设计阶段&#x2F;声明阶段不能确定这个容器到底实际存的是什么类型的对象，所以在JDK1.5之前 只能把元素类型设计为Object，JDK1.5之后使用泛型来解决。因为这个时候除了元素的类型不确定，其 他的部分是确定的，例如关于这个元素如何保存，如何管理等是确定的，因此此时把元素的类型设计成 一个参数，这个类型参数叫做泛型。Collection，List，ArrayList 这个就是类型参数，即泛型。</p>
<p>所谓泛型，就是允许在定义类、接口时通过一个标识表示类中某个属性的类型或者是某个方法的返回值 及参数类型。这个类型参数将在使用时（例如，继承或实现这个接口，用这个类型声明变量、创建对象 时）确定（即传入实际的类型参数，也称为类型实参）。</p>
<p> 从JDK1.5以后，Java引入了“参数化类型（Parameterized type）”的概念，允许我们在创建集合时再指 定集合元素的类型，正如：List，这表明该List只能保存字符串类型的对象。 JDK1.5改写了集合框架中的 全部接口和类，为这些接口、类增加了泛型支持，从而可以在声明集合变量、创建集合对象时传入类型 实参。 </p>
<p><strong>为什么要有泛型？</strong> </p>
<p>解决元素存储的安全性问题，解决获取数据元素时，需要类型强制转换的问题。 </p>
<p>只有指定类型才可以添加到集合中：<strong>类型安全</strong> 读取出来的对象不需要强转：<strong>便捷</strong>。</p>
<p>Java泛型可以保证如果程序在编译时没有发出警告，运行时就不会产生ClassCastException异常。同 时，代码更加简洁、健壮。 </p>
<p>1、集合中使用泛型 </p>
<p>2、自定义泛型： </p>
<p>泛型类：泛型类型用于类的定义中，被称为泛型类。通过泛型可以完成对一组类的操作对外开放相同的 接口。最典型的就是各种容器类，如：List、Set、Map。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//泛型类的最基本写法（这么看可能会有点晕，会在下面的例子中详解）：</span></span><br><span class="line">class 类名称 &lt;泛型标识：可以随便写任意标识号，标识指定的泛型的类型&gt;&#123;</span><br><span class="line">	<span class="keyword">private</span> 泛型标识 <span class="comment">/*（成员变量类型）*/</span> <span class="keyword">var</span>; .....</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span></span><br><span class="line"><span class="comment">//在实例化泛型类时，必须指定T的具体类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Generic</span>&lt;T&gt;&#123;</span><br><span class="line">	<span class="comment">//key这个成员变量的类型为T,T的类型由外部指定</span></span><br><span class="line">	<span class="keyword">private</span> T key;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Generic</span><span class="params">(T key)</span> &#123; <span class="comment">//泛型构造方法形参key的类型也为T，T的类型由外部指定</span></span><br><span class="line">		<span class="built_in">this</span>.key = key;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> T <span class="title function_">getKey</span><span class="params">()</span>&#123; <span class="comment">//泛型方法getKey的返回值类型为T，T的类型由外部指定 return key;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//泛型的类型参数只能是类类型（包括自定义类），不能是简单类型</span></span><br><span class="line"><span class="comment">//传入的实参类型需与泛型的类型参数类型相同，即为Integer.</span></span><br><span class="line">Generic&lt;Integer&gt; genericInteger = <span class="keyword">new</span> <span class="title class_">Generic</span>&lt;Integer&gt;(<span class="number">123456</span>); <span class="comment">//传入的实参类型需与泛型的类型参数类型相同，即为String.</span></span><br><span class="line">Generic&lt;String&gt; genericString = <span class="keyword">new</span> <span class="title class_">Generic</span>&lt;String&gt;(<span class="string">&quot;key_vlaue&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>泛型接口：泛型接口与泛型类的定义及使用基本相同。泛型接口常被用在各种类的生产器中，可以看一 个例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个泛型接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Generator</span>&lt;T&gt; &#123;</span><br><span class="line">	<span class="keyword">public</span> T <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*** 未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中</span></span><br><span class="line"><span class="comment">即：class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;&#123; &#125;</span></span><br><span class="line"><span class="comment">如果不声明泛型，如：</span></span><br><span class="line"><span class="comment">class FruitGenerator implements Generator&lt;T&gt;，编译器会报错：&quot;Unknown class&quot;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FruitGenerator</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Generator</span>&lt;T&gt;&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> T <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*** 传入泛型实参时：</span></span><br><span class="line"><span class="comment">定义一个生产器实现这个接口,虽然我们只创建了一个泛型接口Generator&lt;T&gt;</span></span><br><span class="line"><span class="comment">但是我们可以为T传入无数个实参，形成无数种类型的Generator接口。</span></span><br><span class="line"><span class="comment">在实现类实现泛型接口时，如已将泛型类型传入实参类型，则所有使用泛型的地方都要替换成传入的实</span></span><br><span class="line"><span class="comment">参类型</span></span><br><span class="line"><span class="comment">即：Generator&lt;T&gt;，public T next();中的的T都要替换成传入的String类型。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FruitGenerator</span> <span class="keyword">implements</span> <span class="title class_">Generator</span>&lt;String&gt; &#123;</span><br><span class="line">	<span class="keyword">private</span> String[] fruits = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Pear&quot;</span>&#125;;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">		<span class="keyword">return</span> fruits[rand.nextInt(<span class="number">3</span>)];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>泛型方法：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220319095317417.png" alt="image-20220319095317417"></p>
<h1 id="十七、文件与IO"><a href="#十七、文件与IO" class="headerlink" title="十七、文件与IO"></a>十七、文件与IO</h1><h2 id="1、File类的使用"><a href="#1、File类的使用" class="headerlink" title="1、File类的使用"></a>1、File类的使用</h2><p>java.io.File类：文件和文件目录路径的抽象表示形式，与平台无关。 </p>
<p>File 能新建、删除、重命名文件和目录，但 File 不能访问文件内容本身。如果需要访问文件内容本身， 则需要使用输入&#x2F;输出流。 </p>
<p>想要在Java程序中表示一个真实存在的文件或目录，那么必须有一个File对 象，但是Java程序中的一个 File对象，可能没有一个真实存在的文件或目录。 </p>
<p><strong>构造方法：</strong></p>
<p><strong>public File(String pathname)</strong> 以pathname为路径创建File对象，可以是<strong>绝对路径或者相对路径</strong>，如 果pathname是相对路径，则默认的当前路径在系统属性user.dir中存储。 绝对路径：是一个固定的路 径,从盘符开始相对路径：是相对于某个位置开始 </p>
<p>**public File(String parent,String child)**以parent为父路径，child为子路径创建File对象。 </p>
<p>**public File(File parent,String child)**根据一个父File对象和子文件路径创建File对象。 </p>
<p><strong>常用方法：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">File类的获取功能</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getAbsolutePath</span><span class="params">()</span>：获取绝对路径</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getPath</span><span class="params">()</span> ：获取路径</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> ：获取名称</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getParent</span><span class="params">()</span>：获取上层文件目录路径。若无，返回<span class="literal">null</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">length</span><span class="params">()</span> ：获取文件长度（即：字节数）。不能获取目录的长度。</span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">lastModified</span><span class="params">()</span> ：获取最后一次的修改时间，毫秒值</span><br><span class="line"><span class="keyword">public</span> String[] list() ：获取指定目录下的所有文件或者文件目录的名称数组</span><br><span class="line"><span class="keyword">public</span> File[] listFiles() ：获取指定目录下的所有文件或者文件目录的File数组</span><br><span class="line">File类的重命名功能</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">renameTo</span><span class="params">(File dest)</span>:把文件重命名为指定的文件路径</span><br><span class="line">File类的判断功能</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isDirectory</span><span class="params">()</span>：判断是否是文件目录</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFile</span><span class="params">()</span> ：判断是否是文件</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">exists</span><span class="params">()</span> ：判断是否存在</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canRead</span><span class="params">()</span> ：判断是否可读</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canWrite</span><span class="params">()</span> ：判断是否可写</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHidden</span><span class="params">()</span> ：判断是否隐藏</span><br></pre></td></tr></table></figure>

<p>**listFiles():**方法介绍文件都存放在目录（文件夹）中，那么如何获取一个目录中的所有文件或者目录中 的文件夹呢？那么我们先想想，一个目录中可能有多个文件或者文件夹，那么如果File中有功能获取到一 个目录中的所有文件和文件夹，那么功能得到的结果要么是数组，要么是集合。 </p>
<p>**文件过滤器:**通过上述方法，我们可以获取到一个目录下的所有文件和文件夹，但能不能对其进行过滤 呢？比如我们只想要一个目录下的指定扩展名的文件，或者包含某些关键字的文件夹呢？我们是可以先 把一个目录下的所有文件和文件夹获取到，并遍历当前获取到所有内容，遍历过程中在进行筛选，但是 这个动作有点麻烦，Java给我们提供相应的功能来解决这个问题。查阅File类的API，在查阅时发现File类 中重载的listFiles方法，并且接受指定的过滤器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileDemo2</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//获取扩展名为.java所有文件</span></span><br><span class="line">		<span class="comment">//创建File对象</span></span><br><span class="line">		<span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\JavaSE1115\\code\\day11_code&quot;</span>);</span><br><span class="line">		<span class="comment">//获取指定扩展名的文件,由于要对所有文件进行扩展名筛选，因此调用方法需要传递过滤器</span></span><br><span class="line">		File[] files = file.listFiles(<span class="keyword">new</span> <span class="title class_">FileFilterBySuffix</span>()); <span class="comment">//遍历获取到的所有符合条件的文件</span></span><br><span class="line">		<span class="keyword">for</span> (File f : files) &#123;</span><br><span class="line">			System.out.println(f);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义类实现文件名称FilenameFilter过滤器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileFilterBySuffix</span> <span class="keyword">implements</span> <span class="title class_">FilenameFilter</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">accept</span><span class="params">(File dir, String name)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> name.endsWith(<span class="string">&quot;.java&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileFilterBySuffix</span> <span class="keyword">implements</span> <span class="title class_">FileFilter</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String suffix;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">FileFilterBySuffix</span><span class="params">(String suffix)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">		<span class="built_in">this</span>.suffix = suffix;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">accept</span><span class="params">(File pathname)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> pathname.getName().endsWith(suffix);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2、IO流"><a href="#2、IO流" class="headerlink" title="2、IO流"></a>2、IO流</h2><p>I&#x2F;O是Input&#x2F;Output的缩写， I&#x2F;O技术是非常实用的技术，用于处理设备之间的数据传输。如读&#x2F;写文 件，网络通讯等。 </p>
<p>Java程序中，对于数据的输入&#x2F;输出操作以“流(stream)”的方式进行。</p>
<p>IO原理：输入input:读取外部数据到程序(内存)中 </p>
<p>​				输出output:将程序(内存)数据输出到磁盘、光盘等存储社保中。 </p>
<p>流的分类：按照数据单位来分：字节流，字符流 </p>
<p>​					按照流向来分：输入流，输出流。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220220202806515.png" alt="image-20220220202806515"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220220202815280.png" alt="image-20220220202815280"></p>
<p>流的体系：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220220202827677.png" alt="image-20220220202827677"></p>
<h2 id="3、InputStream和Reader"><a href="#3、InputStream和Reader" class="headerlink" title="3、InputStream和Reader"></a>3、InputStream和Reader</h2><p>InputStream和Reader是所有输入流的基类 </p>
<p>InputStream典型实现是FileInputStream。常用方法read()方法【int read()； int read(byte[] b) ；int read(byte[] b, int off, int len) 】 </p>
<p>Reader典型实现是FileReader。常用方法read()方法【int read()； int read(byte[] b) ；int read(byte[] b, int off, int len) 】 </p>
<p>程序中打开的文件 IO 资源不属于内存里的资源，垃圾回收机制无法回收该资源，所以应该<strong>显式关闭文件 IO 资源。</strong> </p>
<p>FileInputStream 从文件系统中的某个文件中获得输入字节。FileInputStream 用于读取非文本数据之类 的原始字节流。要读取字符流，需要使用 FileReader。 </p>
<h3 id="InputStream方法介绍："><a href="#InputStream方法介绍：" class="headerlink" title="InputStream方法介绍："></a><strong>InputStream方法介绍：</strong></h3><p><strong>int read()：</strong>从输入流中读取数据的下一个字节。返回 0 到 255 范围内的 int 字节值。如果因为已经到 达流末尾而没有可用的字节，则返回值 -1。</p>
<p><strong>int read(byte[] b)：</strong>从此输入流中将最多 b.length 个字节的数据读入一个 byte 数组中。如果因为已经 到达流末尾而没有可用的字节，则返回值 -1。否则以整数形式返回实际读取的字节数。 </p>
<p><strong>int read(byte[] b, int off,int len)：</strong>将输入流中最多 len 个数据字节读入 byte 数组。尝试读取 len 个 字节，但读取的字节也可能小于该值。以整数形式返回实际读取的字节数。如果因为流位于文件末尾而 没有可用的字节，则返回值 -1。 </p>
<p><strong>public void close() throws IOException</strong>关闭此输入流并释放与该流关联的所有系统资源。 </p>
<h3 id="Reader方法介绍："><a href="#Reader方法介绍：" class="headerlink" title="Reader方法介绍："></a>Reader方法介绍：</h3><p>**int read()**读取单个字符。作为整数读取的字符，范围在 0 到 65535 之间 (0x00-0xffff)（2个字节的 Unicode码），如果已到达流的末尾，则返回 -1 </p>
<p>**int read(char[] cbuf)**将字符读入数组。如果已到达流的末尾，则返回 -1。否则返回本次读取的字符 数。</p>
<p>**int read(char[] cbuf,int off,int len)**将字符读入数组的某一部分。存到数组cbuf中，从off处开始存 储，最多读len个字符。如果已到达流的末尾，则返回 -1。否则返回本次读取的字符数。 </p>
<p><strong>public void close() throws IOException</strong>关闭此输入流并释放与该流关联的所有系统资源。 </p>
<h2 id="4、OutputStream和Writer"><a href="#4、OutputStream和Writer" class="headerlink" title="4、OutputStream和Writer"></a>4、OutputStream和Writer</h2><p> OutputStream 和 Writer 也非常相似： </p>
<p>void write(int b&#x2F;int c); </p>
<p>void write(byte[] b&#x2F;char[] cbuf); </p>
<p>void write(byte[] b&#x2F;char[] buff, int off, int len); </p>
<p>void flush(); </p>
<p>void close(); 需要先刷新，再关闭此流。 </p>
<p>因为字符流直接以字符作为操作单位，所以 Writer 可以用字符串来替换字符数组，即以 String 对象作 为参数</p>
<p> <strong>void write(String str);</strong> </p>
<p><strong>void write(String str, int off, int len);</strong> </p>
<p>FileOutputStream 从文件系统中的某个文件中获得输出字节。FileOutputStream 用于写出非文本数据 之类的原始字节流。要写出字符流，需要使用 FileWriter。 </p>
<h3 id="练习：-18"><a href="#练习：-18" class="headerlink" title="练习："></a>练习：</h3><p>将学生对象(姓名，语文分数，数学分数，英语分数，总分)按照总分从高到低排序，并将姓名和从 高到低总分写入文件中。 </p>
<h2 id="5、缓冲流"><a href="#5、缓冲流" class="headerlink" title="5、缓冲流"></a>5、缓冲流</h2><p>为了提高数据读写的速度，Java API提供了带缓冲功能的流类，在使用这些流类时，会创建一个内部缓 冲区数组，缺省使用8192个字节(8Kb)的缓冲区。 </p>
<p>缓冲流要“套接”在相应的节点流之上，根据数据操作单位可以把缓冲流分为：</p>
<p> <strong>BufferedInputStream 和 BufferedOutputStream</strong> </p>
<p><strong>BufferedReader 和 BufferedWriter</strong> </p>
<p>当读取数据时，数据按块读入缓冲区，其后的读操作则直接访问缓冲区 </p>
<p>当使用BufferedInputStream读取字节文件时，BufferedInputStream会一次性从文件中读取8192个 (8Kb)，存在缓冲区中，直到缓冲区装满了，才重新从文件中读取下一个8192个字节数组。 </p>
<p>向流中写入字节时，不会直接写到文件，先写到缓冲区中直到缓冲区写满，BufferedOutputStream才 会把缓冲区中的数据一次性写到文件里。使用方法flush()可以强制将缓冲区的内容全部写入输出流 </p>
<p>关闭流的顺序和打开流的顺序相反。只要关闭最外层流即可，关闭最外层流也会相应关闭内层节点流 </p>
<p>flush()方法的使用：手动将buffer中内容写入文件</p>
<p>如果是带缓冲区的流对象的close()方法，不但会关闭流，还会在关闭流之前刷新缓冲区，关闭后不能再 写出</p>
<h2 id="6、转换流"><a href="#6、转换流" class="headerlink" title="6、转换流"></a>6、转换流</h2><p>转换流提供了在字节流和字符流之间的转换。 </p>
<p>Java API提供了两个转换流： </p>
<p><strong>InputStreamReader</strong>：将InputStream转换为Reader </p>
<p><strong>OutputStreamWriter</strong>：将Writer转换为OutputStream </p>
<p>字节流中的数据都是字符时，转成字符流操作更高效。 </p>
<p>很多时候我们使用转换流来处理文件乱码问题。实现编码和解码的功能</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:\\test\\cn8.txt&quot;</span>);</span><br><span class="line"><span class="comment">//创建转换流对象</span></span><br><span class="line"><span class="comment">//InputStreamReader isr = new InputStreamReader(in);这样创建对象，会用本地默认码</span></span><br><span class="line">表 读取，将会发生错误解码的错误</span><br><span class="line"><span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(in,<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"><span class="comment">//使用转换流去读字节流中的字节</span></span><br><span class="line"><span class="type">int</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((ch = isr.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">	System.out.println((<span class="type">char</span>)ch);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关闭流</span></span><br><span class="line">isr.close();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建与文件关联的字节输出流对象</span></span><br><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;D:\\test\\cn8.txt&quot;</span>);</span><br><span class="line"><span class="comment">//创建可以把字符转成字节的转换流对象，并指定编码</span></span><br><span class="line"><span class="type">OutputStreamWriter</span> <span class="variable">osw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(fos,<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"><span class="comment">//调用转换流，把文字写出去，其实是写到转换流的缓冲区中</span></span><br><span class="line">osw.write(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line"><span class="comment">//写入缓冲区。</span></span><br><span class="line">osw.close();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>字符编码：<strong>常见的编码表</strong> </p>
<p>ASCII：美国标准信息交换码。用一个字节的7位可以表示。 </p>
<p>ISO8859-1：拉丁码表。欧洲码表用一个字节的8位表示。 </p>
<p>GB2312：中国的中文编码表。最多两个字节编码所有字符 </p>
<p>GBK：中国的中文编码表升级，融合了更多的中文文字符号。最多两个字节编码 </p>
<p>Unicode：国际标准码，融合了目前人类使用的所有字符。为每个字符分配唯一的字符码。所有的文字 都用两个字节来表示。 </p>
<p>UTF-8：变长的编码方式，可用1-4个字节来表示一个字符 </p>
<h2 id="7、标准输入、输出流"><a href="#7、标准输入、输出流" class="headerlink" title="7、标准输入、输出流"></a>7、标准输入、输出流</h2><p>System.in和System.out分别代表了系统标准的输入和输出设备 </p>
<p>默认输入设备是：键盘，输出设备是：显示器 </p>
<p>System.in的类型是InputStream </p>
<p>System.out的类型是PrintStream，其是OutputStream的子类</p>
<p>FilterOutputStream 的子类 </p>
<p>重定向：通过System类的setIn，setOut方法对默认设备进行改变。 </p>
<p>public static void <strong>setIn</strong>(InputStream in) </p>
<p>public static void <strong>setOut</strong>(PrintStream out)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">	<span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">while</span>((s=br.readLine())!=<span class="literal">null</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="string">&quot;e&quot;</span>.equalsIgnoreCase(s)||<span class="string">&quot;exit&quot;</span>.equalsIgnoreCase(s))&#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;安全退出&quot;</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">&quot;---&gt;&quot;</span>+s.toUpperCase());</span><br><span class="line">			System.out.println(<span class="string">&quot;继续输入信息&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">if</span>(br!=<span class="literal">null</span>)&#123;</span><br><span class="line">				br.close();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="type">FileOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span></span><br><span class="line"><span class="title class_">File</span>(<span class="string">&quot;D:/out.txt&quot;</span>));</span><br><span class="line">		ps = <span class="keyword">new</span> <span class="title class_">PrintStream</span>(out,<span class="literal">true</span>);</span><br><span class="line">		<span class="keyword">if</span>(ps!=<span class="literal">null</span>)&#123;</span><br><span class="line">			System.setOut(ps);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">65</span>;i&lt;=<span class="number">91</span>;i++)&#123;</span><br><span class="line">			System.out.print((<span class="type">char</span>)i);</span><br><span class="line">			<span class="keyword">if</span>(i%<span class="number">50</span>==<span class="number">0</span>)&#123;</span><br><span class="line">				System.out.println();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(ps!=<span class="literal">null</span>)&#123;</span><br><span class="line">			ps.close();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="8、对象流"><a href="#8、对象流" class="headerlink" title="8、对象流"></a>8、对象流</h2><p>ObjectInputStream和OjbectOutputSteam:用于存储和读取基本数据类型数据或对象的处理流。它的强 大之处就是可以把Java中的对象写入到数据源中，也能把对象从数据源中还原回来。 </p>
<p><strong>序列化：</strong>用ObjectOutputStream类<strong>保存</strong>基本类型数据或对象的机制。 </p>
<p><strong>反序列化：</strong>用ObjectInputStream类<strong>读取</strong>基本类型数据或对象的机制。 </p>
<p><strong>对象的序列化：</strong>对象序列化机制允许把内存中的Java对象转换成平台无关的二进制流，从而允许把这种 二进制流持久地保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点。&#x2F;&#x2F;当其它程序获取 了这种二进制流，就可以恢复成原来的Java对象。序列化的好处在于可将任何实现了Serializable接口的 对象转换为字节数据，使其在保存和传输时可被还原。序列化是RMI(Remote Method Invoke-远程方法 调用)过程的参数和返回值都必须实现的机制。而RMI是javaEE的基础，因此序列化机制是JavaEE平台的 基础。如果需要让某个对象支持序列化机制，则必须让对象所属的类及其属性是可序列化的，为了让某 个类是可序列化的，该类必须实现如下两个接口之一，否则会抛出NotSerializableException。通常实现 <strong>Serializable</strong> </p>
<p>凡是实现Serializable接口的类都有一个表示序列化版本标识符的静态变量： </p>
<p><strong>private static final long serialVersionUID;</strong></p>
<p>serialVersionUID用来表明类的不同版本间的兼容性。简言之，其目的是以序列化对象进行版本控制， 有关各版本反序列化时是否兼容。 </p>
<p>如果类没有显示定义这个静态常量，它的值是Java运行时环境根据类的内部细节自动生成的。若类的实 例变量做了修改，serialVersionUID 可能发生变化。故建议，显式声明。 </p>
<p>简单来说，Java的序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的。在进行 反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体类的serialVersionUID进行比 较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常。 (InvalidCastException)。 </p>
<p>若某个类实现了 Serializable 接口，该类的对象就是可序列化的： </p>
<p>创建一个 ObjectOutputStream </p>
<p>调用 ObjectOutputStream 对象的 writeObject(对象) 方法输出可序列化对象 </p>
<p>注意写出一次，操作flush()一次。 </p>
<p>反序列化 </p>
<p>创建一个 ObjectInputStream </p>
<p>调用 readObject() 方法读取流中的对象 </p>
<p>强调：如果某个类的属性不是基本数据类型或 String 类型，而是另一个引用类型，那么这个引用类型必 须是可序列化的，否则拥有该类型的Field 的类也不能序列化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///序列化：将对象写入到磁盘或者进行网络传输</span></span><br><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span></span><br><span class="line"><span class="title class_">FileOutputStream</span>(“data.txt<span class="string">&quot;));</span></span><br><span class="line"><span class="string">Person p = new Person(&quot;</span>张三<span class="string">&quot;, 18, &quot;</span>太白小区<span class="string">&quot;);</span></span><br><span class="line"><span class="string">oos.writeObject(p);</span></span><br><span class="line"><span class="string">oos.flush();</span></span><br><span class="line"><span class="string">oos.close();</span></span><br><span class="line"><span class="string">//反序列化：将磁盘中的对象数据源读出.</span></span><br><span class="line"><span class="string">ObjectInputStream ois = new ObjectInputStream(new</span></span><br><span class="line"><span class="string">FileInputStream(“data.txt&quot;</span>));</span><br><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> (Person)ois.readObject();</span><br><span class="line">System.out.println(p1.toString());</span><br><span class="line">ois.close();</span><br></pre></td></tr></table></figure>

<p>谈谈你对Serializable接口的理解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">实现了Serializable接口的对象，可将它们转换成一系列字节，并可在以后完全恢复回原来的样子。这一过程亦可通过网络进行。这意味着序列化机制能自动补偿操作系统间的差异。换句话说，可以先在Windows机器上创建一个对象，对其序列化，然后通过网络发给一台Unix机器，然后在那里准确无误地重新“装配”。不必关心数据在不同机器上如何表示，也不必关心字节的顺序或者其他任何细节。</span><br><span class="line">由于大部分作为参数的类如String、Integer等都实现了java.io.Serializable的接口，也可以利用多态的性质，作为参数使接口更灵活</span><br></pre></td></tr></table></figure>

<p>瞬态关键字 </p>
<p>当一个类的对象需要被序列化时，某些属性不需要被序列化，这时不需要序列化的属性可以使用关键字 transient修饰。只要被transient修饰了，序列化时这个属性就不会琲序列化了。同时静态修饰也不会被 序列化，因为序列化是把对象数据进行持久化存储，而静态的属于类加载时的数据，不会被序列化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">	<span class="comment">/** 给类显示声明一个序列版本号。 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">transient</span><span class="comment">/*瞬态*/</span> <span class="type">int</span> age;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="十八、反射"><a href="#十八、反射" class="headerlink" title="十八、反射"></a>十八、反射</h1><p>Reflection（反射）是被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API取得任 何类的内部信息，并能直接操作任意对象的内部属性及方法。 </p>
<p>加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象（一个类只有一个Class对象），这 个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子， 透过这个镜子看到类的结构，所以，我们形象的称之为：<strong>反射。</strong></p>
<p><strong>动态语言</strong> </p>
<p>是一类在运行时可以改变其结构的语言：例如新的函数、对象、甚至代码可以被引进，已有的函数可以 被删除或是其他结构上的变化。通俗点说就是<strong>在运行时代码可以根据某些条件改变自身结构。</strong>主要 动态语言：Object-C、C#、JavaScript、PHP、Python、Erlang。 </p>
<p><strong>静态语言</strong>与动态语言相对应的，运行时结构不可变的语言就是静态语言。如Java、C、C++。 </p>
<p>Java不是动态语言，但Java可以称之为“准动态语言”。即Java有一定的动态性，我们可以利用反射机制、 字节码操作获得类似动态语言的特性。Java的动态性让编程的时候更加灵活！ </p>
<p>Java反射机制提供的功能： </p>
<p>在运行时判断任意一个对象所属的类 </p>
<p>在运行时构造任意一个类的对象 </p>
<p>在运行时判断任意一个类所具有的成员变量和方法 </p>
<p>在运行时获取泛型信息 </p>
<p>在运行时调用任意一个对象的成员变量和方法 </p>
<p>在运行时处理注解 </p>
<p>生成动态代理 </p>
<p>反射机制主要API </p>
<p>**java.lang.Class:**代表一个类 </p>
<p><strong>java.lang.reflect.Method</strong>:代表类的方法 </p>
<p>**java.lang.reflect.Field:**代表类的成员变量 </p>
<p>**java.lang.reflect.Constructor:**代表类的构造器 </p>
<h2 id="1、Class类"><a href="#1、Class类" class="headerlink" title="1、Class类"></a>1、Class类</h2><p>在Object类中定义了以下的方法，此方法将被所有子类继承 </p>
<p>以上的方法返回值的类型是一个Class类，此类是Java反射的源头，实际上所谓反射从程序的运行结果来 看也很好理解，即：可以通过对象反射求出类的名称。 </p>
<p>Class类：某个类的属性、方法和构造器、某个类到底实现了哪些接口。对于每个类而言，JRE 都为其保 留一个不变的 Class 类型的对象。一个 Class 对象包含了特定某个结构 (class&#x2F;interface&#x2F;enum&#x2F;annotation&#x2F;primitive type&#x2F;void&#x2F;[])的有关信息。 </p>
<p>Class本身也是一个类。Class对象只能由系统建立对象。 </p>
<p>一个加载的类再JVM中只会由一个Class实例。一个Class对象对应一个加载到JVM中的要给.class文件。 </p>
<p>每个类的实例都会记得自己是由哪个Class实例所生成。 </p>
<p>通过Class可以完整得到一个类中的所有被加载的结构。 Class类是Reflection的根源，针对任何你想动态加载，运行的类，必须先获取相应的Class对象。 </p>
<p>获取Class的几种方法： </p>
<p>1&gt;若已知具体的类，通过类的class属性获取，该方法最可靠，程序性能最高。 </p>
<p>Class clazz &#x3D; Person.class </p>
<p>2&gt;若已知某个类的对象，调用该对象的getClass方法获取class对象 </p>
<p>3&gt;知道类的全名，通过 Class.forName();获取</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">类:获取类的方式 Class.forName(<span class="string">&quot;&quot;</span>);</span><br><span class="line">                 对象.getClass();</span><br><span class="line">                 类.class</span><br><span class="line">      加载类只会加载一次</span><br><span class="line">    获取类后才能获取类内部信息，属性，方法，构造方法</span><br><span class="line">    获取类后，newInstance方法创建对象，该方法默认会找无参构造,类中必须包含一个无参构造。【】</span><br><span class="line">    有了类后需要获取属性Field类型的对象</span><br><span class="line">    clazz.getFields();<span class="keyword">public</span>修饰的属性</span><br><span class="line">    对于属性的操作有哪些?赋值,取值</span><br><span class="line">       静态属性:可以通过类直接操作,直接获取值或直接赋值</span><br><span class="line">       非静态属性:依赖对象，通过对象. 给对象是属性赋值或取值</span><br><span class="line">       <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       dog.setXm();</span><br><span class="line">    getField(<span class="string">&quot;name&quot;</span>):通过属性名获取属性信息</span><br><span class="line">     field.set();</span><br><span class="line">     field.get();</span><br><span class="line">     field.setAccessible(<span class="literal">true</span>);可以访问私有化的属性 </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2、类的加载与ClassLoader的理解"><a href="#2、类的加载与ClassLoader的理解" class="headerlink" title="2、类的加载与ClassLoader的理解"></a>2、类的加载与ClassLoader的理解</h2><p> 当程序主动创建某个类时，如果该类还未被加载到内存中，则系统会通过以下三个步骤来对类进行初 始化。 </p>
<p>1&gt;类的加载:将类的class文件读入内存，并为之创建和一个java.lang.Class对象，该过程由类加载器完 成。 </p>
<p>类的加载与ClassLoader的理解：加载：将class文件字节码内容加载到内存中，并将这些静态数据转换 成方法区的运行时数据，然后生成一个代表这个类的Class对象，作为方法区中类数据的访问入口(地址 引用)。所有需要访问和使用类数据只能通过这个Class对象，这个加载的过程需要类加载器参与。 </p>
<p>2&gt;类的链接：将类的二进制数据合并到jre中。 </p>
<p>将java类的二进制代码合并到JVM的运行状态之中的过程。 </p>
<p>验证：确保加载的类信息符号JVM规范，利润，已cafe开头，没有安全方面的问题。</p>
<p>准备：正式为类变量static分配内存并设置类变量默认初始值的阶段，这些内存都将再方法区中进行 分配。 </p>
<p>解析：虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程 </p>
<p>3&gt;类的初始化：jvm负责对类进行初始化 </p>
<p>执行类构造器clinit()方法的过程，类构造器clinit()方法是由编译期自动收集类中所有类变量的赋值动 作和静态代码块中的语句合并产生的。类构造器是构造类信息，不说构造该类对象的构造器。 </p>
<p>当初始化一个类的时候，如果发现其父类还没进行初始化，则需要先触发其父类的初始化。 </p>
<p>虚拟机会保证一个类的clinit()方法在多线程环境中被正确加锁和同步。 </p>
<p><strong>ClassLoader:</strong></p>
<p> <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/44670213">https://zhuanlan.zhihu.com/p/44670213</a></p>
<h2 id="3、创建运行时类的对象"><a href="#3、创建运行时类的对象" class="headerlink" title="3、创建运行时类的对象"></a>3、创建运行时类的对象</h2><p>有了Class对象，能做什么？ </p>
<p><strong>创建类的对象</strong>：调用Class对象的newInstance()方法 </p>
<p>要 求： 1）类必须有一个无参数的构造器。2）类的构造器的访问权限需要足够。</p>
<h2 id="4、获取运行时类的完整结构"><a href="#4、获取运行时类的完整结构" class="headerlink" title="4、获取运行时类的完整结构"></a>4、获取运行时类的完整结构</h2><p>通过反射获取运行时类的完整结构:Field、Method、Constructor、Superclass、Interface、 Annotation。 </p>
<p>使用反射可以取得： </p>
<h3 id="1-实现的全部接口"><a href="#1-实现的全部接口" class="headerlink" title="1.实现的全部接口"></a>1.实现的全部接口</h3><p>public Class[] getInterfaces() 确定此对象所表示的类或接口实现的接口。 </p>
<h3 id="2-所继承的父类"><a href="#2-所继承的父类" class="headerlink" title="2.所继承的父类"></a>2.所继承的父类</h3><p>public Class getSuperclass()返回表示此 Class 所表示的实体（类、接口、基本类型）的父 类的Class </p>
<h3 id="3-全部的构造器"><a href="#3-全部的构造器" class="headerlink" title="3.全部的构造器"></a>3.全部的构造器</h3><p>public Constructor[] getConstructors()返回此 Class 对象所表示的类的所有public构造方法。 </p>
<p>public Constructor[] getDeclaredConstructors()返回此 Class 对象表示的类声明的所有构造方法。 </p>
<p>Constructor类中：取得修饰符: public int getModifiers();取得方法名称: public String getName();取得 参数的类型：public Class[] getParameterTypes();</p>
<h3 id="4-全部的方法"><a href="#4-全部的方法" class="headerlink" title="4.全部的方法"></a>4.全部的方法</h3><p>public Method[] getDeclaredMethods()返回此Class对象所表示的类或接口的全部方法 </p>
<p>public Method[] getMethods() 返回此Class对象所表示的类或接口的public的方法 </p>
<p>Method类中：public Class getReturnType()取得全部的返回值 </p>
<p>public Class[] getParameterTypes()取得全部的参数 </p>
<p>public int getModifiers()取得修饰符 </p>
<p>public Class[] getExceptionTypes()取得异常信息。</p>
<p> <strong>调用指定的方法</strong></p>
<p>通过反射，调用类中的方法，通过Method类完成。步骤： </p>
<p>1&gt;通过Class类的**getMethod(String name,Class…parameterTypes)**方法取得一个Method对象，并 设置此方法操作时所需要的参数类型。 </p>
<p>2&gt;之后使用**Object invoke(Object obj, Object[] args)**进行调用，并向方法中传递要设置的obj对象的 参数信息 </p>
<p><strong>Object invoke(Object obj, Object … args):</strong> </p>
<p><strong>说明：</strong> </p>
<p>Object 对应原方法的返回值，若原方法无返回值，此时返回null </p>
<p>若原方法若为静态方法，此时形参Object obj可为null </p>
<p>若原方法形参列表为空，则Object[] args为null </p>
<p>若原方法声明为private,则需要在调用此invoke()方法前，显式调用方法对象的setAccessible(true)方 法，将可访问private的方法 </p>
<h3 id="5-全部的Field"><a href="#5-全部的Field" class="headerlink" title="5.全部的Field"></a>5.全部的Field</h3><p>public Field[] getFields() 返回此Class对象所表示的类或接口的public的Field。 </p>
<p>public Field[] getDeclaredFields() 返回此Class对象所表示的类或接口的全部Field。 </p>
<p>Field方法中：public int getModifiers() 以整数形式返回此Field的修饰符 </p>
<p>public Class getType() 得到Field的属性类型 </p>
<p>public String getName() 返回Field的名称。 </p>
<p><strong>调用指定属性</strong> </p>
<p>在反射机制中，可以直接通过Field类操作类中的属性，通过Field类提供的set()和get()方法就可以完成设 置和取得属性内容的操作。 </p>
<p>public Field getField(String name) 返回此Class对象表示的类或接口的指定的public的Field。 </p>
<p>public Field getDeclaredField(String name)返回此Class对象表示的类或接口的指定的Field。 </p>
<p>在Field中： </p>
<p>public Object get(Object obj) 取得指定对象obj上此Field的属性内容 </p>
<p>public void set(Object obj,Object value) 设置指定对象obj上此Field的属性内容 </p>
<h3 id="6-Annotation相关"><a href="#6-Annotation相关" class="headerlink" title="6.Annotation相关"></a>6.Annotation相关</h3><p>get Annotation(Class annotationClass) getDeclaredAnnotations() </p>
<h3 id="7-泛型相关"><a href="#7-泛型相关" class="headerlink" title="7.泛型相关"></a>7.泛型相关</h3><p>获取父类泛型类型：Type getGenericSuperclass() </p>
<p>泛型类型：ParameterizedType 获取实际的泛型类型参数数组：getActualTypeArguments() </p>
<h3 id="8-类所在的包"><a href="#8-类所在的包" class="headerlink" title="8.类所在的包"></a>8.类所在的包</h3><p>Package getPackage()</p>
<h2 id="5、动态代理"><a href="#5、动态代理" class="headerlink" title="5、动态代理"></a>5、动态代理</h2><p>创建接口与接口的实现类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">update</span><span class="params">(Users user)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl1</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;userDao中实现类1的save&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">update</span><span class="params">(Users user)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dao实现类1执行了。。。&quot;</span>+user);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dao实现类1执行了。。。。&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> ii.创建InvocationHandler</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyInvocationHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法执行之前执行....&quot;</span>+method.getName()+<span class="string">&quot;....&quot;</span>+ Arrays.toString(args));</span><br><span class="line">        <span class="type">Object</span> <span class="variable">res</span> <span class="operator">=</span> method.invoke(target,args);</span><br><span class="line">        System.out.println(<span class="string">&quot;方法执行之后执行&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testProxy</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">UserDaoImpl1</span> <span class="variable">dao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl1</span>();</span><br><span class="line">        Class[] classes = dao.getClass().getInterfaces();</span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">proxy</span> <span class="operator">=</span> (UserDao) Proxy.newProxyInstance(SpringTest.class.getClassLoader(),classes,<span class="keyword">new</span> <span class="title class_">MyInvocationHandler</span>(dao));</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> proxy.test(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">        System.out.println(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="十九、网络编程"><a href="#十九、网络编程" class="headerlink" title="十九、网络编程"></a>十九、网络编程</h1><p>Java是 Internet 上的语言，它从语言级上提供了对网络应用程序的支持，程序员能够很容易开发常见的 网络应用程序。 </p>
<p>Java提供的网络类库，可以实现无缝的网络连接，联网的底层细节被隐藏在 Java 的本机安装系统里，由 JVM 进行控制。并且 Java 实现了一个跨平台的网络库，程序员面对的是一个统一的网络编程环境。</p>
<p>网络编程的目的就是指直接或间接地通过网络协议与其它计算机进行通讯。 </p>
<p>网络编程中有两个主要的问题: </p>
<p>如何准确地定位网络上一台或多台主机 </p>
<p>找到主机后如何可靠高效地进行数据传输 </p>
<p>要想让处于网络中的主机互相通信，只是知道通信双方地址还是不够的，还必须遵循一定的规则。有两 套参考模型： </p>
<p>OSI参考模型：模型过于理想化，未能在因特网上进行广泛推广 </p>
<p>TCP&#x2F;IP参考模型(或TCP&#x2F;IP协议)：事实上的国际标准。 </p>
<ol>
<li>TCP&#x2F;IP协议</li>
</ol>
<p>TCP&#x2F;IP 以其两个主要协议：传输控制协议(TCP)和网络互联协议(IP)而得名，实际上是一组协议，包括多 个具有不同功能且互为关联的协议。</p>
<p> TCP&#x2F;IP协议模型从更实用的角度出发，形成了高效的四层体系结构，即网络接口层、IP层、传输层和应 用层。下图表示了TCP&#x2F;IP的分层结构和与OSI参考模型的对应关系。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220323144147553.png" alt="image-20220323144147553"></p>
<p><strong>传输层协议中有两个非常重要的协议：</strong> </p>
<ul>
<li><p>传输控制协议TCP(Transmission Control Protocol) </p>
</li>
<li><p>用户数据报协议UDP(User Datagram Protocol)。</p>
</li>
</ul>
<p>传输控制协议TCP是面向连接的传输层协议。即应用进程(或程序)在使用TCP协议之前，必须先建立TCP 连接，在传输完毕后，释放已经建立的连接。利用TCP协议进行通信的两个应用进程，一个是服务器进 程。另一个是客户进程。</p>
<p>• 用户数据报协议UDP是面向无连接的运输层协议。即应用进程(或程序)在使用UDP协议之前，不必先建 立连接。自然，发送数据结束时也没有连接需要释放。因此，减少了开销和发送数据之前的时延。 Internet上的主机有两种方式表示地址：</p>
<p>域名：www. baidu.com </p>
<p>IP 地址：180.97.33.108（动态IP地址）</p>
<ol start="2">
<li>InetAddress简介</li>
</ol>
<p>InetAddress 类对象含有一个 Internet 主机地址的域名和IP地址：<a target="_blank" rel="noopener" href="http://www.baidu.com/180.97.33.108%E3%80%82">www.baidu.com/180.97.33.108。</a> </p>
<p>域名容易记忆，当在连接网络时输入一个主机的域名后，域名服务器（DNS）负责将域名转化成IP地 址，这样才能和主机建立连接。 </p>
<p>获取Internet上主机的地址：使用InetAddress类的静态方法：</p>
<p> getByName(String s)：将一个域名或 IP 地址传递给该方法的参数，获得一个 InetAddress对象，该对 象含有主机地址的域名和IP地址，该对象用如下格式表示它包含的信息： <a target="_blank" rel="noopener" href="http://www.baidu.com/180.97.33.108">www.baidu.com/180.97.33.108</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">inter</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;www.baidu.com&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">add</span> <span class="operator">=</span> inter.getHostAddress();</span><br><span class="line">        System.out.println(add);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>端口号：标识正在计算机上运行的进程。公认端口:0-1023。注册端口：1024-49151 。 </p>
<h2 id="TCP程序设计："><a href="#TCP程序设计：" class="headerlink" title="TCP程序设计："></a>TCP程序设计：</h2><p>客户端－服务器模型是最常见的网络应用程序模型。当我们上网时，我们所使用的浏览器(例如IE)就是一 个客户端软件，而提供网页的站点必需运行一个WEB服务器。 </p>
<p>一般而言，主动发起通信的应用程序属于客户端。而服务器则是等待通信请求，当服务器收到客户端的 请求，执行需要的运算然后向客户端返回结果。</p>
<p> IP 地址标识 Internet 上的计算机，端口号标识正在计算机上运行的进程（程序）。 </p>
<p>端口号与IP地址的组合得出一个网络套接字。 </p>
<p>端口号被规定为一个 16 位的整数 0<del>65535。其中，0</del>1023被预先定义的服务通信占用（如telnet占用 端口23，http占用端口80等）。除非我们需要访问这些特定服务，否则，就应该使用 1024~65535 这些 端口中的某一个进行通信，以免发生端口冲突。 </p>
<p>利用套接字(Socket)接口开发网络应用程序早已被广泛的采用，以至于成为事实上的标准。套接字能执 行7种基本操作： </p>
<p>• 连接到远程主机 </p>
<p>• 绑定到端口 </p>
<p>• 接收从远程机器来的连接请求 </p>
<p>• 监听到达的数据 </p>
<p>• 发送数据</p>
<p>• 接收数据 </p>
<p>• 关闭连接 </p>
<ol>
<li>Socket简介</li>
</ol>
<p> 两个Java应用程序可通过一个双向的网络通信连接实现数据交换，这个双向链路的一段称为一个Socket (套接字)。Socket通常用来实现Client&#x2F;Server 连接。 </p>
<p>Java语言的基于套接字编程分为服务器编程和客户端编程，其通信模型如图所示： </p>
<p>一个简单的案例：服务器端与客户端之间是通过流进行交互的。请回顾，输入流与输出流 </p>
<p>该案例实现如下效果，客户端与服务器端进行交流，如果客户端输入的是hello,服务器端返回world. 传输普通 的文字</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端启动&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;localhost&quot;</span>,<span class="number">8888</span>);</span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">            outputStream.write(<span class="string">&quot;你好，服务器&quot;</span>.getBytes());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;客户端已经启动&quot;</span>);</span><br><span class="line">            <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>);</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">            <span class="type">byte</span>[]bs = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            is.read(bs);</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bs);</span><br><span class="line">            System.out.println(<span class="string">&quot;接收到的信息：&quot;</span>+s.trim());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1_Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务开启&quot;</span>);</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">12456</span>);</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> server.accept();</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">byte</span>[] bs = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        inStream.read(bs);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bs);</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">null</span>!=s&amp;&amp;s.trim().equals(<span class="string">&quot;hello&quot;</span>)) &#123;</span><br><span class="line">            os = socket.getOutputStream();</span><br><span class="line">            os.write(<span class="string">&quot;world&quot;</span>.getBytes());</span><br><span class="line">        &#125;</span><br><span class="line">        inStream.close();</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">null</span>!=os) &#123;</span><br><span class="line">            os.close();</span><br><span class="line">        &#125;</span><br><span class="line">        socket.close();</span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1_Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入要传递的内容&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">words</span> <span class="operator">=</span> input.next();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">12456</span>);</span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">            os.write(words.getBytes());</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">inStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">            <span class="type">byte</span>[] bs=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            inStream.read(bs);</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bs);</span><br><span class="line">            System.out.println(s.trim());</span><br><span class="line">            os.close();</span><br><span class="line">            inStream.close();</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>传输普通的图片</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientTest01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;localhost&quot;</span>,<span class="number">8888</span>);</span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">            <span class="type">FileInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:/info4.png&quot;</span>);</span><br><span class="line">            <span class="type">int</span> i;</span><br><span class="line">            <span class="keyword">while</span>((i=inputStream.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">                out.write(i);</span><br><span class="line">            &#125;</span><br><span class="line">            out.close();</span><br><span class="line">            inputStream.close();</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ServerTest01</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>);</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">            <span class="type">FileOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;bak.png&quot;</span>);</span><br><span class="line">            <span class="type">int</span> i ;</span><br><span class="line">            <span class="keyword">while</span>((i=inputStream.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">                out.write(i);</span><br><span class="line">            &#125;</span><br><span class="line">            out.close();</span><br><span class="line">            inputStream.close();</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.openlab.net;</span><br><span class="line"><span class="keyword">import</span> com.openlab.test.OtherClass;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientTest01</span> &#123;</span><br><span class="line">    <span class="comment">//客户端给服务器端发送图片，并收到服务器端的返回的信息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;localhost&quot;</span>,<span class="number">8888</span>);</span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> socket.getOutputStream();<span class="comment">//output</span></span><br><span class="line">            <span class="type">FileInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:/info4.png&quot;</span>);</span><br><span class="line">            <span class="type">int</span> i;</span><br><span class="line">            <span class="keyword">while</span>((i=inputStream.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">                out.write(i);</span><br><span class="line">            &#125;</span><br><span class="line">            socket.shutdownOutput();<span class="comment">//关闭output</span></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">inputStream1</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">            <span class="type">byte</span>[] bs = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            inputStream1.read(bs) ;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bs);</span><br><span class="line">            System.out.println(<span class="string">&quot;收到服务器端信息:&quot;</span>+s.trim());</span><br><span class="line">            out.close();</span><br><span class="line">            inputStream.close();</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ServerTest01</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>);</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">            <span class="type">FileOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;bak.png&quot;</span>);</span><br><span class="line">            <span class="type">int</span> i ;</span><br><span class="line">            <span class="keyword">while</span>((i=inputStream.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">                out.write(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">            outputStream.write(<span class="string">&quot;已经收到信息&quot;</span>.getBytes());</span><br><span class="line">            outputStream.close();</span><br><span class="line">            inputStream.close();</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP:"></a>UDP:</h2><p>和TCP编程相比，UDP编程就简单得多，因为UDP没有创建连接，数据包也是一次收发一个，所以没有 流的概念。在Java中使用UDP编程，仍然需要使用Socket，因为应用程序在使用UDP时必须指定网络接 口（IP）和端口号。注意：UDP端口和TCP端口虽然都使用0~65535，但他们是两套独立的端口，即一 个应用程序用TCP占用了端口1234，不影响另一个应用程序用UDP占用端口1234。在服务器端，使用 UDP也需要监听指定的端口。Java提供了 DatagramSocket 来实现这个功能。UDP数据报通过数据报套 接字DatagramSocket发送和接收，系统不保证UDP数据报一定能够安全送达目的地，也不能确定什么 时候可以抵达。DatagramPacket对象封装了UDP数据报，在数据报中包含了发送端的IP地址和端口号 以及接收端的IP地址和端口号。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Send</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">DatagramSocket</span> <span class="variable">datagramSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;我的UDP方式发送的信息&quot;</span>;</span><br><span class="line">            <span class="type">byte</span>[] bs = s.getBytes();</span><br><span class="line">            <span class="type">InetAddress</span> <span class="variable">inetAddress</span> <span class="operator">=</span> InetAddress.getLocalHost();</span><br><span class="line">            <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bs,<span class="number">0</span>,bs.length,inetAddress,<span class="number">8888</span>);</span><br><span class="line">            datagramSocket.send(packet);</span><br><span class="line">            datagramSocket.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Receive</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">DatagramSocket</span> <span class="variable">datagramSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">8888</span>);</span><br><span class="line">            <span class="type">byte</span>[] bs = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bs,<span class="number">0</span>,bs.length);</span><br><span class="line">            datagramSocket.receive(packet);</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(packet.getData(),<span class="number">0</span>,packet.getLength()));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>URL编程：URL（Uniform Resource Locator）统一资源定位符，它标识Internet上某一资源的地址。 它是一种具体的URL，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">HttpURLConnection</span> <span class="variable">urlConnection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://localhost:8080/jspdemo01_war_exploded/test.bmp&quot;</span>);</span><br><span class="line">        urlConnection = (HttpURLConnection) url.openConnection();</span><br><span class="line">        urlConnection.connect();</span><br><span class="line">        inputStream = urlConnection.getInputStream();</span><br><span class="line">        <span class="type">int</span> i ;</span><br><span class="line">        out = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;bak1.png&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>((i=inputStream.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">            out.write(i);</span><br><span class="line">        &#125;</span><br><span class="line">        out.close();</span><br><span class="line">        inputStream.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP:"></a>HTTP:</h2><p>什么是HTTP？HTTP就是目前使用最广泛的Web应用程序使用的基础协议，例如，浏览器访问网站，手 机App访问后台服务器，都是通过HTTP协议实现的。HTTP是HyperText Transfer Protocol的缩写，翻 译为超文本传输协议，它是基于TCP协议之上的一种请求-响应协议。</p>
<p>我们来看一下浏览器请求访问某个网站时发送的HTTP请求-响应。当浏览器希望访问某个网站时，浏览 器和网站服务器之间首先建立TCP连接，且服务器总是使用 80 端口和加密端口 443 ，然后，浏览器向 服务器发送一个HTTP请求，服务器收到后，返回一个HTTP响应，并且在响应中包含了HTML的网页内 容，这样，浏览器解析HTML后就可以给用户显示网页了。一个完整的HTTP请求-响应如下。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220323145401697.png" alt="image-20220323145401697"></p>
<p>HTTP请求的格式是固定的，它由HTTP Header和HTTP Body两部分构成。第一行总是 请求方法 路径 HTTP版本 ，例如， GET &#x2F; HTTP&#x2F;1.1 表示使用 GET 请求，路径是 &#x2F; ，版本是 HTTP&#x2F;1.1 。 </p>
<p>后续的每一行都是固定的 Header: Value 格式，我们称为HTTP Header，服务器依靠某些特定的 Header来识别客户端请求，例如：</p>
<p> Host：表示请求的域名，因为一台服务器上可能有多个网站，因此有必要依靠Host来识别用于请求； </p>
<p>User-Agent：表示客户端自身标识信息，不同的浏览器有不同的标识，服务器依靠User-Agent判断客户 端类型； </p>
<p>Accept：表示客户端能处理的HTTP响应格式， &#x2F; 表示任意格式， text&#x2F;* 表示任意文本， image&#x2F;png 表 示PNG格式的图片； </p>
<p>Accept-Language：表示客户端接收的语言，多种语言按优先级排序，服务器依靠该字段给用户返回特 定语言的网页版本。 </p>
<p>如果是 GET 请求，那么该HTTP请求只有HTTP Header，没有HTTP Body。如果是 POST 请求，那么该 HTTP请求带有Body，以一个空行分隔。一个典型的带Body的HTTP请求如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST /login HTTP/<span class="number">1.1</span></span><br><span class="line">Host: www.example.com</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: <span class="number">30</span></span><br><span class="line">username=hello&amp;password=<span class="number">123456</span></span><br></pre></td></tr></table></figure>

<p>POST 请求通常要设置 Content-Type 表示Body的类型， Content-Length 表示Body的长度，这样服务 器就可以根据请求的Header和Body做出正确的响应。 </p>
<p>此外， GET 请求的参数必须附加在URL上，并以URLEncode方式编码，例如：<a target="_blank" rel="noopener" href="http://www.example.co/">http://www.example.co</a> m&#x2F;?a&#x3D;1&amp;b&#x3D;K%26R ，参数分别是 a&#x3D;1 和 b&#x3D;K&amp;R 。因为URL的长度限制，GET 请求的参数不能太多， 而 POST 请求的参数就没有长度限制，因为 POST 请求的参数必须放到Body中。并且， POST 请求的参 数不一定是URL编码，可以按任意格式编码，只需要在 Content-Type中正确设置即可。常见的发送 JSON的 POST 请求如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /login HTTP/1.1</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Content-Length: 38</span><br><span class="line">&#123;&quot;username&quot;:&quot;bob&quot;,&quot;password&quot;:&quot;123456&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>HTTP响应也是由Header和Body两部分组成，一个典型的HTTP响应如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 133251</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">    &lt;html&gt;&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;Hello&lt;/h1&gt;</span><br></pre></td></tr></table></figure>

<p>响应的第一行总是 HTTP版本 响应代码 响应说明 ，例如， HTTP&#x2F;1.1 200 OK 表示版本是HTTP&#x2F;1.1 ，响 应代码是 200 ，响应说明是 OK 。客户端只依赖响应代码判断HTTP响应是否成功。 </p>
<p>HTTP有固定的响应代码： </p>
<p>1xx：表示一个提示性响应，例如101表示将切换协议，常见于WebSocket连接； </p>
<p>2xx：表示一个成功的响应，例如200表示成功，206表示只发送了部分内容； </p>
<p>3xx：表示一个重定向的响应，例如301表示永久重定向，303表示客户端应该按指定路径重新发送请 求； </p>
<p>4xx：表示一个因为客户端问题导致的错误响应，例如400表示因为Content-Type等各种原因导致的无效 请求，404表示指定的路径不存在； </p>
<p>5xx：表示一个因为服务器问题导致的错误响应，例如500表示服务器内部故障，503表示服务器暂时无 法响应。 </p>
<p>当浏览器收到第一个HTTP响应后，它解析HTML后，又会发送一系列HTTP请求，例如， GET &#x2F;logo.jpg HTTP&#x2F;1.1 请求一个图片，服务器响应图片请求后，会直接把二进制内容的图片发送给浏览器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: image/jpeg</span><br><span class="line">Content-Length: 18391</span><br><span class="line">????JFIFHH??XExifMM?i&amp;??X?...(二进制的JPEG图片)</span><br></pre></td></tr></table></figure>

<p>因此，服务器总是被动地接收客户端的一个HTTP请求，然后响应它。客户端则根据需要发送若干个 HTTP请求。 </p>
<p>对于最早期的HTTP&#x2F;1.0协议，每次发送一个HTTP请求，客户端都需要先创建一个新的TCP连接，然后， 收到服务器响应后，关闭这个TCP连接。由于建立TCP连接就比较耗时，因此，为了提高效率， HTTP&#x2F;1.1协议允许在一个TCP连接中反复发送-响应，这样就能大大提高效率</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220323145619489.png" alt="image-20220323145619489"></p>
<p>因为HTTP协议是一个请求-响应协议，客户端在发送了一个HTTP请求后，必须等待服务器响应后，才能 发送下一个请求，这样一来，如果某个响应太慢，它就会堵住后面的请求。</p>
<p> 所以，为了进一步提速，HTTP&#x2F;2.0允许客户端在没有收到响应的时候，发送多个HTTP请求，服务器返 回响应的时候，不一定按顺序返回，只要双方能识别出哪个响应对应哪个请求，就可以做到并行发送和 接收：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220323145640571.png" alt="image-20220323145640571"></p>
<p>可见，HTTP&#x2F;2.0进一步提高了效率。 </p>
<p><strong>HTTP编程</strong> </p>
<p>既然HTTP涉及到客户端和服务器端，和TCP类似，我们也需要针对客户端编程和针对服务器端编程。 </p>
<p>本节我们不讨论服务器端的HTTP编程，因为服务器端的HTTP编程本质上就是编写Web服务器，这是一 个非常复杂的体系，也是JavaEE开发的核心内容，我们在后面的章节再仔细研究。 </p>
<p>本节我们只讨论作为客户端的HTTP编程。 </p>
<p>因为浏览器也是一种HTTP客户端，所以，客户端的HTTP编程，它的行为本质上和浏览器是一样的，即 发送一个HTTP请求，接收服务器响应后，获得响应内容。只不过浏览器进一步把响应内容解析后渲染并 展示给了用户，而我们使用Java进行HTTP客户端编程仅限于获得响应内容。 </p>
<p>我们来看一下Java如果使用HTTP客户端编程。Java标准库提供了基于HTTP的包，但是要注意，早期的 JDK版本是通过 HttpURLConnection 访问 </p>
<p>HTTP，典型代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">HttpURLConnection</span> <span class="variable">urlConnection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://localhost:8080/jspdemo01_war_exploded/test.bmp&quot;</span>);</span><br><span class="line">        urlConnection = (HttpURLConnection) url.openConnection();</span><br><span class="line">        urlConnection.connect();</span><br><span class="line">        inputStream = urlConnection.getInputStream();</span><br><span class="line">        <span class="type">int</span> i ;</span><br><span class="line">        out = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;bak1.png&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>((i=inputStream.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">            out.write(i);</span><br><span class="line">        &#125;</span><br><span class="line">        out.close();</span><br><span class="line">        inputStream.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="二十、JDK8新特性"><a href="#二十、JDK8新特性" class="headerlink" title="二十、JDK8新特性"></a>二十、JDK8新特性</h1><h2 id="1、日期类型"><a href="#1、日期类型" class="headerlink" title="1、日期类型"></a>1、日期类型</h2><p>Java 8 吸收了 Joda-Time 的精华，以一个新的开始为 Java 创建优秀的 API。新的 java.time 中包含了所 有关于本地日期（LocalDate）、本地时间（LocalTime）、本地日期时间（LocalDateTime）、时区 （ZonedDateTime）和持续时间（Duration）的类。历史悠久的 Date 类新增了 toInstant() 方法，用 于把 Date 转换成新的表示形式。这些新增的本地化时间日期 API 大大简化了日期时间和本地化的管理 </p>
<p>LocalDate、LocalTime、LocalDateTime 类是其中较重要的几个类，它们的实例是不可变的对象，分别 表示使用 ISO-8601日历系统的日期、时间、日期和时间。它们提供了简单的本地日期或时间，并不包含 当前的时间信息，也不包含与时区相关的信息。 </p>
<p>LocalDate代表IOS格式（yyyy-MM-dd）的日期,可以存储 生日、纪念日等日期。 </p>
<p>LocalTime表示一个时间，而不是日期。</p>
<p>LocalDateTime是用来表示日期和时间的，这是一个最常用的类之一。 </p>
<p><strong>注：</strong>ISO-8601日历系统是国际标准化组织制定的现代公民的日期和时间的表示法，也就是公历。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">LocalDate</span> <span class="variable">time</span> <span class="operator">=</span> LocalDate.now();<span class="comment">// 获取系统当前的时间</span></span><br><span class="line">		System.out.println(time);</span><br><span class="line">		time = LocalDate.of(<span class="number">2018</span>, <span class="number">3</span>, <span class="number">25</span>);<span class="comment">//将整数转为为日期类型</span></span><br><span class="line">		time = LocalDate.of(<span class="number">2018</span>, Month.JUNE, <span class="number">25</span>);<span class="comment">//将整数转换为日期类型</span></span><br><span class="line">		System.out.println(time);</span><br><span class="line">		time = LocalDate.parse(<span class="string">&quot;2018年04月08号&quot;</span>,</span><br><span class="line">DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy年MM月dd号&quot;</span>));<span class="comment">//将一个字符串转换为日期类型</span></span><br><span class="line">		System.out.println(time.isLeapYear());<span class="comment">//是否是闰年</span></span><br><span class="line">		System.out.println(time);</span><br><span class="line">		<span class="type">Period</span> <span class="variable">p</span> <span class="operator">=</span> time.until(LocalDate.now());<span class="comment">//获取两个日期的时间差，得到的是Period类型</span></span><br><span class="line">        </span><br><span class="line">System.out.println(p.getYears()+<span class="string">&quot;年&quot;</span>+p.getMonths()+<span class="string">&quot;月&quot;</span>+p.getDays()+<span class="string">&quot;天&quot;</span>);<span class="comment">//可以通过period类型获取 年月日</span></span><br><span class="line">        </span><br><span class="line">		<span class="type">long</span> <span class="variable">t</span> <span class="operator">=</span> ChronoUnit.DAYS.between(time, LocalDate.now());<span class="comment">//求两个日期差了多少天</span></span><br><span class="line">		System.out.println(t);</span><br><span class="line">		<span class="type">DayOfWeek</span> <span class="variable">d</span> <span class="operator">=</span> time.getDayOfWeek();<span class="comment">//获取该日期是星期几</span></span><br><span class="line">		System.out.println(d.getValue());<span class="comment">//获取星期几的数字表示</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">LocalTime</span> <span class="variable">time</span> <span class="operator">=</span> LocalTime.now();<span class="comment">//系统当前的时间，时分秒毫秒</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> time.format(DateTimeFormatter.ofPattern(<span class="string">&quot;HH:mm:ss&quot;</span>));<span class="comment">//转换</span></span><br><span class="line">	System.out.println(time);</span><br><span class="line">	System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">LocalDateTime</span> <span class="variable">time</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">	System.out.println(time);</span><br><span class="line">	<span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> time.getYear();</span><br><span class="line">	<span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> time.getMonth().getValue();</span><br><span class="line">	<span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> time.getDayOfMonth();</span><br><span class="line">	<span class="type">int</span> <span class="variable">week</span> <span class="operator">=</span> time.getDayOfWeek().getValue();</span><br><span class="line">	System.out.println(year+<span class="string">&quot;年&quot;</span>+month+<span class="string">&quot;月&quot;</span>+day+<span class="string">&quot;日\t&quot;</span>+week);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Instant</span> <span class="variable">instant</span> <span class="operator">=</span> Instant.now();</span><br><span class="line">		System.out.println(instant);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//添加时间的偏移量</span></span><br><span class="line">		<span class="type">OffsetDateTime</span> <span class="variable">offsetDateTime</span> <span class="operator">=</span></span><br><span class="line">instant.atOffset(ZoneOffset.ofHours(<span class="number">8</span>));</span><br><span class="line">		System.out.println(offsetDateTime);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//toEpochMilli():获取自1970年1月1日0时0分0秒（UTC）开始的毫秒数 ---&gt; Date类的getTime()</span></span><br><span class="line">		<span class="type">long</span> <span class="variable">milli</span> <span class="operator">=</span> instant.toEpochMilli();</span><br><span class="line">		System.out.println(milli);</span><br><span class="line">		<span class="comment">//ofEpochMilli():通过给定的毫秒数，获取Instant实例 --&gt;Date(long millis)</span></span><br><span class="line">		<span class="type">Instant</span> <span class="variable">instant1</span> <span class="operator">=</span> Instant.ofEpochMilli(<span class="number">1550475314878L</span>);</span><br><span class="line">		System.out.println(instant1);</span><br></pre></td></tr></table></figure>

<h2 id="2、Lambda表达式"><a href="#2、Lambda表达式" class="headerlink" title="2、Lambda表达式"></a>2、Lambda表达式</h2><p> lambda 表达式，也可称为[闭包]，它是推动Java 8 发布的最重要新特性，允许把[函数]作为一个方法的 参数（函数作为参数传递进方法中），Java中的Lambda可以被当做是匿名内部类的“语法糖”。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">run</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;run接口中的run方法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    run.run();</span><br><span class="line">    System.out.println(<span class="string">&quot;-----------------------------------&quot;</span>);</span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">run1</span> <span class="operator">=</span> ()-&gt;&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;run接口中的run方法&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    run1.run();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span>&#123;</span><br><span class="line">    Comparator&lt;Integer&gt; com = <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    com.compare(<span class="number">20</span>,<span class="number">35</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;--------------------&quot;</span>);</span><br><span class="line">    Comparator&lt;Integer&gt; com2 =(o1,o2)-&gt; &#123;<span class="keyword">return</span> o1.compareTo(o2);&#125;;</span><br><span class="line">    <span class="comment">//方法引用</span></span><br><span class="line">    Comparator&lt;Integer&gt; com3=Integer::compareTo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Lambda表达式的本质：作为函数式接口的实例。 </p>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parameters) -&gt; expression</span><br><span class="line">或</span><br><span class="line">(parameters) -&gt;&#123; statements; &#125;</span><br></pre></td></tr></table></figure>

<p>( ) ：用来描述参数列表； </p>
<p>{ } ： 用来描述方法体； </p>
<p>-&gt; ：Lambda运算符，可以叫做箭头符号，或者goes to </p>
<p>3、函数式(Functional)接口：如果一个接口中，只声明了一个抽象方法，则此接口就称为函数式接口。</p>
<h1 id="二一、JSON"><a href="#二一、JSON" class="headerlink" title="二一、JSON"></a>二一、JSON</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串转换为json对象，以及java对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//字符串转换为json对象</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;name\&quot;:\&quot;zhangsan\&quot;,\&quot;sex\&quot;:\&quot;male\&quot;,\&quot;age\&quot;:\&quot;18\&quot;&#125;&quot;</span>;</span><br><span class="line">    <span class="type">JSONObject</span> <span class="variable">obj</span> <span class="operator">=</span>JSONObject.parseObject(str);</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> obj.get(<span class="string">&quot;name&quot;</span>).toString();</span><br><span class="line">    System.out.println(name);</span><br><span class="line">    <span class="type">String</span> <span class="variable">name2</span> <span class="operator">=</span> obj.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    System.out.println(name2);</span><br><span class="line">    <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> obj.getInteger(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">    System.out.println(age);</span><br><span class="line">    <span class="comment">//json字符串转换为普通java对象</span></span><br><span class="line">    <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person) JSONObject.parseObject(str,Person.class);</span><br><span class="line">    System.out.println(p.getSex());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java对象转换为json字符串以及json对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    p.setName(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">    p.setAge(<span class="number">18</span>);</span><br><span class="line">    p.setSex(<span class="string">&quot;男&quot;</span>);</span><br><span class="line">    <span class="comment">//java对象转换为json字符串</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> JSONObject.toJSONString(p);</span><br><span class="line">    System.out.println(s);</span><br><span class="line">    <span class="comment">//java对象转换为json对象</span></span><br><span class="line">    JSONObject json= (JSONObject) JSONObject.toJSON(p);</span><br><span class="line">    System.out.println(json.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通java集合转换为json数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;Person&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;A&quot;</span>,<span class="string">&quot;男&quot;</span> ,<span class="number">17</span>);</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;B&quot;</span>,<span class="string">&quot;女&quot;</span> ,<span class="number">16</span>);</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;C&quot;</span>,<span class="string">&quot;男&quot;</span> ,<span class="number">17</span>);</span><br><span class="line">    list.add(p1);</span><br><span class="line">    list.add(p2);</span><br><span class="line">    list.add(p3);</span><br><span class="line">    <span class="type">JSONArray</span> <span class="variable">arr</span> <span class="operator">=</span> (JSONArray) JSONArray.toJSON(list);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.size();i++)&#123;</span><br><span class="line">        <span class="type">JSONObject</span> <span class="variable">json</span> <span class="operator">=</span> (JSONObject) arr.get(i);</span><br><span class="line">        System.out.println(json.get(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line">    String s=<span class="string">&quot;[&#123;\&quot;name\&quot;:\&quot;zhangsan\&quot;,\&quot;sex\&quot;:\&quot;male\&quot;,\&quot;age\&quot;:\&quot;18\&quot;&#125;,&#123;\&quot;name\&quot;:\&quot;zhangsan1\&quot;,\&quot;sex\&quot;:\&quot;male1\&quot;,\&quot;age\&quot;:\&quot;17\&quot;&#125;]&quot;</span>;</span><br><span class="line">    List&lt;Person&gt; list = JSONObject.parseArray(s,Person.class);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> list.get(i);</span><br><span class="line">        System.out.println(p.getName()+<span class="string">&quot;\t&quot;</span>+p.getSex());</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;-------------------------------&quot;</span>);</span><br><span class="line">    <span class="type">JSONArray</span> <span class="variable">arr</span> <span class="operator">=</span> JSONObject.parseArray(s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.size();i++)&#123;</span><br><span class="line">        <span class="type">JSONObject</span> <span class="variable">json</span> <span class="operator">=</span> (JSONObject) arr.get(i);</span><br><span class="line">        System.out.println(json.get(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">陈天在睡觉</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/post/2b32338b.html">http://example.com/post/2b32338b.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">陈天在睡觉</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/%E5%8D%9A%E5%AE%A28.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/post/38c0576c.html"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E5%8D%9A%E5%AE%A26.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">RHCSA</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E5%A4%B4%E5%83%8F.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">陈天在睡觉</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">6</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://blog.csdn.net/qq_52059326" target="_blank" title="CSDN"><i class="iconfont icon-csdn"></i></a><a class="social-icon" href="https://space.bilibili.com/14631623" target="_blank" title="b站"><i class="iconfont icon-bilibili-fill"></i></a><a class="social-icon" href="https://github.com/chentianzaishuijiao" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content"><b><font color="#e66b6d">双</font> <font color="#e66d98">手</font> <font color="#e66cc6">合</font> <font color="#cc6de6">十</font> <font color="#9770e6">成</font> <font color="#6d93e6">为</font> <font color="#6fcde6">自</font> <font color="#72e6b6">己</font> <font color="#72e689">的</font> <font color="#99e670">神</font>, <font color="#cde670">自</font> <font color="#e6df72">己</font> <font color="#e6c073">所</font> <font color="#e6a271">信</font> <font color="#e6796f">念</font> <font color="#e65454">的</font> <font color="#e63333">即</font> <font color="#e62c2c">是</font> <font color="#e60101">信</font> <font color="#e60101">仰</font></b> <p align="center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/f7384c88956d4378b72e47548e19c9f8.gif" width="50" alt="mao"></p> <p align="center">微信号：a847503688</p> <p align="center">QQ号：847503688</p></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">一、java语言概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.</span> <span class="toc-text">1、软件开发介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.2.</span> <span class="toc-text">2、计算机编程语言介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0"><span class="toc-number">1.3.</span> <span class="toc-text">3、java语言概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81java%E6%8A%80%E6%9C%AF%E5%B9%B3%E5%8F%B0"><span class="toc-number">1.4.</span> <span class="toc-text">4、java技术平台</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81java%E4%BD%BF%E7%94%A8%E9%A2%86%E5%9F%9F"><span class="toc-number">1.5.</span> <span class="toc-text">5、java使用领域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81java%E4%B8%BB%E8%A6%81%E7%89%B9%E5%BE%81"><span class="toc-number">1.6.</span> <span class="toc-text">6、java主要特征</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81java%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E4%B8%8E%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">1.7.</span> <span class="toc-text">7、java程序运行机制与运行过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81java%E8%AF%AD%E8%A8%80%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="toc-number">1.8.</span> <span class="toc-text">8、java语言环境搭建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81helloworld"><span class="toc-number">1.9.</span> <span class="toc-text">9、helloworld</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E3%80%81%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95"><span class="toc-number">1.10.</span> <span class="toc-text">10、常见问题及解决办法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11%E3%80%81%E6%B3%A8%E9%87%8A"><span class="toc-number">1.11.</span> <span class="toc-text">11、注释</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12%E3%80%81%E8%89%AF%E5%A5%BD%E7%9A%84%E7%BC%96%E7%A8%8B%E4%B9%A0%E6%83%AF"><span class="toc-number">1.12.</span> <span class="toc-text">12、良好的编程习惯</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0%E9%A2%98%EF%BC%9A"><span class="toc-number">1.13.</span> <span class="toc-text">练习题：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.</span> <span class="toc-text">二、数据类型变量与运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.1.</span> <span class="toc-text">1、数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-number">2.2.</span> <span class="toc-text">2、标识符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E4%BF%9D%E7%95%99%E5%AD%97"><span class="toc-number">2.3.</span> <span class="toc-text">3、关键字与保留字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E5%8F%98%E9%87%8F"><span class="toc-number">2.4.</span> <span class="toc-text">4、变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.5.</span> <span class="toc-text">5、类型转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.6.</span> <span class="toc-text">6、 运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0%EF%BC%9A"><span class="toc-number">2.7.</span> <span class="toc-text">练习：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.</span> <span class="toc-text">三、流程控制语句</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84"><span class="toc-number">3.1.</span> <span class="toc-text">1、选择结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-if%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.1.1.</span> <span class="toc-text">1.if语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81switch%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.1.2.</span> <span class="toc-text">2、switch语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%83%E4%B9%A01-%EF%BC%9A"><span class="toc-number">3.1.3.</span> <span class="toc-text">练习1 ：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%83%E4%B9%A02-%EF%BC%9A"><span class="toc-number">3.1.4.</span> <span class="toc-text">练习2 ：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%83%E4%B9%A03%EF%BC%9A"><span class="toc-number">3.1.5.</span> <span class="toc-text">练习3：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#switch%E4%B8%8Eif%E6%AF%94%E8%BE%83"><span class="toc-number">3.1.6.</span> <span class="toc-text">switch与if比较</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84"><span class="toc-number">3.2.</span> <span class="toc-text">2、循环结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-gt-while%E5%BE%AA%E7%8E%AF"><span class="toc-number">3.2.1.</span> <span class="toc-text">1&gt;while循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-gt-do-while"><span class="toc-number">3.2.2.</span> <span class="toc-text">2&gt;do-while</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-gt-for%E5%BE%AA%E7%8E%AF"><span class="toc-number">3.2.3.</span> <span class="toc-text">3&gt;for循环</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E8%B7%B3%E8%BD%AC%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.3.</span> <span class="toc-text">3、跳转语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0%EF%BC%9A-1"><span class="toc-number">3.4.</span> <span class="toc-text">练习：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%95%B0%E7%BB%84"><span class="toc-number">4.</span> <span class="toc-text">四、数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E6%95%B0%E7%BB%84%E7%9A%84%E6%A6%82%E8%BF%B0"><span class="toc-number">4.1.</span> <span class="toc-text">1、数组的概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">4.2.</span> <span class="toc-text">2、一维数组的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90"><span class="toc-number">4.3.</span> <span class="toc-text">3、一维数组内存分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C"><span class="toc-number">4.4.</span> <span class="toc-text">4、一维数组操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0%EF%BC%9A-2"><span class="toc-number">4.4.1.</span> <span class="toc-text">练习：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%9A%E5%8D%81%E5%A4%A7%E5%86%85%E9%83%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-number">4.5.</span> <span class="toc-text">排序算法：十大内部排序算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">4.6.</span> <span class="toc-text">5、二维数组</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86%E5%88%9D%E5%A7%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.</span> <span class="toc-text">五、初步认识初始面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B"><span class="toc-number">5.1.</span> <span class="toc-text">1、面向对象和面向过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">5.2.</span> <span class="toc-text">2、 类和对象的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E7%B1%BB%E7%9A%84%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F%EF%BC%9A"><span class="toc-number">5.3.</span> <span class="toc-text">3、类的语法格式：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0%EF%BC%9A-3"><span class="toc-number">5.3.1.</span> <span class="toc-text">练习：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">5.4.</span> <span class="toc-text">4、成员变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">5.5.</span> <span class="toc-text">5、方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8%EF%BC%9A%E5%86%85%E5%AD%98%E8%A7%A3%E6%9E%90"><span class="toc-number">5.6.</span> <span class="toc-text">6、对象的创建和使用：内存解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0%EF%BC%9A-4"><span class="toc-number">5.6.1.</span> <span class="toc-text">练习：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84"><span class="toc-number">5.7.</span> <span class="toc-text">7、对象数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0%EF%BC%9A-5"><span class="toc-number">5.7.1.</span> <span class="toc-text">练习：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81%E5%8A%A8%E6%80%81%E5%8F%82%E6%95%B0"><span class="toc-number">5.8.</span> <span class="toc-text">8、动态参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92"><span class="toc-number">5.9.</span> <span class="toc-text">9、值传递和引用传递</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0%EF%BC%9A-6"><span class="toc-number">5.9.1.</span> <span class="toc-text">练习：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%B0%81%E8%A3%85"><span class="toc-number">6.</span> <span class="toc-text">六、封装</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E5%B0%81%E8%A3%85"><span class="toc-number">6.1.</span> <span class="toc-text">1、封装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0%EF%BC%9A-7"><span class="toc-number">6.1.1.</span> <span class="toc-text">练习：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">6.2.</span> <span class="toc-text">2、构造方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81this%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">6.3.</span> <span class="toc-text">3、this关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81-%E5%8C%85%E4%B8%8Eimport"><span class="toc-number">6.4.</span> <span class="toc-text">4、 包与import</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0%EF%BC%9A-8"><span class="toc-number">6.4.1.</span> <span class="toc-text">练习：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E7%BB%A7%E6%89%BF"><span class="toc-number">7.</span> <span class="toc-text">七、继承</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E7%BB%A7%E6%89%BF%E7%9A%84%E5%90%AB%E4%B9%89"><span class="toc-number">7.1.</span> <span class="toc-text">1、继承的含义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0%EF%BC%9A-9"><span class="toc-number">7.1.1.</span> <span class="toc-text">练习：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81super"><span class="toc-number">7.2.</span> <span class="toc-text">2、super</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99"><span class="toc-number">7.3.</span> <span class="toc-text">3、方法重写</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0"><span class="toc-number">7.3.1.</span> <span class="toc-text">练习:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">7.4.</span> <span class="toc-text">4、访问修饰符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%BF%87%E7%A8%8B"><span class="toc-number">7.5.</span> <span class="toc-text">5、对象实例化过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">7.6.</span> <span class="toc-text">6、抽象类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="toc-number">7.7.</span> <span class="toc-text">7、抽象方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81final"><span class="toc-number">7.8.</span> <span class="toc-text">8、final</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0%EF%BC%9A-10"><span class="toc-number">7.8.1.</span> <span class="toc-text">练习：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E5%A4%9A%E6%80%81"><span class="toc-number">8.</span> <span class="toc-text">八、多态</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%A4%9A%E6%80%81"><span class="toc-number">8.1.</span> <span class="toc-text">1.多态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81Object%E7%B1%BB"><span class="toc-number">8.2.</span> <span class="toc-text">2、Object类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81-x3D-x3D-%E4%B8%8Eequals%E6%96%B9%E6%B3%95"><span class="toc-number">8.2.1.</span> <span class="toc-text">1、&#x3D;&#x3D; 与equals方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0%EF%BC%9A-11"><span class="toc-number">8.2.1.1.</span> <span class="toc-text">练习：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81toString-%E6%96%B9%E6%B3%95"><span class="toc-number">8.2.2.</span> <span class="toc-text">2、toString()方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">8.2.3.</span> <span class="toc-text">重载和重写的区别：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0%EF%BC%9A-12"><span class="toc-number">8.2.4.</span> <span class="toc-text">练习：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81static%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">8.3.</span> <span class="toc-text">3、static关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">8.4.</span> <span class="toc-text">4、代码块</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E6%8E%A5%E5%8F%A3"><span class="toc-number">9.</span> <span class="toc-text">九、接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0%EF%BC%9A-13"><span class="toc-number">9.1.</span> <span class="toc-text">练习：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E3%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">10.</span> <span class="toc-text">十、内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">10.1.</span> <span class="toc-text">1、成员内部类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">10.2.</span> <span class="toc-text">2、局部内部类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">10.3.</span> <span class="toc-text">3、匿名内部类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%B8%80%E3%80%81%E5%BC%82%E5%B8%B8"><span class="toc-number">11.</span> <span class="toc-text">十一、异常</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0%EF%BC%9A-14"><span class="toc-number">11.1.</span> <span class="toc-text">练习：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%BA%8C%E3%80%81%E5%B8%B8%E7%94%A8%E7%B1%BB"><span class="toc-number">12.</span> <span class="toc-text">十二、常用类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%92%8C%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">12.1.</span> <span class="toc-text">1、基本数据类和引用数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0%EF%BC%9A-15"><span class="toc-number">12.1.1.</span> <span class="toc-text">练习：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81String%E7%B1%BB"><span class="toc-number">12.2.</span> <span class="toc-text">2、String类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81StringBuffer%E7%B1%BB"><span class="toc-number">12.3.</span> <span class="toc-text">3、StringBuffer类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81StringBuilder%E7%B1%BB"><span class="toc-number">12.4.</span> <span class="toc-text">4、StringBuilder类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0%EF%BC%9A-16"><span class="toc-number">12.4.1.</span> <span class="toc-text">练习：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E6%97%A5%E6%9C%9F%E7%B1%BB%E5%9E%8B"><span class="toc-number">12.5.</span> <span class="toc-text">5、日期类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-gt-System%E7%B1%BB"><span class="toc-number">12.5.1.</span> <span class="toc-text">1&gt;System类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-gt-java-util-Date%E7%B1%BB"><span class="toc-number">12.5.2.</span> <span class="toc-text">2&gt;java.util.Date类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-gt-SimpleDateFormat%E7%B1%BB"><span class="toc-number">12.5.3.</span> <span class="toc-text">3&gt;SimpleDateFormat类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-gt-java-util-Calendar-%E6%97%A5%E5%8E%86-%E7%B1%BB"><span class="toc-number">12.5.4.</span> <span class="toc-text">4&gt; java.util.Calendar(日历)类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81Math%E7%B1%BB"><span class="toc-number">12.6.</span> <span class="toc-text">6、Math类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81BigInteger%E4%B8%8EBigDecimal"><span class="toc-number">12.7.</span> <span class="toc-text">7、BigInteger与BigDecimal</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BigDecimal%E7%B1%BB"><span class="toc-number">12.7.1.</span> <span class="toc-text">BigDecimal类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81Comparable%E6%8E%A5%E5%8F%A3%E4%B8%8ECompator%E6%8E%A5%E5%8F%A3"><span class="toc-number">12.8.</span> <span class="toc-text">8、Comparable接口与Compator接口</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%B8%89%E3%80%81%E7%BA%BF%E7%A8%8B"><span class="toc-number">13.</span> <span class="toc-text">十三、线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">13.1.</span> <span class="toc-text">1、基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="toc-number">13.2.</span> <span class="toc-text">2、 线程的创建和使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="toc-number">13.3.</span> <span class="toc-text">3、线程状态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-gt-join%E6%96%B9%E6%B3%95"><span class="toc-number">13.3.1.</span> <span class="toc-text">1&gt;join方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-gt-sleep%E6%96%B9%E6%B3%95"><span class="toc-number">13.3.2.</span> <span class="toc-text">2&gt; sleep方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-gt-Interrupt-%E7%BA%BF%E7%A8%8B%E8%A2%AB%E4%B8%AD%E6%96%AD"><span class="toc-number">13.3.3.</span> <span class="toc-text">3&gt;Interrupt 线程被中断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-gt-yield"><span class="toc-number">13.3.4.</span> <span class="toc-text">4&gt; yield</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-gt-join%E6%96%B9%E6%B3%95"><span class="toc-number">13.3.5.</span> <span class="toc-text">5&gt;join方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-gt-%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">13.3.6.</span> <span class="toc-text">6&gt;线程的优先级</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E5%90%8C%E6%AD%A5%E5%9F%9F%E6%AD%BB%E9%94%81"><span class="toc-number">13.4.</span> <span class="toc-text">4、同步域死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0%EF%BC%9A-17"><span class="toc-number">13.4.1.</span> <span class="toc-text">练习：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="toc-number">13.5.</span> <span class="toc-text">5、线程之间的通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E5%85%B6%E4%BB%96%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%96%B9%E5%BC%8F"><span class="toc-number">13.6.</span> <span class="toc-text">6、其他创建线程方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-gt-%E5%AE%9E%E7%8E%B0Callable%E6%8E%A5%E5%8F%A3"><span class="toc-number">13.6.1.</span> <span class="toc-text">1&gt; 实现Callable接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-gt-%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">13.6.2.</span> <span class="toc-text">2&gt;线程池:</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E5%9B%9B%E3%80%81%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%B3%A8%E8%A7%A3"><span class="toc-number">14.</span> <span class="toc-text">十四、枚举和注解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E6%9E%9A%E4%B8%BE"><span class="toc-number">14.1.</span> <span class="toc-text">1、枚举</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E6%B3%A8%E8%A7%A3"><span class="toc-number">14.2.</span> <span class="toc-text">2、注解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%BA%94%E3%80%81%E9%9B%86%E5%90%88"><span class="toc-number">15.</span> <span class="toc-text">十五、集合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81Collection%E6%8E%A5%E5%8F%A3"><span class="toc-number">15.1.</span> <span class="toc-text">1、Collection接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">15.2.</span> <span class="toc-text">2、迭代器的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81List%E6%8E%A5%E5%8F%A3%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3"><span class="toc-number">15.3.</span> <span class="toc-text">3、List接口常用接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81Set%E6%8E%A5%E5%8F%A3"><span class="toc-number">15.4.</span> <span class="toc-text">4、Set接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81Map%E6%8E%A5%E5%8F%A3"><span class="toc-number">15.5.</span> <span class="toc-text">5、Map接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E3%80%81Collections%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">15.6.</span> <span class="toc-text">6.、Collections工具类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0-1"><span class="toc-number">15.7.</span> <span class="toc-text">练习:</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E5%85%AD%E3%80%81%E6%B3%9B%E5%9E%8B"><span class="toc-number">16.</span> <span class="toc-text">十六、泛型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%B8%83%E3%80%81%E6%96%87%E4%BB%B6%E4%B8%8EIO"><span class="toc-number">17.</span> <span class="toc-text">十七、文件与IO</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81File%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">17.1.</span> <span class="toc-text">1、File类的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81IO%E6%B5%81"><span class="toc-number">17.2.</span> <span class="toc-text">2、IO流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81InputStream%E5%92%8CReader"><span class="toc-number">17.3.</span> <span class="toc-text">3、InputStream和Reader</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#InputStream%E6%96%B9%E6%B3%95%E4%BB%8B%E7%BB%8D%EF%BC%9A"><span class="toc-number">17.3.1.</span> <span class="toc-text">InputStream方法介绍：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reader%E6%96%B9%E6%B3%95%E4%BB%8B%E7%BB%8D%EF%BC%9A"><span class="toc-number">17.3.2.</span> <span class="toc-text">Reader方法介绍：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81OutputStream%E5%92%8CWriter"><span class="toc-number">17.4.</span> <span class="toc-text">4、OutputStream和Writer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0%EF%BC%9A-18"><span class="toc-number">17.4.1.</span> <span class="toc-text">练习：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E7%BC%93%E5%86%B2%E6%B5%81"><span class="toc-number">17.5.</span> <span class="toc-text">5、缓冲流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E8%BD%AC%E6%8D%A2%E6%B5%81"><span class="toc-number">17.6.</span> <span class="toc-text">6、转换流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E3%80%81%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-number">17.7.</span> <span class="toc-text">7、标准输入、输出流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81%E5%AF%B9%E8%B1%A1%E6%B5%81"><span class="toc-number">17.8.</span> <span class="toc-text">8、对象流</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E5%85%AB%E3%80%81%E5%8F%8D%E5%B0%84"><span class="toc-number">18.</span> <span class="toc-text">十八、反射</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81Class%E7%B1%BB"><span class="toc-number">18.1.</span> <span class="toc-text">1、Class类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E4%B8%8EClassLoader%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">18.2.</span> <span class="toc-text">2、类的加载与ClassLoader的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E5%88%9B%E5%BB%BA%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">18.3.</span> <span class="toc-text">3、创建运行时类的对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E8%8E%B7%E5%8F%96%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E5%AE%8C%E6%95%B4%E7%BB%93%E6%9E%84"><span class="toc-number">18.4.</span> <span class="toc-text">4、获取运行时类的完整结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%85%A8%E9%83%A8%E6%8E%A5%E5%8F%A3"><span class="toc-number">18.4.1.</span> <span class="toc-text">1.实现的全部接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%89%80%E7%BB%A7%E6%89%BF%E7%9A%84%E7%88%B6%E7%B1%BB"><span class="toc-number">18.4.2.</span> <span class="toc-text">2.所继承的父类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%85%A8%E9%83%A8%E7%9A%84%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">18.4.3.</span> <span class="toc-text">3.全部的构造器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%85%A8%E9%83%A8%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">18.4.4.</span> <span class="toc-text">4.全部的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%85%A8%E9%83%A8%E7%9A%84Field"><span class="toc-number">18.4.5.</span> <span class="toc-text">5.全部的Field</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-Annotation%E7%9B%B8%E5%85%B3"><span class="toc-number">18.4.6.</span> <span class="toc-text">6.Annotation相关</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%B3%9B%E5%9E%8B%E7%9B%B8%E5%85%B3"><span class="toc-number">18.4.7.</span> <span class="toc-text">7.泛型相关</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E7%B1%BB%E6%89%80%E5%9C%A8%E7%9A%84%E5%8C%85"><span class="toc-number">18.4.8.</span> <span class="toc-text">8.类所在的包</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">18.5.</span> <span class="toc-text">5、动态代理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%B9%9D%E3%80%81%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-number">19.</span> <span class="toc-text">十九、网络编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%9A"><span class="toc-number">19.1.</span> <span class="toc-text">TCP程序设计：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UDP"><span class="toc-number">19.2.</span> <span class="toc-text">UDP:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP"><span class="toc-number">19.3.</span> <span class="toc-text">HTTP:</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8D%81%E3%80%81JDK8%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">20.</span> <span class="toc-text">二十、JDK8新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E6%97%A5%E6%9C%9F%E7%B1%BB%E5%9E%8B"><span class="toc-number">20.1.</span> <span class="toc-text">1、日期类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">20.2.</span> <span class="toc-text">2、Lambda表达式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E4%B8%80%E3%80%81JSON"><span class="toc-number">21.</span> <span class="toc-text">二一、JSON</span></a></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('/img/%E5%8D%9A%E5%AE%A28.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 陈天在睡觉</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>