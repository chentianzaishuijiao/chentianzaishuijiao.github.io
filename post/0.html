<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>JAVA面试题 | 陈天在睡觉</title><meta name="author" content="陈天在睡觉"><meta name="copyright" content="陈天在睡觉"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="1 JDK与JRE的区别是什么？它们各自有什么作用？12345678区别：JDK 是 Java Development Kit 缩写，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。JRE 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JV">
<meta property="og:type" content="article">
<meta property="og:title" content="JAVA面试题">
<meta property="og:url" content="http://example.com/post/0.html">
<meta property="og:site_name" content="陈天在睡觉">
<meta property="og:description" content="1 JDK与JRE的区别是什么？它们各自有什么作用？12345678区别：JDK 是 Java Development Kit 缩写，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。JRE 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JV">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/%E5%8D%9A%E5%AE%A22.png">
<meta property="article:published_time" content="2023-01-27T16:00:00.000Z">
<meta property="article:modified_time" content="2023-01-28T06:55:23.072Z">
<meta property="article:author" content="陈天在睡觉">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/%E5%8D%9A%E5%AE%A22.png"><link rel="shortcut icon" href="/img/%E6%9F%BF%E5%AD%90.png"><link rel="canonical" href="http://example.com/post/0"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 陈天在睡觉","link":"链接: ","source":"来源: 陈天在睡觉","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JAVA面试题',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2023-01-28 14:55:23'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/font.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E5%A4%B4%E5%83%8F.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/%E5%8D%9A%E5%AE%A22.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">陈天在睡觉</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">JAVA面试题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-01-27T16:00:00.000Z" title="发表于 2023-01-28 00:00:00">2023-01-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-28T06:55:23.072Z" title="更新于 2023-01-28 14:55:23">2023-01-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/JAVA/">JAVA</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>28分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="JAVA面试题"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="1-JDK与JRE的区别是什么？它们各自有什么作用？"><a href="#1-JDK与JRE的区别是什么？它们各自有什么作用？" class="headerlink" title="1 JDK与JRE的区别是什么？它们各自有什么作用？"></a>1 JDK与JRE的区别是什么？它们各自有什么作用？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">区别：</span><br><span class="line">JDK 是 Java Development Kit 缩写，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。</span><br><span class="line"></span><br><span class="line">JRE 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序。</span><br><span class="line"></span><br><span class="line">各自作用：</span><br><span class="line">JDK提供了编译、运行Java程序所需的各种工具和资源，包括Java编译器、Java运行环境JRE，以及常用的Java基础类库等，是整个JAVA的核心。</span><br><span class="line">JRE是运行基于Java语言编写的程序所不可缺少的运行环境，用于解释执行Java的字节码文件。</span><br></pre></td></tr></table></figure>

<h3 id="2-环境变量PATH的作用是什么？"><a href="#2-环境变量PATH的作用是什么？" class="headerlink" title="2 环境变量PATH的作用是什么？"></a>2 环境变量PATH的作用是什么？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Path环境变量是Windows系统的变量机制，它的作用是在系统执行某一指令时指引操作系统根据它所指示的路径在电脑中寻找该指令，告诉windows操作系统去哪里找这个命令文件，如果没有找到，则运行会报错。Java只是配置环境变量时用了一下Path变量而已。</span><br></pre></td></tr></table></figure>

<h3 id="3-环境变量CLASSPATH的作用是什么？"><a href="#3-环境变量CLASSPATH的作用是什么？" class="headerlink" title="3 环境变量CLASSPATH的作用是什么？"></a>3 环境变量CLASSPATH的作用是什么？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CLASSPATH环境变量作用是指定类搜索路径，要使用已经编写好的类，前提当然是能够找到它们，JVM就是通过CLASSPTH来寻找类的。</span><br><span class="line">只有类在ClassPath中，java命令才能找到它，并解释它。</span><br></pre></td></tr></table></figure>

<h3 id="4-什么是JVM，其工作原理是什么样的？"><a href="#4-什么是JVM，其工作原理是什么样的？" class="headerlink" title="4 什么是JVM，其工作原理是什么样的？"></a>4 什么是JVM，其工作原理是什么样的？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。</span><br><span class="line">工作原理：Java源文件在通过编译器后被编译成相应的 .Class 文件（字节码文件），.Class 文件又被JVM中的解释器编译成机器码在不同的操作系统（Windows、Linux、Mac）上运行。每种操作系统的解释器是不同的，但基于解释器实现的虚拟机是相同的，这也是Java能够跨平台的原因。</span><br></pre></td></tr></table></figure>

<h3 id="5-如何理解Java中的装箱和拆箱？"><a href="#5-如何理解Java中的装箱和拆箱？" class="headerlink" title="5 如何理解Java中的装箱和拆箱？"></a>5 如何理解Java中的装箱和拆箱？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">装箱就是 自动将基本数据类型转换为包装器类型。</span><br><span class="line">拆箱就是 自动将包装器类型转换为基本数据类型。</span><br></pre></td></tr></table></figure>

<h3 id="6-Java中equals方法和-x3D-x3D-的区别是什么？"><a href="#6-Java中equals方法和-x3D-x3D-的区别是什么？" class="headerlink" title="6 Java中equals方法和&#x3D;&#x3D;的区别是什么？"></a>6 Java中equals方法和&#x3D;&#x3D;的区别是什么？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">对于基本类型，==比较的是值；</span><br><span class="line">对于引用类型，==比较的是地址；</span><br><span class="line">equals不能用于基本类型的比较；</span><br><span class="line">如果没有重写equals，equals就相当于==；</span><br><span class="line">如果重写了equals方法，equals比较的是对象的内容；</span><br></pre></td></tr></table></figure>

<h3 id="7-类和对象有什么区别？"><a href="#7-类和对象有什么区别？" class="headerlink" title="7 类和对象有什么区别？"></a>7 类和对象有什么区别？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1，类是一个抽象的概念，它不存在于现实中的时间/空间里，类只是为所有的对象定义了抽象的属性与行为。就好像“Person（人）”这个类，它虽然可以包含很多个体，但它本身不存在于现实世界上。</span><br><span class="line"></span><br><span class="line">2，对象是类的一个具体。它是一个实实在在存在的东西。</span><br><span class="line"></span><br><span class="line">3，类是一个静态的概念，类本身不携带任何数据。当没有为类创建任何对象时，类本身不存在于内存空间中。</span><br><span class="line"></span><br><span class="line">4，对象是一个动态的概念。每一个对象都存在着有别于其它对象的属于自己的独特的属性和行为。对象的属性可以随着它自己的行为而发生改变。</span><br></pre></td></tr></table></figure>

<h3 id="8-Java中成员变量的特点有哪些？"><a href="#8-Java中成员变量的特点有哪些？" class="headerlink" title="8 Java中成员变量的特点有哪些？"></a>8 Java中成员变量的特点有哪些？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">成员变量处在类中方法外</span><br><span class="line">成员变量随着对象的创建而创建，随对象的消失而消失</span><br><span class="line">成员变量由类的对象进行调用</span><br><span class="line">成员变量存储在堆内存中</span><br><span class="line">成员变量具有默认的初始值</span><br></pre></td></tr></table></figure>

<h3 id="9-Java中静态变量的特点有哪些？"><a href="#9-Java中静态变量的特点有哪些？" class="headerlink" title="9 Java中静态变量的特点有哪些？"></a>9 Java中静态变量的特点有哪些？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">静态变量用static修饰，处于成员变量的位置</span><br><span class="line">静态变量随着类的加载而存在，随着类的执行结束而消失</span><br><span class="line">静态变量存储在堆内存中（JDK8以前存储在方法区中）</span><br><span class="line">静态成员的存储位置</span><br><span class="line">静态变量可由类或者类的对象进行调用</span><br></pre></td></tr></table></figure>

<h3 id="10-Java中子类的构造函数如何为父类传递参数？"><a href="#10-Java中子类的构造函数如何为父类传递参数？" class="headerlink" title="10 Java中子类的构造函数如何为父类传递参数？"></a>10 Java中子类的构造函数如何为父类传递参数？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">显式： 构造方法的第一行super(n..)  n 个参数</span><br><span class="line">隐式： 子对象构造方法会默认调用父类的无参构造方法，即super(). 所以父类中如果没有无参构造，则子类必须显式的调用父类的有参构造方法</span><br></pre></td></tr></table></figure>

<h3 id="11-this与super的区别？"><a href="#11-this与super的区别？" class="headerlink" title="11 this与super的区别？"></a>11 this与super的区别？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. this是当前对象的引用，当前对象即调用实例方法的对象，super相当于是子类对象中从父类继承下来部分成员的引用。</span><br><span class="line"> </span><br><span class="line">2. 在非静态成员方法中，this用来访问本类的方法和属性，super用来访问父类继承下来的方法和属性。</span><br><span class="line"> </span><br><span class="line">3. 在构造方法中：this()用于调用本类构造方法，super()用于调用父类构造方法，两种调用不能同时在构造方法中出现。</span><br><span class="line"> </span><br><span class="line">4. 构造方法中一定会存在super()的调用（调用默认或者无参的时候），没有写编译器也会增加，但是this()不写则没有。</span><br></pre></td></tr></table></figure>

<h3 id="12-接口和抽象类的区别？"><a href="#12-接口和抽象类的区别？" class="headerlink" title="12 接口和抽象类的区别？"></a>12 接口和抽象类的区别？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">接口是行为的抽象，是一种行为的规范，接口是like a 的关系；抽象是对类的抽象，是一种模板设计，抽象类是is a 的关系。</span><br><span class="line">接口没有构造方法，而抽象类有构造方法，其方法一般给子类使用</span><br><span class="line">接口只有定义，不能有方法的实现，java 1.8中可以定义default方法体，而抽象类可以有定义与实现，方法可在抽象类中实现。</span><br><span class="line">抽象体现出了继承关系，继承只能单继承。接口提现出来了实现的关系，实现可以多实现。接口强调特定功能的实现，而抽象类强调所属关系。</span><br><span class="line">接口成员变量默认为public static final，必须赋初值，不能被修改；其所有的成员方法都是public abstract的。抽象类中成员变量默认default，可在子类中被重新定义，也可被重新赋值；抽象方法被abstract修饰，不能被private、static、synchronized和native等修饰，必须以分号结尾，不带花括号。 </span><br></pre></td></tr></table></figure>

<h3 id="13-字符串字面量是否自动生成一个String对象？"><a href="#13-字符串字面量是否自动生成一个String对象？" class="headerlink" title="13 字符串字面量是否自动生成一个String对象？"></a>13 字符串字面量是否自动生成一个String对象？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">是</span><br></pre></td></tr></table></figure>

<h3 id="14-字符串对象池的作用是什么？"><a href="#14-字符串对象池的作用是什么？" class="headerlink" title="14 字符串对象池的作用是什么？"></a>14 字符串对象池的作用是什么？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象池的存在是为了避免频繁的创建和销毁对象而影响系统性能</span><br></pre></td></tr></table></figure>

<h3 id="15-StringBuffer和StringBuilder的区别以及存在的作用？"><a href="#15-StringBuffer和StringBuilder的区别以及存在的作用？" class="headerlink" title="15 StringBuffer和StringBuilder的区别以及存在的作用？"></a>15 StringBuffer和StringBuilder的区别以及存在的作用？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、StringBuffer 与 StringBuilder 中的方法和功能完全是等价的，</span><br><span class="line"></span><br><span class="line">2、只是StringBuffer 中的方法大都采用了 synchronized 关键字进行修饰，因此是线程安全的，而 StringBuilder 没有这个修饰，可以被认为是线程不安全的。 </span><br><span class="line"></span><br><span class="line">3、在单线程程序下，StringBuilder效率更快，因为它不需要加锁，不具备多线程安全而StringBuffer则每次都需要判断锁，效率相对更低</span><br></pre></td></tr></table></figure>

<p>16 简述数组的内存原理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组是存放在连续内存空间上的相同类型数据的集合</span><br></pre></td></tr></table></figure>

<h3 id="17-迭代器是什么？"><a href="#17-迭代器是什么？" class="headerlink" title="17 迭代器是什么？"></a>17 迭代器是什么？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">迭代器（Iterator）是一个对象，它的工作是遍历并选择序列中的对象，它提供了一种访问一个容器（container）对象中的各个元素，而不必暴露该对象内部细节的方法。通过迭代器，开发人员不需要了解容器底层的结构，就可以实现对容器的遍历。</span><br></pre></td></tr></table></figure>

<h3 id="18-比较器是什么？"><a href="#18-比较器是什么？" class="headerlink" title="18 比较器是什么？"></a>18 比较器是什么？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">比较器是java中一个接口，该接口用于对用户定义类的对象进行排序和比较。</span><br></pre></td></tr></table></figure>

<h3 id="19-Vector、ArrayList和LinkedList的区别？"><a href="#19-Vector、ArrayList和LinkedList的区别？" class="headerlink" title="19 Vector、ArrayList和LinkedList的区别？"></a>19 Vector、ArrayList和LinkedList的区别？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ArrayList:作为List接口的主要实现类，线程不安全的，执行效率高，底层使用Object[]存储</span><br><span class="line">LinkedList:对于频繁的插入和删除操作，使用此类比ArrayList效率高，底层使用双向链表存储</span><br><span class="line">Vector:作为List接口的古老实现类，线程安全的，执行效率低，底层使用Object[]存储</span><br><span class="line"></span><br><span class="line">ArrayList底层通过动态数组实现，而LinkedList底层通过双向链表实现</span><br><span class="line">ArrayList根据索引查找元素的效率比较高，但是插入、删除数据时性能比较低，需要将待插入或删除元素之后的元素往后或往前移动</span><br><span class="line">LinkedList查询元素的效率比较低，需要从头部或尾部开始查找，挨个遍历每一个元素直到找到所需元素，但是插入、删除元素的效率比较高</span><br><span class="line"></span><br><span class="line">Vector是线程安全的，而ArrayList是线程不安全的，Vector类中的方法通过synchronized修饰实现线程的同步，但实现同步需要很高的开销，这也导致了访问Vector比ArrayList慢</span><br><span class="line">ArrayList和Vector都是采用连续的内存空间存储元素，但是当空间不足的时候，两个类扩容的方式是不同的。（ArrayList每次存储时会检查空间大小，不够时会扩充为原来的1.5倍，Vector会扩充为原来空间的2倍</span><br></pre></td></tr></table></figure>

<h3 id="20-HashMap、HashTable和TreeMap的区别？"><a href="#20-HashMap、HashTable和TreeMap的区别？" class="headerlink" title="20 HashMap、HashTable和TreeMap的区别？"></a>20 HashMap、HashTable和TreeMap的区别？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、HashTable的方法是同步的，HashMap未经同步，所以在多线程场合要手动同步HashMap这个区别就像Vector和ArrayList一样。</span><br><span class="line">2、HashTable不允许null值，key和value都不可以,HashMap允许null值，key和value都可以。</span><br><span class="line">3、HashTable使用Enumeration，HashMap使用Iterator。 </span><br><span class="line">4、HashTable使用Enumeration，HashMap使用Iterator</span><br><span class="line">5、哈希值的使用不同，HashTable直接使用对象的hashCode。</span><br></pre></td></tr></table></figure>

<h3 id="21-什么样的数据集合可以使用foreach循环？"><a href="#21-什么样的数据集合可以使用foreach循环？" class="headerlink" title="21 什么样的数据集合可以使用foreach循环？"></a>21 什么样的数据集合可以使用foreach循环？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组或者实现了Iterable接口的类实例</span><br></pre></td></tr></table></figure>

<h3 id="22-字节流与字符流的区别？"><a href="#22-字节流与字符流的区别？" class="headerlink" title="22 字节流与字符流的区别？"></a>22 字节流与字符流的区别？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、字节流操作的基本单元为字节；字符流操作的基本单元为Unicode码元。</span><br><span class="line">2、字节流默认不使用缓冲区；字符流使用缓冲区。</span><br><span class="line">3、字节流通常用于处理二进制数据，实际上它可以处理任意类型的数据，但它不支持直接写入或读取Unicode码元；字符流通常处理文本数据，它支持写入及读取Unicode码元。</span><br></pre></td></tr></table></figure>

<h3 id="23-字节流的处理方式有哪些？"><a href="#23-字节流的处理方式有哪些？" class="headerlink" title="23 字节流的处理方式有哪些？"></a>23 字节流的处理方式有哪些？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InputStream是所有字节输入流的超类</span><br><span class="line">OutputStream是所有字节输出流的超类</span><br></pre></td></tr></table></figure>

<h3 id="24-字符流的处理方式有哪些？"><a href="#24-字符流的处理方式有哪些？" class="headerlink" title="24 字符流的处理方式有哪些？"></a>24 字符流的处理方式有哪些？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Reader是所有读取字符串输入流的超类</span><br><span class="line">writer是所有输出字符串的超类</span><br></pre></td></tr></table></figure>

<h3 id="25-什么是序列化？"><a href="#25-什么是序列化？" class="headerlink" title="25 什么是序列化？"></a>25 什么是序列化？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决在对对象流进行读写操作时所引发的问题</span><br></pre></td></tr></table></figure>

<h3 id="26-解释进程和线程的区别"><a href="#26-解释进程和线程的区别" class="headerlink" title="26 解释进程和线程的区别"></a>26 解释进程和线程的区别</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、进程是系统分配资源的最小单位，线程是cpu调度的最小单位</span><br><span class="line">2、进程拥有独立的地址空间，一个进程包含多个线程，多个线程共享地址空间</span><br><span class="line">3、在java中一个进程对应一个JVM对象实例，多个线程运行在jvm中</span><br></pre></td></tr></table></figure>

<h3 id="27-实现线程的方式有哪些？"><a href="#27-实现线程的方式有哪些？" class="headerlink" title="27 实现线程的方式有哪些？"></a>27 实现线程的方式有哪些？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、继承Thread类，重写run()方法</span><br><span class="line">2、实现Runnable接口，重写run()方法</span><br><span class="line">3、实现Callable接口，该接口中的call方法可以在线程执行结束时产生一个返回值</span><br></pre></td></tr></table></figure>

<h3 id="28-如何使用synchronized来让线程同步？"><a href="#28-如何使用synchronized来让线程同步？" class="headerlink" title="28 如何使用synchronized来让线程同步？"></a>28 如何使用synchronized来让线程同步？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">synchronized方法控制&quot;对象&quot;的访问，每一个对象对应一把锁，每个synchronized方法都必须获得调用该方法的对象的锁才能执行，否则线程会阻塞，方法一旦执行，就独占该锁，直到该方法返回才释放锁，后面被阻塞的线程才能获得这个锁，继续执行</span><br></pre></td></tr></table></figure>

<h3 id="29-为什么会有线程安全问题？"><a href="#29-为什么会有线程安全问题？" class="headerlink" title="29 为什么会有线程安全问题？"></a>29 为什么会有线程安全问题？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、多个线程之间操作同一个数据，至少有一个线程修改这个数据</span><br><span class="line">2、一条语句对应多个指令，线程调度可以发生任何时刻，所以线程调度不确定性导致指令顺序不确定</span><br></pre></td></tr></table></figure>

<h3 id="30-什么是锁并解释死锁的原因？"><a href="#30-什么是锁并解释死锁的原因？" class="headerlink" title="30 什么是锁并解释死锁的原因？"></a>30 什么是锁并解释死锁的原因？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">锁是用来控制多个线程访问共享资源的方式，一般来说，一个锁能够防止多个线程同时访问共享资源。</span><br><span class="line"></span><br><span class="line">死锁的原因：</span><br><span class="line">1、竞争资源</span><br><span class="line">2、进程推进顺序不当</span><br></pre></td></tr></table></figure>

<h3 id="31-反射的原理是什么？"><a href="#31-反射的原理是什么？" class="headerlink" title="31 反射的原理是什么？"></a>31 反射的原理是什么？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过class、constructor、field、method四个方法获取一个类的各个组成部分</span><br></pre></td></tr></table></figure>

<h3 id="32-Class类的含义和作用是什么？"><a href="#32-Class类的含义和作用是什么？" class="headerlink" title="32 Class类的含义和作用是什么？"></a>32 Class类的含义和作用是什么？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class的意思为“类”，是java中的一个类，是定义一个特定类的实现，存在于java.lang包中，它的构造函数是私有的，由JVM创建Class对象，可以通过getClass()方法获取到Class对象。</span><br></pre></td></tr></table></figure>

<h3 id="33-创建对象有哪几种形式？"><a href="#33-创建对象有哪几种形式？" class="headerlink" title="33 创建对象有哪几种形式？"></a>33 创建对象有哪几种形式？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、new关键字   </span><br><span class="line">2、Class.newInstance  </span><br><span class="line">3、Constructor.newInstance </span><br><span class="line">4、Clone方法 </span><br><span class="line">5、反序列化</span><br></pre></td></tr></table></figure>

<h3 id="34-如何利用反射机制来访问一个类的私有成员？"><a href="#34-如何利用反射机制来访问一个类的私有成员？" class="headerlink" title="34 如何利用反射机制来访问一个类的私有成员？"></a>34 如何利用反射机制来访问一个类的私有成员？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用setAccessible(boolean flag)方法</span><br></pre></td></tr></table></figure>

<h3 id="35-什么是TCP什么是UDP？"><a href="#35-什么是TCP什么是UDP？" class="headerlink" title="35 什么是TCP什么是UDP？"></a>35 什么是TCP什么是UDP？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TCP：传输控制协议，是一种面向连接的、可靠的、基于字节流的传输层通信协议。</span><br><span class="line">UDP：用户数据报协议，是一种面向无连接，不可靠、以数据报文段的形式传输的传输层通信协议。</span><br></pre></td></tr></table></figure>

<h3 id="36-简述七层网络模型架构"><a href="#36-简述七层网络模型架构" class="headerlink" title="36 简述七层网络模型架构"></a>36 简述七层网络模型架构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">应用层	确定通信对象，提供访问网络服务的接口	</span><br><span class="line">表示层	负责数据的编码、转化（界面与二进制数据转换，高级语言与机器语言的转换）数据压缩、解压，加密、解密。根据不同应用目的处理为不同的格式，表现出来就是我们看到的各种各样的文件扩展名。</span><br><span class="line">会话层	负责建立、维护、控制会话单工(Simplex)、半双工(Half duplex)、全双工(Full duplex)三种通信模式的服务</span><br><span class="line">传输层	负责分割、组合数据，实现端到端的逻辑连接三次握手(Three-way handshake)，面向连接(Connection-Oriented)或非面向连接(Connectionless-Oriented)的服务，流控(Flow control)等都发生在这一层。是第一个端到端，即主机到主机的层次。</span><br><span class="line">网络层	负责管理网络地址，定位设备，决定路由</span><br><span class="line">数据链路层	负责准备物理传输，CRC校验，错误通知，网络拓扑，流控等</span><br><span class="line">物理层	就是实实在在的物理链路，负责将数据以比特流的方式发送、接收</span><br></pre></td></tr></table></figure>

<h3 id="37-简述对TCP-x2F-IP协议的理解"><a href="#37-简述对TCP-x2F-IP协议的理解" class="headerlink" title="37 简述对TCP&#x2F;IP协议的理解"></a>37 简述对TCP&#x2F;IP协议的理解</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TCP/IP 是IP、TCP、HTTP等协议的集合。协议就是计算机与计算机之间通过网络实现通信时事先达成的一种约定。两台计算机之间必须能够支持相同的的协议，并循序相同的协议进行处理，才能实现相互通讯</span><br></pre></td></tr></table></figure>

<h3 id="38-什么是IP？"><a href="#38-什么是IP？" class="headerlink" title="38 什么是IP？"></a>38 什么是IP？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IP地址是IP协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。</span><br><span class="line">IP协议是为计算机网络相互连接进行通信而设计的协议</span><br></pre></td></tr></table></figure>

<h3 id="39-什么是NAT？"><a href="#39-什么是NAT？" class="headerlink" title="39 什么是NAT？"></a>39 什么是NAT？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NAT是一种地址交换技术，它可以将IP数据报文头中的IP地址转换为另一个IP地址，并通过转换端口号达到地址重用的目的。NAT作为一种缓解IPv4公网地址枯竭的过渡技术，由于实现简单，得到了广泛应用。</span><br></pre></td></tr></table></figure>

<h3 id="40-什么是DNS？"><a href="#40-什么是DNS？" class="headerlink" title="40 什么是DNS？"></a>40 什么是DNS？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将域名解析为IP地址，输入网址后，首先会查询本地DNS缓存，无果后再查询本地DNS服务器。</span><br></pre></td></tr></table></figure>

<h3 id="41-什么是DHCP？"><a href="#41-什么是DHCP？" class="headerlink" title="41 什么是DHCP？"></a>41 什么是DHCP？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">动态分配IP地址协议，DHCP客户端从DHCP服务器获得DHCP服务器的IP地址、DNS服务器的IP地址、默认网关的IP地址等。</span><br></pre></td></tr></table></figure>

<h3 id="42-子网掩码是干什么的？"><a href="#42-子网掩码是干什么的？" class="headerlink" title="42 子网掩码是干什么的？"></a>42 子网掩码是干什么的？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">子网掩码用来指明一个IP地址所标示的主机是处于哪个子网中的。子网掩码不能单独存在，它必须结合IP地址一起使用。子网掩码只有一个作用，就是将某个IP地址划分成网络地址和主机地址两部分</span><br></pre></td></tr></table></figure>

<h3 id="43-IP地址分类有哪些？"><a href="#43-IP地址分类有哪些？" class="headerlink" title="43 IP地址分类有哪些？"></a>43 IP地址分类有哪些？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">A类：(1.0.0.0-126.0.0.0)（默认子网掩码：255.0.0.0或 0xFF000000）第一个字节为网络号，后三个字节为主机号。该类IP地址的最前面为“0”，所以地址的网络号取值于1~126之间。一般用于大型网络。</span><br><span class="line"></span><br><span class="line">B类：(128.0.0.0-191.255.0.0)（默认子网掩码：255.255.0.0或0xFFFF0000）前两个字节为网络号，后两个字节为主机号。该类IP地址的最前面为“10”，所以地址的网络号取值于128~191之间。一般用于中等规模网络。</span><br><span class="line"></span><br><span class="line">C类：(192.0.0.0-223.255.255.0)（子网掩码：255.255.255.0或 0xFFFFFF00）前三个字节为网络号，最后一个字节为主机号。该类IP地址的最前面为“110”，所以地址的网络号取值于192~223之间。一般用于小型网络。</span><br><span class="line"></span><br><span class="line">D类：是多播地址。该类IP地址的最前面为“1110”，所以地址的网络号取值于224~239之间。一般用于多路广播用户。</span><br><span class="line"></span><br><span class="line">E类：是保留地址。该类IP地址的最前面为“1111”，所以地址的网络号取值于240~255之间。</span><br></pre></td></tr></table></figure>

<h3 id="44-Java与C-x2F-C-有什么异同？"><a href="#44-Java与C-x2F-C-有什么异同？" class="headerlink" title="44 Java与C&#x2F;C++有什么异同？"></a>44 Java与C&#x2F;C++有什么异同？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Java与C++都是面向对象语言，都使用了面向对象思想（例如封装、继承、多态等），由于面向对象有许多非常好的特性（继承、组合等），因此二者都有很好的可重用性。</span><br><span class="line"></span><br><span class="line">二者的不同点：</span><br><span class="line">1.	Java为解释性语言，C++为编译型语言</span><br><span class="line">2.	Java为纯面向对象语言，C++兼具面向过程和面向对象编程的特点</span><br><span class="line">3.	Java语言没有指针概念</span><br><span class="line">4.	Java语言不支持多重继承，但引入了接口的概念</span><br><span class="line">5.	Java语言提供了垃圾回收器来实现垃圾的自动回收，而C++需要开发人员去管理对内存的分配</span><br><span class="line">6.	C++语言支持运算符重载，Java不支持运算法重载</span><br></pre></td></tr></table></figure>

<h3 id="45-Java中的作用域有哪些？"><a href="#45-Java中的作用域有哪些？" class="headerlink" title="45 Java中的作用域有哪些？"></a>45 Java中的作用域有哪些？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1）public。表明该成员变量或方法对所有类或对象都是可见的，所有类或对象都可以直</span><br><span class="line">接访问。</span><br><span class="line">2）private。表明该成员变量或方法是私有的，只有当前类对其具有访问权限，除此之外</span><br><span class="line">的其他类或者对象都没有访问权限。</span><br><span class="line">3）protected。表明该成员变量或方法对自己及其子类是可见的，即自己和子类具有权限访问，除此之外的其他类或者对象都没有访问权限。</span><br><span class="line">4）default。表明该成员变量或方法只有自己和与其位于同一包内的类可见。若父类与子类位</span><br><span class="line">于同一个包内，则子类对父类的default的成员变量或方法都有访问权限。若父类与子类位于不同的 package（包）内，则没有访问权限。</span><br></pre></td></tr></table></figure>

<h3 id="46-一个Java文件中是否可以定义多个类？"><a href="#46-一个Java文件中是否可以定义多个类？" class="headerlink" title="46 一个Java文件中是否可以定义多个类？"></a>46 一个Java文件中是否可以定义多个类？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个java文件中可以定义多个类，但是最多只有一个类被public修饰，并且这个类的类名与文件名必须相同</span><br></pre></td></tr></table></figure>

<h3 id="47-为什么Java中有些接口没有任何方法？"><a href="#47-为什么Java中有些接口没有任何方法？" class="headerlink" title="47 为什么Java中有些接口没有任何方法？"></a>47 为什么Java中有些接口没有任何方法？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因为实现这些接口的类不需要重写任何方法，这些没有任何方法声明的接口又被叫做标识接口，标识接口对实现它的类没有任何语义上的要求，它仅仅充当一个标识的作用，用来表明实现它的类属于一个特定的类型</span><br></pre></td></tr></table></figure>

<h3 id="48-Java中的clone方法有什么作用？"><a href="#48-Java中的clone方法有什么作用？" class="headerlink" title="48 Java中的clone方法有什么作用？"></a>48 Java中的clone方法有什么作用？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">已知对象A创建出另一个与A具有相同状态的对象B，并且对B的修改不会影响到A的状态</span><br></pre></td></tr></table></figure>

<h3 id="49-什么是浅拷贝和深拷贝？"><a href="#49-什么是浅拷贝和深拷贝？" class="headerlink" title="49 什么是浅拷贝和深拷贝？"></a>49 什么是浅拷贝和深拷贝？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">浅拷贝：仅仅克隆基本类型变量，不克隆引用类型变量；</span><br><span class="line">深拷贝：既克隆基本类型变量，又克隆引用类型变量；</span><br></pre></td></tr></table></figure>

<h3 id="50-什么是反射机制？"><a href="#50-什么是反射机制？" class="headerlink" title="50 什么是反射机制？"></a>50 什么是反射机制？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">反射是通过获取类的class对象，然后动态的获取到这个类的内部结构，动态的去操作类的属性和方法。</span><br></pre></td></tr></table></figure>

<h3 id="51-面向过程与面向对象有什么区别？"><a href="#51-面向过程与面向对象有什么区别？" class="headerlink" title="51 面向过程与面向对象有什么区别？"></a>51 面向过程与面向对象有什么区别？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了；面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。</span><br></pre></td></tr></table></figure>

<h3 id="52-面向对象的开发方式有什么优点？"><a href="#52-面向对象的开发方式有什么优点？" class="headerlink" title="52 面向对象的开发方式有什么优点？"></a>52 面向对象的开发方式有什么优点？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护</span><br></pre></td></tr></table></figure>

<h3 id="53-重载和覆盖有什么区别？"><a href="#53-重载和覆盖有什么区别？" class="headerlink" title="53 重载和覆盖有什么区别？"></a>53 重载和覆盖有什么区别？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">重载发生在同一个类中，方法名相同、参数列表、返回类型、权限修饰符可以不同</span><br><span class="line">覆盖发生在子类中，方法名相、参数列表、返回类型都相同，权限修饰符要大于父类方法，声明异常范围要小于父类方法，但是final和private修饰的方法不可重写</span><br></pre></td></tr></table></figure>

<h3 id="54-final、finally和finalize有什么区别？"><a href="#54-final、finally和finalize有什么区别？" class="headerlink" title="54 final、finally和finalize有什么区别？"></a>54 final、finally和finalize有什么区别？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">final可以修饰类，变量，方法，修饰的类不能被继承，修饰的变量不能重新赋值，修饰的方法不能被重写</span><br><span class="line">finally用于抛异常，finally代码块内语句无论是否发生异常，都会在执行finally，常用于一些流的关闭。</span><br><span class="line">finalize方法用于垃圾回收。</span><br></pre></td></tr></table></figure>

<h3 id="55-static关键字有哪些作用？"><a href="#55-static关键字有哪些作用？" class="headerlink" title="55 static关键字有哪些作用？"></a>55 static关键字有哪些作用？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第一，为某特定数据类型或对象分配单一的存储空间，而与创建对象的个数无关。</span><br><span class="line">第二，实现某个方法或属性与类而不是对象关联在一起</span><br></pre></td></tr></table></figure>

<h3 id="56-volatile关键字有哪些作用？"><a href="#56-volatile关键字有哪些作用？" class="headerlink" title="56 volatile关键字有哪些作用？"></a>56 volatile关键字有哪些作用？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.线程的可见性：当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。</span><br><span class="line">2. 顺序一致性：禁止指令重排序。</span><br></pre></td></tr></table></figure>

<h3 id="57-值传递与引用传递有哪些区别？"><a href="#57-值传递与引用传递有哪些区别？" class="headerlink" title="57 值传递与引用传递有哪些区别？"></a>57 值传递与引用传递有哪些区别？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">值传递：方法调用时，实际参数把它的值传递给对应的形式参数，方法执行中形式参数值的改变不影响实际参数的值。</span><br><span class="line">引用传递: 也称为传地址。方法调用时，实际参数的引用(地址，而不是参数的值)被传递给方法中相对应的形式参数，在方法执行中，对形式参数的操作实际上就是对实际参数的操作，方法执行中形式参数值的改变将会影响实际参数的值。</span><br></pre></td></tr></table></figure>

<h3 id="58-自动类型转换和强制类型转换是什么？"><a href="#58-自动类型转换和强制类型转换是什么？" class="headerlink" title="58 自动类型转换和强制类型转换是什么？"></a>58 自动类型转换和强制类型转换是什么？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">自动类型转换：对于某些类型的转换编译器可隐式地自动进行，不需人工干预，自动类型转换</span><br><span class="line">强制类型转换：类型转换需要编程者显式指定</span><br></pre></td></tr></table></figure>

<h3 id="59-Math类中round、ceil和floor方法的区别？"><a href="#59-Math类中round、ceil和floor方法的区别？" class="headerlink" title="59 Math类中round、ceil和floor方法的区别？"></a>59 Math类中round、ceil和floor方法的区别？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">round:取接近的整数</span><br><span class="line">ceil:向上取整</span><br><span class="line">floor:向下取整</span><br></pre></td></tr></table></figure>

<h3 id="60-i-与-i的区别？"><a href="#60-i-与-i的区别？" class="headerlink" title="60 i++与++i的区别？"></a>60 i++与++i的区别？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i++是先赋值，然后再自增；</span><br><span class="line">++i是先自增，后赋值。</span><br></pre></td></tr></table></figure>

<h3 id="61-lengt与length-的区别？"><a href="#61-lengt与length-的区别？" class="headerlink" title="61 lengt与length()的区别？"></a>61 lengt与length()的区别？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">length：用于基本类型数组，得到数组容量。</span><br><span class="line">length():用于String类型的字符串中，用于获取字符串的长度。</span><br></pre></td></tr></table></figure>

<h3 id="62-异常处理的原理是什么？"><a href="#62-异常处理的原理是什么？" class="headerlink" title="62 异常处理的原理是什么？"></a>62 异常处理的原理是什么？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">抛出异常：当方法出现错误而引发异常时，方法创建异常对象并交付运行系统，异常对象包含异常类型和异常出现时的程序状态等异常信息。运行系统负责寻找处置异常的代码并执行</span><br><span class="line">捕捉异常：方法抛出异常后，运行系统寻找合适的异常处理器。潜在的异常处理器是异常发生时依次存留在调用栈中方法集合。当异常处理器所能处理的异常类型与方法抛出的异常类型相符时，即为合适的异常处理器。运行系统从发生异常的方法开始，依次回查调用栈中的方法，直至找到含有合适异常处理器的方法并执行。当运行系统遍历调用栈而未找到合适的异常处理器，则运行系统终止。</span><br></pre></td></tr></table></figure>

<h3 id="63-run-与start-的区别？"><a href="#63-run-与start-的区别？" class="headerlink" title="63 run()与start()的区别？"></a>63 run()与start()的区别？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、start方法用来启动相应的线程；</span><br><span class="line">2、run方法只是thread的一个普通方法，在主线程里执行；</span><br><span class="line">3、需要并行处理的代码放在run方法中，start方法启动线程后自动调用run方法；</span><br><span class="line">4、run方法必须是public的访问权限，返回类型为void。</span><br></pre></td></tr></table></figure>

<h3 id="64-amp-与-amp-amp-的区别？"><a href="#64-amp-与-amp-amp-的区别？" class="headerlink" title="64 &amp;与&amp;&amp;的区别？"></a>64 &amp;与&amp;&amp;的区别？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">按位与：a&amp;b是把a和b都转换成二进制数然后再进行与的运算；</span><br><span class="line">逻辑与：a&amp;&amp;b就是当且仅当两个操作数均为 true时，其结果才为 true，只要有一个为false，a&amp;&amp;b就为false</span><br></pre></td></tr></table></figure>

<h3 id="65-short-s1-x3D-1-s1-x3D-s1-1-有什么错"><a href="#65-short-s1-x3D-1-s1-x3D-s1-1-有什么错" class="headerlink" title="65 short s1 &#x3D; 1; s1 &#x3D; s1 + 1;有什么错?"></a>65 short s1 &#x3D; 1; s1 &#x3D; s1 + 1;有什么错?</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s1 + 1，s1是short类型，1是int型，s1会自动转换为int型的1，与1相加后，得到int型的2，与左边类型不匹配</span><br></pre></td></tr></table></figure>

<h3 id="66-在JAVA中如何跳出当前的多重嵌套循环？"><a href="#66-在JAVA中如何跳出当前的多重嵌套循环？" class="headerlink" title="66 在JAVA中如何跳出当前的多重嵌套循环？"></a>66 在JAVA中如何跳出当前的多重嵌套循环？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、使用break</span><br><span class="line">2、循环条件限制</span><br><span class="line">3、循环内抛出异常</span><br></pre></td></tr></table></figure>

<h3 id="67-使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？"><a href="#67-使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？" class="headerlink" title="67 使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？"></a>67 使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">引用不能变</span><br></pre></td></tr></table></figure>

<h3 id="68-静态变量和实例变量的区别？"><a href="#68-静态变量和实例变量的区别？" class="headerlink" title="68 静态变量和实例变量的区别？"></a>68 静态变量和实例变量的区别？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">实例变量属于某个对象的属性，必须创建了实例对象，其中的实例变量才会被分配空间，才能使用这个实例变量</span><br><span class="line">静态变量不属于某个实例对象，而是属于整个类。只要程序加载了类的字节码，不用创建任何实例对象，静态变量就回被分配空间，静态变量就可以被使用了</span><br></pre></td></tr></table></figure>

<h3 id="69-接口是否可继承接口"><a href="#69-接口是否可继承接口" class="headerlink" title="69 接口是否可继承接口?"></a>69 接口是否可继承接口?</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以</span><br></pre></td></tr></table></figure>

<h3 id="70-抽象类是否可实现接口"><a href="#70-抽象类是否可实现接口" class="headerlink" title="70 抽象类是否可实现接口?"></a>70 抽象类是否可实现接口?</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以</span><br></pre></td></tr></table></figure>

<h3 id="71-抽象类是否可继承具体类"><a href="#71-抽象类是否可继承具体类" class="headerlink" title="71 抽象类是否可继承具体类?"></a>71 抽象类是否可继承具体类?</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以</span><br></pre></td></tr></table></figure>

<h3 id="72-抽象类中是否可以有静态的main方法？"><a href="#72-抽象类中是否可以有静态的main方法？" class="headerlink" title="72 抽象类中是否可以有静态的main方法？"></a>72 抽象类中是否可以有静态的main方法？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以</span><br></pre></td></tr></table></figure>

<h3 id="73-java中实现多态的机制是什么？"><a href="#73-java中实现多态的机制是什么？" class="headerlink" title="73 java中实现多态的机制是什么？"></a>73 java中实现多态的机制是什么？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过将子类对象引用赋值给超类对象引用变量（向上转型）来实现动态方法调用</span><br></pre></td></tr></table></figure>

<h3 id="74-error和exception有什么区别？"><a href="#74-error和exception有什么区别？" class="headerlink" title="74 error和exception有什么区别？"></a>74 error和exception有什么区别？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Error属于程序无法处理的错误，是JVM需要负担的责任，无法通过try-catch来进行捕获</span><br><span class="line">Exception: 程序本身可以处理的异常，可以通过catch来进行捕获，通常遇到这种错误，应对其进行处理，使应用程序可以继续正常运行</span><br></pre></td></tr></table></figure>

<h3 id="75-throw与throws的区别？"><a href="#75-throw与throws的区别？" class="headerlink" title="75 throw与throws的区别？"></a>75 throw与throws的区别？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">throw：作用在方法内，表示抛出具体异常，由方法体内的语句处理；</span><br><span class="line">一定抛出了异常；</span><br><span class="line">throws：作用在方法的声明上，表示抛出异常，由调用者来进行异常处理；</span><br><span class="line">可能出现异常，不一定会发生异常；</span><br></pre></td></tr></table></figure>

<h3 id="76-sleep-和-wait-有什么区别"><a href="#76-sleep-和-wait-有什么区别" class="headerlink" title="76 sleep() 和 wait() 有什么区别?"></a>76 sleep() 和 wait() 有什么区别?</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、sleep()是Thread类的静态方法。wait()是Object类的方法。</span><br><span class="line">2、sleep()是不释放锁的。wait()是释放锁的。</span><br><span class="line">3、sleep()常用于一定时间内暂停线程执行。wait()常用于线程间交互和通信。</span><br><span class="line">4、sleep()方法睡眠指定时间之后，线程会自动苏醒。wait()方法被调用后，可以通过notify()或notifyAll()来唤醒wait的线程</span><br></pre></td></tr></table></figure>

<h3 id="77-当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法"><a href="#77-当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法" class="headerlink" title="77 当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法?"></a>77 当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法?</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、一个线程在访问一个对象的一个synchronized方法时，另一个线程可以同时访问这个对象的非同步方法</span><br><span class="line">2、一个线程在访问一个对象的一个synchronized方法时，另一个线程不可以同时访问这个对象的普通同步方法</span><br><span class="line">3、一个线程在访问一个对象的一个synchronized方法时，另一个线程可以同时访问这个对象的静态同步方法 </span><br><span class="line">4、一个线程在访问一个对象的一个static synchronized方法时，另一个线程不可以同时访问这个对象的静态同步方法</span><br></pre></td></tr></table></figure>

<h3 id="78-线程的基本状态以及状态之间的关系是什么？"><a href="#78-线程的基本状态以及状态之间的关系是什么？" class="headerlink" title="78 线程的基本状态以及状态之间的关系是什么？"></a>78 线程的基本状态以及状态之间的关系是什么？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">线程状态：就绪、运行、阻塞</span><br><span class="line">就绪状态代表线程具备了运行的所有条件，等待CPU的调度；当CPU调度线程后，将进入运行状态；在运行时遇到I/O中断、线程休眠、调用了对象的wait方法就会进入阻塞状态</span><br></pre></td></tr></table></figure>

<h3 id="79-List、Map、Set三个接口，存取元素时，各有什么特点？"><a href="#79-List、Map、Set三个接口，存取元素时，各有什么特点？" class="headerlink" title="79 List、Map、Set三个接口，存取元素时，各有什么特点？"></a>79 List、Map、Set三个接口，存取元素时，各有什么特点？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List存放元素可以重复，存放元素是有序的</span><br><span class="line">Set 存放元素不可重复</span><br><span class="line">Map存放键值对，键不可重复，值可重复</span><br></pre></td></tr></table></figure>

<h3 id="80-两个对象值相同-x-equals-y-x3D-x3D-true-，但却可有不同的hashcode，这句话对不对？"><a href="#80-两个对象值相同-x-equals-y-x3D-x3D-true-，但却可有不同的hashcode，这句话对不对？" class="headerlink" title="80 两个对象值相同(x.equals(y) &#x3D;&#x3D; true)，但却可有不同的hashcode，这句话对不对？"></a>80 两个对象值相同(x.equals(y) &#x3D;&#x3D; true)，但却可有不同的hashcode，这句话对不对？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不对</span><br></pre></td></tr></table></figure>

<h3 id="81-什么是java序列化，如何实现java序列化？或者请解释Serializable接口的作用。"><a href="#81-什么是java序列化，如何实现java序列化？或者请解释Serializable接口的作用。" class="headerlink" title="81 什么是java序列化，如何实现java序列化？或者请解释Serializable接口的作用。"></a>81 什么是java序列化，如何实现java序列化？或者请解释Serializable接口的作用。</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">序列化是通过实现serializable接口，该接口没有需要实现的方法，implement Serializable只是为了标注该对象是可被序列化的，使用一个输出流（FileOutputStream）来构造一个ObjectOutputStream对象，接着使用ObjectOutputStream对象的writeObejct（Object object）方法就可以将参数的obj对象到磁盘，需要恢复的时候使用输入流。</span><br></pre></td></tr></table></figure>

<h3 id="82-什么是构造函数？"><a href="#82-什么是构造函数？" class="headerlink" title="82 什么是构造函数？"></a>82 什么是构造函数？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">构造函数，也叫构造方法，是JAVA中一种特殊的函数，与函数名相同，无返回值</span><br></pre></td></tr></table></figure>

<h3 id="83-内部类有哪些？"><a href="#83-内部类有哪些？" class="headerlink" title="83 内部类有哪些？"></a>83 内部类有哪些？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、静态内部类 </span><br><span class="line">2、成员内部类 </span><br><span class="line">3、局部内部类 </span><br><span class="line">4、匿名内部类</span><br></pre></td></tr></table></figure>

<h3 id="84-instanceof有什么用？"><a href="#84-instanceof有什么用？" class="headerlink" title="84 instanceof有什么用？"></a>84 instanceof有什么用？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">判断一个引用类型变量所指向的对象是否是一个类的实例</span><br></pre></td></tr></table></figure>

<h3 id="85-什么是GC？"><a href="#85-什么是GC？" class="headerlink" title="85 什么是GC？"></a>85 什么是GC？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GC是垃圾收集的意思，内存处理是开发人员容易出现问题的地方，忘记或者错误地内存回收会导致程序或者系统的不稳定甚至崩溃，Java提供的垃圾回收机制可以自动检测对象是否超过作用域从而达到自动回收的目的</span><br></pre></td></tr></table></figure>

<h3 id="86-Java中是否存在内存泄漏的问题，并举例说明？"><a href="#86-Java中是否存在内存泄漏的问题，并举例说明？" class="headerlink" title="86 Java中是否存在内存泄漏的问题，并举例说明？"></a>86 Java中是否存在内存泄漏的问题，并举例说明？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、在堆中申请了空间没有被释放；</span><br><span class="line">2、对象已不再被使用，但还仍然在内存中保留着</span><br></pre></td></tr></table></figure>

<h3 id="87-Java中的堆内存与栈内存有什么区别？"><a href="#87-Java中的堆内存与栈内存有什么区别？" class="headerlink" title="87 Java中的堆内存与栈内存有什么区别？"></a>87 Java中的堆内存与栈内存有什么区别？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">堆内存是区别于栈区、全局数据区和代码区的另一个内存区域。堆允许程序在运行时动态地申请某个大小的内存空间。栈内存在函数中定义的一些基本类型的变量和对象的引用变量都在函数的栈内存中分配。</span><br></pre></td></tr></table></figure>

<h3 id="88-什么是栈内存溢出？"><a href="#88-什么是栈内存溢出？" class="headerlink" title="88 什么是栈内存溢出？"></a>88 什么是栈内存溢出？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">栈溢出指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致与其相邻的栈中的变量的值被改变</span><br></pre></td></tr></table></figure>

<h3 id="89-什么是堆内存溢出？"><a href="#89-什么是堆内存溢出？" class="headerlink" title="89 什么是堆内存溢出？"></a>89 什么是堆内存溢出？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">申请内存空间时，超出最大堆内存空间，系统给不了</span><br></pre></td></tr></table></figure>

<h3 id="90什么是整数溢出？"><a href="#90什么是整数溢出？" class="headerlink" title="90什么是整数溢出？"></a>90什么是整数溢出？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">整数在内存里面保存在一个固定长度的空间内，它能存储的最大值和最小值是固定的，如果我们尝试去存储一个数，而这个数又大于这个固定的最大值时，就会导致整数溢出</span><br></pre></td></tr></table></figure>

<h3 id="91-同步和异步有什么区别？"><a href="#91-同步和异步有什么区别？" class="headerlink" title="91 同步和异步有什么区别？"></a>91 同步和异步有什么区别？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">同步:发送一个请求,等待返回,然后再发送下一个请求 </span><br><span class="line">异步:发送一个请求,不等待返回,随时可以再发送下一个请求</span><br></pre></td></tr></table></figure>

<h3 id="92-终止线程的方法有哪些？"><a href="#92-终止线程的方法有哪些？" class="headerlink" title="92 终止线程的方法有哪些？"></a>92 终止线程的方法有哪些？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、正常运行结束 </span><br><span class="line">2、使用退出标签退出线程 </span><br><span class="line">3、Interrupt方法结束线程 </span><br><span class="line">4、stop方法结束线程</span><br></pre></td></tr></table></figure>

<h3 id="93-什么是单例模式？"><a href="#93-什么是单例模式？" class="headerlink" title="93 什么是单例模式？"></a>93 什么是单例模式？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">保证一个类只有一个实列，并提供一个访问它的全局访问点。</span><br></pre></td></tr></table></figure>

<h3 id="94-什么是工厂模式？"><a href="#94-什么是工厂模式？" class="headerlink" title="94 什么是工厂模式？"></a>94 什么是工厂模式？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">定义一个创建对象的接口，但由子类决定需要实例化哪一个类。使得子类实例化过程推迟。</span><br></pre></td></tr></table></figure>

<h3 id="95-什么是适配器模式？"><a href="#95-什么是适配器模式？" class="headerlink" title="95 什么是适配器模式？"></a>95 什么是适配器模式？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将一个类的接口转换成用户希望得到的另一种接口。使原本不相容的接口得以协同工作。</span><br></pre></td></tr></table></figure>

<h3 id="96-什么是观察者模式？"><a href="#96-什么是观察者模式？" class="headerlink" title="96 什么是观察者模式？"></a>96 什么是观察者模式？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖它的对象都得到通知并自动更新。</span><br></pre></td></tr></table></figure>

<h3 id="97-什么是代理模式？"><a href="#97-什么是代理模式？" class="headerlink" title="97 什么是代理模式？"></a>97 什么是代理模式？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">为其他对象提供一种代理以控制这个对象的访问。</span><br></pre></td></tr></table></figure>

<h3 id="98-什么是NIO？"><a href="#98-什么是NIO？" class="headerlink" title="98 什么是NIO？"></a>98 什么是NIO？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">同步非阻塞NIO：NIO主要是想解决BIO的大并发问题，BIO是每一个请求分配一个线程，当请求过多时，每个线程占用一定的内存空间，服务器瘫痪了。</span><br></pre></td></tr></table></figure>

<h3 id="99-迭代器的实现原理是什么？"><a href="#99-迭代器的实现原理是什么？" class="headerlink" title="99 迭代器的实现原理是什么？"></a>99 迭代器的实现原理是什么？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在ArrayList类下有一个成员内部类Itr,它实现了Iterator接口，内部类中定义了一个游标成员变量，通过hasNext方法来判断游标后是否有下一个元素，如果有就把元素添加到Object数组中，然后继续下一个判断；如果没有就结束</span><br></pre></td></tr></table></figure>

<h3 id="100-垃圾回收有哪些算法并详细阐述原理"><a href="#100-垃圾回收有哪些算法并详细阐述原理" class="headerlink" title="100 垃圾回收有哪些算法并详细阐述原理"></a>100 垃圾回收有哪些算法并详细阐述原理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、引用计数法：假设有一个对象A，任何一个对象对A的引用，那么对象A的引用计数器+1，当引用失败时，对象A的引用计数器就-1，如果对象A的计算器的值为0，就说明对象A没有引用了，可以被回收。</span><br><span class="line">2、标记清除法：标记 ：从根节点开始标记引用的对象。</span><br><span class="line">			 清除 ：未被标记引用的对象就是垃圾对象，可以被清理</span><br><span class="line">3、标记压缩算法：在标记清除法的基础上在清理阶段，并不是简单的清理未标记的对象，而是将存活的对象压缩到内存的一端，然后清理边界以外的垃圾</span><br><span class="line">4、复制算法：复制算法的核心就是，将原有的内存空间一分为二，每次只用其中的一块，在垃圾回收时，将正在使用的对象复制到另一个内存空间中，然后将该内存空间清空，交换两个内存的角色，完成垃圾的回收。</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">陈天在睡觉</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/post/0.html">http://example.com/post/0.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">陈天在睡觉</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/%E5%8D%9A%E5%AE%A22.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/post/2d58191d.html"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E5%8D%9A%E5%AE%A27.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">HCIA</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E5%A4%B4%E5%83%8F.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">陈天在睡觉</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://blog.csdn.net/qq_52059326" target="_blank" title="CSDN"><i class="iconfont icon-csdn"></i></a><a class="social-icon" href="https://space.bilibili.com/14631623" target="_blank" title="b站"><i class="iconfont icon-bilibili-fill"></i></a><a class="social-icon" href="https://github.com/chentianzaishuijiao" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content"><b><font color="#e66b6d">双</font> <font color="#e66d98">手</font> <font color="#e66cc6">合</font> <font color="#cc6de6">十</font> <font color="#9770e6">成</font> <font color="#6d93e6">为</font> <font color="#6fcde6">自</font> <font color="#72e6b6">己</font> <font color="#72e689">的</font> <font color="#99e670">神</font>, <font color="#cde670">自</font> <font color="#e6df72">己</font> <font color="#e6c073">所</font> <font color="#e6a271">信</font> <font color="#e6796f">念</font> <font color="#e65454">的</font> <font color="#e63333">即</font> <font color="#e62c2c">是</font> <font color="#e60101">信</font> <font color="#e60101">仰</font></b> <p align="center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/f7384c88956d4378b72e47548e19c9f8.gif" width="50" alt="mao"></p> <p align="center">微信号：a847503688</p> <p align="center">QQ号：847503688</p></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-JDK%E4%B8%8EJRE%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%AE%83%E4%BB%AC%E5%90%84%E8%87%AA%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">1 JDK与JRE的区别是什么？它们各自有什么作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8FPATH%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">2 环境变量PATH的作用是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8FCLASSPATH%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.</span> <span class="toc-text">3 环境变量CLASSPATH的作用是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BB%80%E4%B9%88%E6%98%AFJVM%EF%BC%8C%E5%85%B6%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-number">4.</span> <span class="toc-text">4 什么是JVM，其工作原理是什么样的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3Java%E4%B8%AD%E7%9A%84%E8%A3%85%E7%AE%B1%E5%92%8C%E6%8B%86%E7%AE%B1%EF%BC%9F"><span class="toc-number">5.</span> <span class="toc-text">5 如何理解Java中的装箱和拆箱？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-Java%E4%B8%ADequals%E6%96%B9%E6%B3%95%E5%92%8C-x3D-x3D-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">6.</span> <span class="toc-text">6 Java中equals方法和&#x3D;&#x3D;的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">7.</span> <span class="toc-text">7 类和对象有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-Java%E4%B8%AD%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%9A%84%E7%89%B9%E7%82%B9%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">8.</span> <span class="toc-text">8 Java中成员变量的特点有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-Java%E4%B8%AD%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E7%9A%84%E7%89%B9%E7%82%B9%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">9.</span> <span class="toc-text">9 Java中静态变量的特点有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-Java%E4%B8%AD%E5%AD%90%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%A6%82%E4%BD%95%E4%B8%BA%E7%88%B6%E7%B1%BB%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0%EF%BC%9F"><span class="toc-number">10.</span> <span class="toc-text">10 Java中子类的构造函数如何为父类传递参数？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-this%E4%B8%8Esuper%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">11.</span> <span class="toc-text">11 this与super的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">12.</span> <span class="toc-text">12 接口和抽象类的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E9%87%8F%E6%98%AF%E5%90%A6%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E4%B8%80%E4%B8%AAString%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="toc-number">13.</span> <span class="toc-text">13 字符串字面量是否自动生成一个String对象？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1%E6%B1%A0%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">14.</span> <span class="toc-text">14 字符串对象池的作用是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-StringBuffer%E5%92%8CStringBuilder%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E5%AD%98%E5%9C%A8%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">15.</span> <span class="toc-text">15 StringBuffer和StringBuilder的区别以及存在的作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">16.</span> <span class="toc-text">17 迭代器是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-%E6%AF%94%E8%BE%83%E5%99%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">17.</span> <span class="toc-text">18 比较器是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-Vector%E3%80%81ArrayList%E5%92%8CLinkedList%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">18.</span> <span class="toc-text">19 Vector、ArrayList和LinkedList的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-HashMap%E3%80%81HashTable%E5%92%8CTreeMap%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">19.</span> <span class="toc-text">20 HashMap、HashTable和TreeMap的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E6%95%B0%E6%8D%AE%E9%9B%86%E5%90%88%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8foreach%E5%BE%AA%E7%8E%AF%EF%BC%9F"><span class="toc-number">20.</span> <span class="toc-text">21 什么样的数据集合可以使用foreach循环？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-%E5%AD%97%E8%8A%82%E6%B5%81%E4%B8%8E%E5%AD%97%E7%AC%A6%E6%B5%81%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">21.</span> <span class="toc-text">22 字节流与字符流的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-%E5%AD%97%E8%8A%82%E6%B5%81%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">22.</span> <span class="toc-text">23 字节流的处理方式有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-%E5%AD%97%E7%AC%A6%E6%B5%81%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">23.</span> <span class="toc-text">24 字符流的处理方式有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-%E4%BB%80%E4%B9%88%E6%98%AF%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%9F"><span class="toc-number">24.</span> <span class="toc-text">25 什么是序列化？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-%E8%A7%A3%E9%87%8A%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">25.</span> <span class="toc-text">26 解释进程和线程的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27-%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">26.</span> <span class="toc-text">27 实现线程的方式有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8synchronized%E6%9D%A5%E8%AE%A9%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%EF%BC%9F"><span class="toc-number">27.</span> <span class="toc-text">28 如何使用synchronized来让线程同步？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">28.</span> <span class="toc-text">29 为什么会有线程安全问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#30-%E4%BB%80%E4%B9%88%E6%98%AF%E9%94%81%E5%B9%B6%E8%A7%A3%E9%87%8A%E6%AD%BB%E9%94%81%E7%9A%84%E5%8E%9F%E5%9B%A0%EF%BC%9F"><span class="toc-number">29.</span> <span class="toc-text">30 什么是锁并解释死锁的原因？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#31-%E5%8F%8D%E5%B0%84%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">30.</span> <span class="toc-text">31 反射的原理是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32-Class%E7%B1%BB%E7%9A%84%E5%90%AB%E4%B9%89%E5%92%8C%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">31.</span> <span class="toc-text">32 Class类的含义和作用是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E5%BD%A2%E5%BC%8F%EF%BC%9F"><span class="toc-number">32.</span> <span class="toc-text">33 创建对象有哪几种形式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#34-%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E6%9D%A5%E8%AE%BF%E9%97%AE%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84%E7%A7%81%E6%9C%89%E6%88%90%E5%91%98%EF%BC%9F"><span class="toc-number">33.</span> <span class="toc-text">34 如何利用反射机制来访问一个类的私有成员？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#35-%E4%BB%80%E4%B9%88%E6%98%AFTCP%E4%BB%80%E4%B9%88%E6%98%AFUDP%EF%BC%9F"><span class="toc-number">34.</span> <span class="toc-text">35 什么是TCP什么是UDP？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#36-%E7%AE%80%E8%BF%B0%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E6%9E%B6%E6%9E%84"><span class="toc-number">35.</span> <span class="toc-text">36 简述七层网络模型架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#37-%E7%AE%80%E8%BF%B0%E5%AF%B9TCP-x2F-IP%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">36.</span> <span class="toc-text">37 简述对TCP&#x2F;IP协议的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#38-%E4%BB%80%E4%B9%88%E6%98%AFIP%EF%BC%9F"><span class="toc-number">37.</span> <span class="toc-text">38 什么是IP？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#39-%E4%BB%80%E4%B9%88%E6%98%AFNAT%EF%BC%9F"><span class="toc-number">38.</span> <span class="toc-text">39 什么是NAT？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#40-%E4%BB%80%E4%B9%88%E6%98%AFDNS%EF%BC%9F"><span class="toc-number">39.</span> <span class="toc-text">40 什么是DNS？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#41-%E4%BB%80%E4%B9%88%E6%98%AFDHCP%EF%BC%9F"><span class="toc-number">40.</span> <span class="toc-text">41 什么是DHCP？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#42-%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81%E6%98%AF%E5%B9%B2%E4%BB%80%E4%B9%88%E7%9A%84%EF%BC%9F"><span class="toc-number">41.</span> <span class="toc-text">42 子网掩码是干什么的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#43-IP%E5%9C%B0%E5%9D%80%E5%88%86%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">42.</span> <span class="toc-text">43 IP地址分类有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#44-Java%E4%B8%8EC-x2F-C-%E6%9C%89%E4%BB%80%E4%B9%88%E5%BC%82%E5%90%8C%EF%BC%9F"><span class="toc-number">43.</span> <span class="toc-text">44 Java与C&#x2F;C++有什么异同？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#45-Java%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">44.</span> <span class="toc-text">45 Java中的作用域有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#46-%E4%B8%80%E4%B8%AAJava%E6%96%87%E4%BB%B6%E4%B8%AD%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E5%AE%9A%E4%B9%89%E5%A4%9A%E4%B8%AA%E7%B1%BB%EF%BC%9F"><span class="toc-number">45.</span> <span class="toc-text">46 一个Java文件中是否可以定义多个类？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#47-%E4%B8%BA%E4%BB%80%E4%B9%88Java%E4%B8%AD%E6%9C%89%E4%BA%9B%E6%8E%A5%E5%8F%A3%E6%B2%A1%E6%9C%89%E4%BB%BB%E4%BD%95%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">46.</span> <span class="toc-text">47 为什么Java中有些接口没有任何方法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#48-Java%E4%B8%AD%E7%9A%84clone%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">47.</span> <span class="toc-text">48 Java中的clone方法有什么作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#49-%E4%BB%80%E4%B9%88%E6%98%AF%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D%EF%BC%9F"><span class="toc-number">48.</span> <span class="toc-text">49 什么是浅拷贝和深拷贝？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#50-%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-number">49.</span> <span class="toc-text">50 什么是反射机制？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#51-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">50.</span> <span class="toc-text">51 面向过程与面向对象有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#52-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BC%80%E5%8F%91%E6%96%B9%E5%BC%8F%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%82%B9%EF%BC%9F"><span class="toc-number">51.</span> <span class="toc-text">52 面向对象的开发方式有什么优点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#53-%E9%87%8D%E8%BD%BD%E5%92%8C%E8%A6%86%E7%9B%96%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">52.</span> <span class="toc-text">53 重载和覆盖有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#54-final%E3%80%81finally%E5%92%8Cfinalize%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">53.</span> <span class="toc-text">54 final、finally和finalize有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#55-static%E5%85%B3%E9%94%AE%E5%AD%97%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">54.</span> <span class="toc-text">55 static关键字有哪些作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#56-volatile%E5%85%B3%E9%94%AE%E5%AD%97%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">55.</span> <span class="toc-text">56 volatile关键字有哪些作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#57-%E5%80%BC%E4%BC%A0%E9%80%92%E4%B8%8E%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">56.</span> <span class="toc-text">57 值传递与引用传递有哪些区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#58-%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%92%8C%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">57.</span> <span class="toc-text">58 自动类型转换和强制类型转换是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#59-Math%E7%B1%BB%E4%B8%ADround%E3%80%81ceil%E5%92%8Cfloor%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">58.</span> <span class="toc-text">59 Math类中round、ceil和floor方法的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#60-i-%E4%B8%8E-i%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">59.</span> <span class="toc-text">60 i++与++i的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#61-lengt%E4%B8%8Elength-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">60.</span> <span class="toc-text">61 lengt与length()的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#62-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">61.</span> <span class="toc-text">62 异常处理的原理是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#63-run-%E4%B8%8Estart-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">62.</span> <span class="toc-text">63 run()与start()的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#64-amp-%E4%B8%8E-amp-amp-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">63.</span> <span class="toc-text">64 &amp;与&amp;&amp;的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#65-short-s1-x3D-1-s1-x3D-s1-1-%E6%9C%89%E4%BB%80%E4%B9%88%E9%94%99"><span class="toc-number">64.</span> <span class="toc-text">65 short s1 &#x3D; 1; s1 &#x3D; s1 + 1;有什么错?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#66-%E5%9C%A8JAVA%E4%B8%AD%E5%A6%82%E4%BD%95%E8%B7%B3%E5%87%BA%E5%BD%93%E5%89%8D%E7%9A%84%E5%A4%9A%E9%87%8D%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF%EF%BC%9F"><span class="toc-number">65.</span> <span class="toc-text">66 在JAVA中如何跳出当前的多重嵌套循环？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#67-%E4%BD%BF%E7%94%A8final%E5%85%B3%E9%94%AE%E5%AD%97%E4%BF%AE%E9%A5%B0%E4%B8%80%E4%B8%AA%E5%8F%98%E9%87%8F%E6%97%B6%EF%BC%8C%E6%98%AF%E5%BC%95%E7%94%A8%E4%B8%8D%E8%83%BD%E5%8F%98%EF%BC%8C%E8%BF%98%E6%98%AF%E5%BC%95%E7%94%A8%E7%9A%84%E5%AF%B9%E8%B1%A1%E4%B8%8D%E8%83%BD%E5%8F%98%EF%BC%9F"><span class="toc-number">66.</span> <span class="toc-text">67 使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#68-%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">67.</span> <span class="toc-text">68 静态变量和实例变量的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#69-%E6%8E%A5%E5%8F%A3%E6%98%AF%E5%90%A6%E5%8F%AF%E7%BB%A7%E6%89%BF%E6%8E%A5%E5%8F%A3"><span class="toc-number">68.</span> <span class="toc-text">69 接口是否可继承接口?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#70-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%98%AF%E5%90%A6%E5%8F%AF%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3"><span class="toc-number">69.</span> <span class="toc-text">70 抽象类是否可实现接口?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#71-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%98%AF%E5%90%A6%E5%8F%AF%E7%BB%A7%E6%89%BF%E5%85%B7%E4%BD%93%E7%B1%BB"><span class="toc-number">70.</span> <span class="toc-text">71 抽象类是否可继承具体类?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#72-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%AD%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E6%9C%89%E9%9D%99%E6%80%81%E7%9A%84main%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">71.</span> <span class="toc-text">72 抽象类中是否可以有静态的main方法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#73-java%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%80%81%E7%9A%84%E6%9C%BA%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">72.</span> <span class="toc-text">73 java中实现多态的机制是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#74-error%E5%92%8Cexception%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">73.</span> <span class="toc-text">74 error和exception有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#75-throw%E4%B8%8Ethrows%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">74.</span> <span class="toc-text">75 throw与throws的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#76-sleep-%E5%92%8C-wait-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">75.</span> <span class="toc-text">76 sleep() 和 wait() 有什么区别?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#77-%E5%BD%93%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E8%BF%9B%E5%85%A5%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%80%E4%B8%AAsynchronized%E6%96%B9%E6%B3%95%E5%90%8E%EF%BC%8C%E5%85%B6%E5%AE%83%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%90%A6%E5%8F%AF%E8%BF%9B%E5%85%A5%E6%AD%A4%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B6%E5%AE%83%E6%96%B9%E6%B3%95"><span class="toc-number">76.</span> <span class="toc-text">77 当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#78-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81%E4%BB%A5%E5%8F%8A%E7%8A%B6%E6%80%81%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">77.</span> <span class="toc-text">78 线程的基本状态以及状态之间的关系是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#79-List%E3%80%81Map%E3%80%81Set%E4%B8%89%E4%B8%AA%E6%8E%A5%E5%8F%A3%EF%BC%8C%E5%AD%98%E5%8F%96%E5%85%83%E7%B4%A0%E6%97%B6%EF%BC%8C%E5%90%84%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="toc-number">78.</span> <span class="toc-text">79 List、Map、Set三个接口，存取元素时，各有什么特点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#80-%E4%B8%A4%E4%B8%AA%E5%AF%B9%E8%B1%A1%E5%80%BC%E7%9B%B8%E5%90%8C-x-equals-y-x3D-x3D-true-%EF%BC%8C%E4%BD%86%E5%8D%B4%E5%8F%AF%E6%9C%89%E4%B8%8D%E5%90%8C%E7%9A%84hashcode%EF%BC%8C%E8%BF%99%E5%8F%A5%E8%AF%9D%E5%AF%B9%E4%B8%8D%E5%AF%B9%EF%BC%9F"><span class="toc-number">79.</span> <span class="toc-text">80 两个对象值相同(x.equals(y) &#x3D;&#x3D; true)，但却可有不同的hashcode，这句话对不对？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#81-%E4%BB%80%E4%B9%88%E6%98%AFjava%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0java%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%9F%E6%88%96%E8%80%85%E8%AF%B7%E8%A7%A3%E9%87%8ASerializable%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BD%9C%E7%94%A8%E3%80%82"><span class="toc-number">80.</span> <span class="toc-text">81 什么是java序列化，如何实现java序列化？或者请解释Serializable接口的作用。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#82-%E4%BB%80%E4%B9%88%E6%98%AF%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-number">81.</span> <span class="toc-text">82 什么是构造函数？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#83-%E5%86%85%E9%83%A8%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">82.</span> <span class="toc-text">83 内部类有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#84-instanceof%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="toc-number">83.</span> <span class="toc-text">84 instanceof有什么用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#85-%E4%BB%80%E4%B9%88%E6%98%AFGC%EF%BC%9F"><span class="toc-number">84.</span> <span class="toc-text">85 什么是GC？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#86-Java%E4%B8%AD%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%8C%E5%B9%B6%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E%EF%BC%9F"><span class="toc-number">85.</span> <span class="toc-text">86 Java中是否存在内存泄漏的问题，并举例说明？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#87-Java%E4%B8%AD%E7%9A%84%E5%A0%86%E5%86%85%E5%AD%98%E4%B8%8E%E6%A0%88%E5%86%85%E5%AD%98%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">86.</span> <span class="toc-text">87 Java中的堆内存与栈内存有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#88-%E4%BB%80%E4%B9%88%E6%98%AF%E6%A0%88%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%EF%BC%9F"><span class="toc-number">87.</span> <span class="toc-text">88 什么是栈内存溢出？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#89-%E4%BB%80%E4%B9%88%E6%98%AF%E5%A0%86%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%EF%BC%9F"><span class="toc-number">88.</span> <span class="toc-text">89 什么是堆内存溢出？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#90%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%EF%BC%9F"><span class="toc-number">89.</span> <span class="toc-text">90什么是整数溢出？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#91-%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">90.</span> <span class="toc-text">91 同步和异步有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#92-%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">91.</span> <span class="toc-text">92 终止线程的方法有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#93-%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="toc-number">92.</span> <span class="toc-text">93 什么是单例模式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#94-%E4%BB%80%E4%B9%88%E6%98%AF%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="toc-number">93.</span> <span class="toc-text">94 什么是工厂模式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#95-%E4%BB%80%E4%B9%88%E6%98%AF%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="toc-number">94.</span> <span class="toc-text">95 什么是适配器模式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#96-%E4%BB%80%E4%B9%88%E6%98%AF%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="toc-number">95.</span> <span class="toc-text">96 什么是观察者模式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#97-%E4%BB%80%E4%B9%88%E6%98%AF%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="toc-number">96.</span> <span class="toc-text">97 什么是代理模式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#98-%E4%BB%80%E4%B9%88%E6%98%AFNIO%EF%BC%9F"><span class="toc-number">97.</span> <span class="toc-text">98 什么是NIO？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#99-%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">98.</span> <span class="toc-text">99 迭代器的实现原理是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#100-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%89%E5%93%AA%E4%BA%9B%E7%AE%97%E6%B3%95%E5%B9%B6%E8%AF%A6%E7%BB%86%E9%98%90%E8%BF%B0%E5%8E%9F%E7%90%86"><span class="toc-number">99.</span> <span class="toc-text">100 垃圾回收有哪些算法并详细阐述原理</span></a></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('/img/%E5%8D%9A%E5%AE%A22.png')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 陈天在睡觉</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>