<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JAVA面试题</title>
      <link href="/post/0.html"/>
      <url>/post/0.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-JDK与JRE的区别是什么？它们各自有什么作用？"><a href="#1-JDK与JRE的区别是什么？它们各自有什么作用？" class="headerlink" title="1 JDK与JRE的区别是什么？它们各自有什么作用？"></a>1 JDK与JRE的区别是什么？它们各自有什么作用？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">区别：</span><br><span class="line">JDK 是 Java Development Kit 缩写，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。</span><br><span class="line"></span><br><span class="line">JRE 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序。</span><br><span class="line"></span><br><span class="line">各自作用：</span><br><span class="line">JDK提供了编译、运行Java程序所需的各种工具和资源，包括Java编译器、Java运行环境JRE，以及常用的Java基础类库等，是整个JAVA的核心。</span><br><span class="line">JRE是运行基于Java语言编写的程序所不可缺少的运行环境，用于解释执行Java的字节码文件。</span><br></pre></td></tr></table></figure><h3 id="2-环境变量PATH的作用是什么？"><a href="#2-环境变量PATH的作用是什么？" class="headerlink" title="2 环境变量PATH的作用是什么？"></a>2 环境变量PATH的作用是什么？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Path环境变量是Windows系统的变量机制，它的作用是在系统执行某一指令时指引操作系统根据它所指示的路径在电脑中寻找该指令，告诉windows操作系统去哪里找这个命令文件，如果没有找到，则运行会报错。Java只是配置环境变量时用了一下Path变量而已。</span><br></pre></td></tr></table></figure><h3 id="3-环境变量CLASSPATH的作用是什么？"><a href="#3-环境变量CLASSPATH的作用是什么？" class="headerlink" title="3 环境变量CLASSPATH的作用是什么？"></a>3 环境变量CLASSPATH的作用是什么？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CLASSPATH环境变量作用是指定类搜索路径，要使用已经编写好的类，前提当然是能够找到它们，JVM就是通过CLASSPTH来寻找类的。</span><br><span class="line">只有类在ClassPath中，java命令才能找到它，并解释它。</span><br></pre></td></tr></table></figure><h3 id="4-什么是JVM，其工作原理是什么样的？"><a href="#4-什么是JVM，其工作原理是什么样的？" class="headerlink" title="4 什么是JVM，其工作原理是什么样的？"></a>4 什么是JVM，其工作原理是什么样的？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。</span><br><span class="line">工作原理：Java源文件在通过编译器后被编译成相应的 .Class 文件（字节码文件），.Class 文件又被JVM中的解释器编译成机器码在不同的操作系统（Windows、Linux、Mac）上运行。每种操作系统的解释器是不同的，但基于解释器实现的虚拟机是相同的，这也是Java能够跨平台的原因。</span><br></pre></td></tr></table></figure><h3 id="5-如何理解Java中的装箱和拆箱？"><a href="#5-如何理解Java中的装箱和拆箱？" class="headerlink" title="5 如何理解Java中的装箱和拆箱？"></a>5 如何理解Java中的装箱和拆箱？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">装箱就是 自动将基本数据类型转换为包装器类型。</span><br><span class="line">拆箱就是 自动将包装器类型转换为基本数据类型。</span><br></pre></td></tr></table></figure><h3 id="6-Java中equals方法和-x3D-x3D-的区别是什么？"><a href="#6-Java中equals方法和-x3D-x3D-的区别是什么？" class="headerlink" title="6 Java中equals方法和&#x3D;&#x3D;的区别是什么？"></a>6 Java中equals方法和&#x3D;&#x3D;的区别是什么？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">对于基本类型，==比较的是值；</span><br><span class="line">对于引用类型，==比较的是地址；</span><br><span class="line">equals不能用于基本类型的比较；</span><br><span class="line">如果没有重写equals，equals就相当于==；</span><br><span class="line">如果重写了equals方法，equals比较的是对象的内容；</span><br></pre></td></tr></table></figure><h3 id="7-类和对象有什么区别？"><a href="#7-类和对象有什么区别？" class="headerlink" title="7 类和对象有什么区别？"></a>7 类和对象有什么区别？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1，类是一个抽象的概念，它不存在于现实中的时间/空间里，类只是为所有的对象定义了抽象的属性与行为。就好像“Person（人）”这个类，它虽然可以包含很多个体，但它本身不存在于现实世界上。</span><br><span class="line"></span><br><span class="line">2，对象是类的一个具体。它是一个实实在在存在的东西。</span><br><span class="line"></span><br><span class="line">3，类是一个静态的概念，类本身不携带任何数据。当没有为类创建任何对象时，类本身不存在于内存空间中。</span><br><span class="line"></span><br><span class="line">4，对象是一个动态的概念。每一个对象都存在着有别于其它对象的属于自己的独特的属性和行为。对象的属性可以随着它自己的行为而发生改变。</span><br></pre></td></tr></table></figure><h3 id="8-Java中成员变量的特点有哪些？"><a href="#8-Java中成员变量的特点有哪些？" class="headerlink" title="8 Java中成员变量的特点有哪些？"></a>8 Java中成员变量的特点有哪些？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">成员变量处在类中方法外</span><br><span class="line">成员变量随着对象的创建而创建，随对象的消失而消失</span><br><span class="line">成员变量由类的对象进行调用</span><br><span class="line">成员变量存储在堆内存中</span><br><span class="line">成员变量具有默认的初始值</span><br></pre></td></tr></table></figure><h3 id="9-Java中静态变量的特点有哪些？"><a href="#9-Java中静态变量的特点有哪些？" class="headerlink" title="9 Java中静态变量的特点有哪些？"></a>9 Java中静态变量的特点有哪些？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">静态变量用static修饰，处于成员变量的位置</span><br><span class="line">静态变量随着类的加载而存在，随着类的执行结束而消失</span><br><span class="line">静态变量存储在堆内存中（JDK8以前存储在方法区中）</span><br><span class="line">静态成员的存储位置</span><br><span class="line">静态变量可由类或者类的对象进行调用</span><br></pre></td></tr></table></figure><h3 id="10-Java中子类的构造函数如何为父类传递参数？"><a href="#10-Java中子类的构造函数如何为父类传递参数？" class="headerlink" title="10 Java中子类的构造函数如何为父类传递参数？"></a>10 Java中子类的构造函数如何为父类传递参数？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">显式： 构造方法的第一行super(n..)  n 个参数</span><br><span class="line">隐式： 子对象构造方法会默认调用父类的无参构造方法，即super(). 所以父类中如果没有无参构造，则子类必须显式的调用父类的有参构造方法</span><br></pre></td></tr></table></figure><h3 id="11-this与super的区别？"><a href="#11-this与super的区别？" class="headerlink" title="11 this与super的区别？"></a>11 this与super的区别？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. this是当前对象的引用，当前对象即调用实例方法的对象，super相当于是子类对象中从父类继承下来部分成员的引用。</span><br><span class="line"> </span><br><span class="line">2. 在非静态成员方法中，this用来访问本类的方法和属性，super用来访问父类继承下来的方法和属性。</span><br><span class="line"> </span><br><span class="line">3. 在构造方法中：this()用于调用本类构造方法，super()用于调用父类构造方法，两种调用不能同时在构造方法中出现。</span><br><span class="line"> </span><br><span class="line">4. 构造方法中一定会存在super()的调用（调用默认或者无参的时候），没有写编译器也会增加，但是this()不写则没有。</span><br></pre></td></tr></table></figure><h3 id="12-接口和抽象类的区别？"><a href="#12-接口和抽象类的区别？" class="headerlink" title="12 接口和抽象类的区别？"></a>12 接口和抽象类的区别？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">接口是行为的抽象，是一种行为的规范，接口是like a 的关系；抽象是对类的抽象，是一种模板设计，抽象类是is a 的关系。</span><br><span class="line">接口没有构造方法，而抽象类有构造方法，其方法一般给子类使用</span><br><span class="line">接口只有定义，不能有方法的实现，java 1.8中可以定义default方法体，而抽象类可以有定义与实现，方法可在抽象类中实现。</span><br><span class="line">抽象体现出了继承关系，继承只能单继承。接口提现出来了实现的关系，实现可以多实现。接口强调特定功能的实现，而抽象类强调所属关系。</span><br><span class="line">接口成员变量默认为public static final，必须赋初值，不能被修改；其所有的成员方法都是public abstract的。抽象类中成员变量默认default，可在子类中被重新定义，也可被重新赋值；抽象方法被abstract修饰，不能被private、static、synchronized和native等修饰，必须以分号结尾，不带花括号。 </span><br></pre></td></tr></table></figure><h3 id="13-字符串字面量是否自动生成一个String对象？"><a href="#13-字符串字面量是否自动生成一个String对象？" class="headerlink" title="13 字符串字面量是否自动生成一个String对象？"></a>13 字符串字面量是否自动生成一个String对象？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">是</span><br></pre></td></tr></table></figure><h3 id="14-字符串对象池的作用是什么？"><a href="#14-字符串对象池的作用是什么？" class="headerlink" title="14 字符串对象池的作用是什么？"></a>14 字符串对象池的作用是什么？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象池的存在是为了避免频繁的创建和销毁对象而影响系统性能</span><br></pre></td></tr></table></figure><h3 id="15-StringBuffer和StringBuilder的区别以及存在的作用？"><a href="#15-StringBuffer和StringBuilder的区别以及存在的作用？" class="headerlink" title="15 StringBuffer和StringBuilder的区别以及存在的作用？"></a>15 StringBuffer和StringBuilder的区别以及存在的作用？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、StringBuffer 与 StringBuilder 中的方法和功能完全是等价的，</span><br><span class="line"></span><br><span class="line">2、只是StringBuffer 中的方法大都采用了 synchronized 关键字进行修饰，因此是线程安全的，而 StringBuilder 没有这个修饰，可以被认为是线程不安全的。 </span><br><span class="line"></span><br><span class="line">3、在单线程程序下，StringBuilder效率更快，因为它不需要加锁，不具备多线程安全而StringBuffer则每次都需要判断锁，效率相对更低</span><br></pre></td></tr></table></figure><p>16 简述数组的内存原理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组是存放在连续内存空间上的相同类型数据的集合</span><br></pre></td></tr></table></figure><h3 id="17-迭代器是什么？"><a href="#17-迭代器是什么？" class="headerlink" title="17 迭代器是什么？"></a>17 迭代器是什么？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">迭代器（Iterator）是一个对象，它的工作是遍历并选择序列中的对象，它提供了一种访问一个容器（container）对象中的各个元素，而不必暴露该对象内部细节的方法。通过迭代器，开发人员不需要了解容器底层的结构，就可以实现对容器的遍历。</span><br></pre></td></tr></table></figure><h3 id="18-比较器是什么？"><a href="#18-比较器是什么？" class="headerlink" title="18 比较器是什么？"></a>18 比较器是什么？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">比较器是java中一个接口，该接口用于对用户定义类的对象进行排序和比较。</span><br></pre></td></tr></table></figure><h3 id="19-Vector、ArrayList和LinkedList的区别？"><a href="#19-Vector、ArrayList和LinkedList的区别？" class="headerlink" title="19 Vector、ArrayList和LinkedList的区别？"></a>19 Vector、ArrayList和LinkedList的区别？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ArrayList:作为List接口的主要实现类，线程不安全的，执行效率高，底层使用Object[]存储</span><br><span class="line">LinkedList:对于频繁的插入和删除操作，使用此类比ArrayList效率高，底层使用双向链表存储</span><br><span class="line">Vector:作为List接口的古老实现类，线程安全的，执行效率低，底层使用Object[]存储</span><br><span class="line"></span><br><span class="line">ArrayList底层通过动态数组实现，而LinkedList底层通过双向链表实现</span><br><span class="line">ArrayList根据索引查找元素的效率比较高，但是插入、删除数据时性能比较低，需要将待插入或删除元素之后的元素往后或往前移动</span><br><span class="line">LinkedList查询元素的效率比较低，需要从头部或尾部开始查找，挨个遍历每一个元素直到找到所需元素，但是插入、删除元素的效率比较高</span><br><span class="line"></span><br><span class="line">Vector是线程安全的，而ArrayList是线程不安全的，Vector类中的方法通过synchronized修饰实现线程的同步，但实现同步需要很高的开销，这也导致了访问Vector比ArrayList慢</span><br><span class="line">ArrayList和Vector都是采用连续的内存空间存储元素，但是当空间不足的时候，两个类扩容的方式是不同的。（ArrayList每次存储时会检查空间大小，不够时会扩充为原来的1.5倍，Vector会扩充为原来空间的2倍</span><br></pre></td></tr></table></figure><h3 id="20-HashMap、HashTable和TreeMap的区别？"><a href="#20-HashMap、HashTable和TreeMap的区别？" class="headerlink" title="20 HashMap、HashTable和TreeMap的区别？"></a>20 HashMap、HashTable和TreeMap的区别？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、HashTable的方法是同步的，HashMap未经同步，所以在多线程场合要手动同步HashMap这个区别就像Vector和ArrayList一样。</span><br><span class="line">2、HashTable不允许null值，key和value都不可以,HashMap允许null值，key和value都可以。</span><br><span class="line">3、HashTable使用Enumeration，HashMap使用Iterator。 </span><br><span class="line">4、HashTable使用Enumeration，HashMap使用Iterator</span><br><span class="line">5、哈希值的使用不同，HashTable直接使用对象的hashCode。</span><br></pre></td></tr></table></figure><h3 id="21-什么样的数据集合可以使用foreach循环？"><a href="#21-什么样的数据集合可以使用foreach循环？" class="headerlink" title="21 什么样的数据集合可以使用foreach循环？"></a>21 什么样的数据集合可以使用foreach循环？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组或者实现了Iterable接口的类实例</span><br></pre></td></tr></table></figure><h3 id="22-字节流与字符流的区别？"><a href="#22-字节流与字符流的区别？" class="headerlink" title="22 字节流与字符流的区别？"></a>22 字节流与字符流的区别？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、字节流操作的基本单元为字节；字符流操作的基本单元为Unicode码元。</span><br><span class="line">2、字节流默认不使用缓冲区；字符流使用缓冲区。</span><br><span class="line">3、字节流通常用于处理二进制数据，实际上它可以处理任意类型的数据，但它不支持直接写入或读取Unicode码元；字符流通常处理文本数据，它支持写入及读取Unicode码元。</span><br></pre></td></tr></table></figure><h3 id="23-字节流的处理方式有哪些？"><a href="#23-字节流的处理方式有哪些？" class="headerlink" title="23 字节流的处理方式有哪些？"></a>23 字节流的处理方式有哪些？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InputStream是所有字节输入流的超类</span><br><span class="line">OutputStream是所有字节输出流的超类</span><br></pre></td></tr></table></figure><h3 id="24-字符流的处理方式有哪些？"><a href="#24-字符流的处理方式有哪些？" class="headerlink" title="24 字符流的处理方式有哪些？"></a>24 字符流的处理方式有哪些？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Reader是所有读取字符串输入流的超类</span><br><span class="line">writer是所有输出字符串的超类</span><br></pre></td></tr></table></figure><h3 id="25-什么是序列化？"><a href="#25-什么是序列化？" class="headerlink" title="25 什么是序列化？"></a>25 什么是序列化？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决在对对象流进行读写操作时所引发的问题</span><br></pre></td></tr></table></figure><h3 id="26-解释进程和线程的区别"><a href="#26-解释进程和线程的区别" class="headerlink" title="26 解释进程和线程的区别"></a>26 解释进程和线程的区别</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、进程是系统分配资源的最小单位，线程是cpu调度的最小单位</span><br><span class="line">2、进程拥有独立的地址空间，一个进程包含多个线程，多个线程共享地址空间</span><br><span class="line">3、在java中一个进程对应一个JVM对象实例，多个线程运行在jvm中</span><br></pre></td></tr></table></figure><h3 id="27-实现线程的方式有哪些？"><a href="#27-实现线程的方式有哪些？" class="headerlink" title="27 实现线程的方式有哪些？"></a>27 实现线程的方式有哪些？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、继承Thread类，重写run()方法</span><br><span class="line">2、实现Runnable接口，重写run()方法</span><br><span class="line">3、实现Callable接口，该接口中的call方法可以在线程执行结束时产生一个返回值</span><br></pre></td></tr></table></figure><h3 id="28-如何使用synchronized来让线程同步？"><a href="#28-如何使用synchronized来让线程同步？" class="headerlink" title="28 如何使用synchronized来让线程同步？"></a>28 如何使用synchronized来让线程同步？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">synchronized方法控制&quot;对象&quot;的访问，每一个对象对应一把锁，每个synchronized方法都必须获得调用该方法的对象的锁才能执行，否则线程会阻塞，方法一旦执行，就独占该锁，直到该方法返回才释放锁，后面被阻塞的线程才能获得这个锁，继续执行</span><br></pre></td></tr></table></figure><h3 id="29-为什么会有线程安全问题？"><a href="#29-为什么会有线程安全问题？" class="headerlink" title="29 为什么会有线程安全问题？"></a>29 为什么会有线程安全问题？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、多个线程之间操作同一个数据，至少有一个线程修改这个数据</span><br><span class="line">2、一条语句对应多个指令，线程调度可以发生任何时刻，所以线程调度不确定性导致指令顺序不确定</span><br></pre></td></tr></table></figure><h3 id="30-什么是锁并解释死锁的原因？"><a href="#30-什么是锁并解释死锁的原因？" class="headerlink" title="30 什么是锁并解释死锁的原因？"></a>30 什么是锁并解释死锁的原因？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">锁是用来控制多个线程访问共享资源的方式，一般来说，一个锁能够防止多个线程同时访问共享资源。</span><br><span class="line"></span><br><span class="line">死锁的原因：</span><br><span class="line">1、竞争资源</span><br><span class="line">2、进程推进顺序不当</span><br></pre></td></tr></table></figure><h3 id="31-反射的原理是什么？"><a href="#31-反射的原理是什么？" class="headerlink" title="31 反射的原理是什么？"></a>31 反射的原理是什么？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过class、constructor、field、method四个方法获取一个类的各个组成部分</span><br></pre></td></tr></table></figure><h3 id="32-Class类的含义和作用是什么？"><a href="#32-Class类的含义和作用是什么？" class="headerlink" title="32 Class类的含义和作用是什么？"></a>32 Class类的含义和作用是什么？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class的意思为“类”，是java中的一个类，是定义一个特定类的实现，存在于java.lang包中，它的构造函数是私有的，由JVM创建Class对象，可以通过getClass()方法获取到Class对象。</span><br></pre></td></tr></table></figure><h3 id="33-创建对象有哪几种形式？"><a href="#33-创建对象有哪几种形式？" class="headerlink" title="33 创建对象有哪几种形式？"></a>33 创建对象有哪几种形式？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、new关键字   </span><br><span class="line">2、Class.newInstance  </span><br><span class="line">3、Constructor.newInstance </span><br><span class="line">4、Clone方法 </span><br><span class="line">5、反序列化</span><br></pre></td></tr></table></figure><h3 id="34-如何利用反射机制来访问一个类的私有成员？"><a href="#34-如何利用反射机制来访问一个类的私有成员？" class="headerlink" title="34 如何利用反射机制来访问一个类的私有成员？"></a>34 如何利用反射机制来访问一个类的私有成员？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用setAccessible(boolean flag)方法</span><br></pre></td></tr></table></figure><h3 id="35-什么是TCP什么是UDP？"><a href="#35-什么是TCP什么是UDP？" class="headerlink" title="35 什么是TCP什么是UDP？"></a>35 什么是TCP什么是UDP？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TCP：传输控制协议，是一种面向连接的、可靠的、基于字节流的传输层通信协议。</span><br><span class="line">UDP：用户数据报协议，是一种面向无连接，不可靠、以数据报文段的形式传输的传输层通信协议。</span><br></pre></td></tr></table></figure><h3 id="36-简述七层网络模型架构"><a href="#36-简述七层网络模型架构" class="headerlink" title="36 简述七层网络模型架构"></a>36 简述七层网络模型架构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">应用层确定通信对象，提供访问网络服务的接口</span><br><span class="line">表示层负责数据的编码、转化（界面与二进制数据转换，高级语言与机器语言的转换）数据压缩、解压，加密、解密。根据不同应用目的处理为不同的格式，表现出来就是我们看到的各种各样的文件扩展名。</span><br><span class="line">会话层负责建立、维护、控制会话单工(Simplex)、半双工(Half duplex)、全双工(Full duplex)三种通信模式的服务</span><br><span class="line">传输层负责分割、组合数据，实现端到端的逻辑连接三次握手(Three-way handshake)，面向连接(Connection-Oriented)或非面向连接(Connectionless-Oriented)的服务，流控(Flow control)等都发生在这一层。是第一个端到端，即主机到主机的层次。</span><br><span class="line">网络层负责管理网络地址，定位设备，决定路由</span><br><span class="line">数据链路层负责准备物理传输，CRC校验，错误通知，网络拓扑，流控等</span><br><span class="line">物理层就是实实在在的物理链路，负责将数据以比特流的方式发送、接收</span><br></pre></td></tr></table></figure><h3 id="37-简述对TCP-x2F-IP协议的理解"><a href="#37-简述对TCP-x2F-IP协议的理解" class="headerlink" title="37 简述对TCP&#x2F;IP协议的理解"></a>37 简述对TCP&#x2F;IP协议的理解</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TCP/IP 是IP、TCP、HTTP等协议的集合。协议就是计算机与计算机之间通过网络实现通信时事先达成的一种约定。两台计算机之间必须能够支持相同的的协议，并循序相同的协议进行处理，才能实现相互通讯</span><br></pre></td></tr></table></figure><h3 id="38-什么是IP？"><a href="#38-什么是IP？" class="headerlink" title="38 什么是IP？"></a>38 什么是IP？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IP地址是IP协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。</span><br><span class="line">IP协议是为计算机网络相互连接进行通信而设计的协议</span><br></pre></td></tr></table></figure><h3 id="39-什么是NAT？"><a href="#39-什么是NAT？" class="headerlink" title="39 什么是NAT？"></a>39 什么是NAT？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NAT是一种地址交换技术，它可以将IP数据报文头中的IP地址转换为另一个IP地址，并通过转换端口号达到地址重用的目的。NAT作为一种缓解IPv4公网地址枯竭的过渡技术，由于实现简单，得到了广泛应用。</span><br></pre></td></tr></table></figure><h3 id="40-什么是DNS？"><a href="#40-什么是DNS？" class="headerlink" title="40 什么是DNS？"></a>40 什么是DNS？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将域名解析为IP地址，输入网址后，首先会查询本地DNS缓存，无果后再查询本地DNS服务器。</span><br></pre></td></tr></table></figure><h3 id="41-什么是DHCP？"><a href="#41-什么是DHCP？" class="headerlink" title="41 什么是DHCP？"></a>41 什么是DHCP？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">动态分配IP地址协议，DHCP客户端从DHCP服务器获得DHCP服务器的IP地址、DNS服务器的IP地址、默认网关的IP地址等。</span><br></pre></td></tr></table></figure><h3 id="42-子网掩码是干什么的？"><a href="#42-子网掩码是干什么的？" class="headerlink" title="42 子网掩码是干什么的？"></a>42 子网掩码是干什么的？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">子网掩码用来指明一个IP地址所标示的主机是处于哪个子网中的。子网掩码不能单独存在，它必须结合IP地址一起使用。子网掩码只有一个作用，就是将某个IP地址划分成网络地址和主机地址两部分</span><br></pre></td></tr></table></figure><h3 id="43-IP地址分类有哪些？"><a href="#43-IP地址分类有哪些？" class="headerlink" title="43 IP地址分类有哪些？"></a>43 IP地址分类有哪些？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">A类：(1.0.0.0-126.0.0.0)（默认子网掩码：255.0.0.0或 0xFF000000）第一个字节为网络号，后三个字节为主机号。该类IP地址的最前面为“0”，所以地址的网络号取值于1~126之间。一般用于大型网络。</span><br><span class="line"></span><br><span class="line">B类：(128.0.0.0-191.255.0.0)（默认子网掩码：255.255.0.0或0xFFFF0000）前两个字节为网络号，后两个字节为主机号。该类IP地址的最前面为“10”，所以地址的网络号取值于128~191之间。一般用于中等规模网络。</span><br><span class="line"></span><br><span class="line">C类：(192.0.0.0-223.255.255.0)（子网掩码：255.255.255.0或 0xFFFFFF00）前三个字节为网络号，最后一个字节为主机号。该类IP地址的最前面为“110”，所以地址的网络号取值于192~223之间。一般用于小型网络。</span><br><span class="line"></span><br><span class="line">D类：是多播地址。该类IP地址的最前面为“1110”，所以地址的网络号取值于224~239之间。一般用于多路广播用户。</span><br><span class="line"></span><br><span class="line">E类：是保留地址。该类IP地址的最前面为“1111”，所以地址的网络号取值于240~255之间。</span><br></pre></td></tr></table></figure><h3 id="44-Java与C-x2F-C-有什么异同？"><a href="#44-Java与C-x2F-C-有什么异同？" class="headerlink" title="44 Java与C&#x2F;C++有什么异同？"></a>44 Java与C&#x2F;C++有什么异同？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Java与C++都是面向对象语言，都使用了面向对象思想（例如封装、继承、多态等），由于面向对象有许多非常好的特性（继承、组合等），因此二者都有很好的可重用性。</span><br><span class="line"></span><br><span class="line">二者的不同点：</span><br><span class="line">1.Java为解释性语言，C++为编译型语言</span><br><span class="line">2.Java为纯面向对象语言，C++兼具面向过程和面向对象编程的特点</span><br><span class="line">3.Java语言没有指针概念</span><br><span class="line">4.Java语言不支持多重继承，但引入了接口的概念</span><br><span class="line">5.Java语言提供了垃圾回收器来实现垃圾的自动回收，而C++需要开发人员去管理对内存的分配</span><br><span class="line">6.C++语言支持运算符重载，Java不支持运算法重载</span><br></pre></td></tr></table></figure><h3 id="45-Java中的作用域有哪些？"><a href="#45-Java中的作用域有哪些？" class="headerlink" title="45 Java中的作用域有哪些？"></a>45 Java中的作用域有哪些？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1）public。表明该成员变量或方法对所有类或对象都是可见的，所有类或对象都可以直</span><br><span class="line">接访问。</span><br><span class="line">2）private。表明该成员变量或方法是私有的，只有当前类对其具有访问权限，除此之外</span><br><span class="line">的其他类或者对象都没有访问权限。</span><br><span class="line">3）protected。表明该成员变量或方法对自己及其子类是可见的，即自己和子类具有权限访问，除此之外的其他类或者对象都没有访问权限。</span><br><span class="line">4）default。表明该成员变量或方法只有自己和与其位于同一包内的类可见。若父类与子类位</span><br><span class="line">于同一个包内，则子类对父类的default的成员变量或方法都有访问权限。若父类与子类位于不同的 package（包）内，则没有访问权限。</span><br></pre></td></tr></table></figure><h3 id="46-一个Java文件中是否可以定义多个类？"><a href="#46-一个Java文件中是否可以定义多个类？" class="headerlink" title="46 一个Java文件中是否可以定义多个类？"></a>46 一个Java文件中是否可以定义多个类？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个java文件中可以定义多个类，但是最多只有一个类被public修饰，并且这个类的类名与文件名必须相同</span><br></pre></td></tr></table></figure><h3 id="47-为什么Java中有些接口没有任何方法？"><a href="#47-为什么Java中有些接口没有任何方法？" class="headerlink" title="47 为什么Java中有些接口没有任何方法？"></a>47 为什么Java中有些接口没有任何方法？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因为实现这些接口的类不需要重写任何方法，这些没有任何方法声明的接口又被叫做标识接口，标识接口对实现它的类没有任何语义上的要求，它仅仅充当一个标识的作用，用来表明实现它的类属于一个特定的类型</span><br></pre></td></tr></table></figure><h3 id="48-Java中的clone方法有什么作用？"><a href="#48-Java中的clone方法有什么作用？" class="headerlink" title="48 Java中的clone方法有什么作用？"></a>48 Java中的clone方法有什么作用？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">已知对象A创建出另一个与A具有相同状态的对象B，并且对B的修改不会影响到A的状态</span><br></pre></td></tr></table></figure><h3 id="49-什么是浅拷贝和深拷贝？"><a href="#49-什么是浅拷贝和深拷贝？" class="headerlink" title="49 什么是浅拷贝和深拷贝？"></a>49 什么是浅拷贝和深拷贝？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">浅拷贝：仅仅克隆基本类型变量，不克隆引用类型变量；</span><br><span class="line">深拷贝：既克隆基本类型变量，又克隆引用类型变量；</span><br></pre></td></tr></table></figure><h3 id="50-什么是反射机制？"><a href="#50-什么是反射机制？" class="headerlink" title="50 什么是反射机制？"></a>50 什么是反射机制？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">反射是通过获取类的class对象，然后动态的获取到这个类的内部结构，动态的去操作类的属性和方法。</span><br></pre></td></tr></table></figure><h3 id="51-面向过程与面向对象有什么区别？"><a href="#51-面向过程与面向对象有什么区别？" class="headerlink" title="51 面向过程与面向对象有什么区别？"></a>51 面向过程与面向对象有什么区别？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了；面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。</span><br></pre></td></tr></table></figure><h3 id="52-面向对象的开发方式有什么优点？"><a href="#52-面向对象的开发方式有什么优点？" class="headerlink" title="52 面向对象的开发方式有什么优点？"></a>52 面向对象的开发方式有什么优点？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护</span><br></pre></td></tr></table></figure><h3 id="53-重载和覆盖有什么区别？"><a href="#53-重载和覆盖有什么区别？" class="headerlink" title="53 重载和覆盖有什么区别？"></a>53 重载和覆盖有什么区别？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">重载发生在同一个类中，方法名相同、参数列表、返回类型、权限修饰符可以不同</span><br><span class="line">覆盖发生在子类中，方法名相、参数列表、返回类型都相同，权限修饰符要大于父类方法，声明异常范围要小于父类方法，但是final和private修饰的方法不可重写</span><br></pre></td></tr></table></figure><h3 id="54-final、finally和finalize有什么区别？"><a href="#54-final、finally和finalize有什么区别？" class="headerlink" title="54 final、finally和finalize有什么区别？"></a>54 final、finally和finalize有什么区别？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">final可以修饰类，变量，方法，修饰的类不能被继承，修饰的变量不能重新赋值，修饰的方法不能被重写</span><br><span class="line">finally用于抛异常，finally代码块内语句无论是否发生异常，都会在执行finally，常用于一些流的关闭。</span><br><span class="line">finalize方法用于垃圾回收。</span><br></pre></td></tr></table></figure><h3 id="55-static关键字有哪些作用？"><a href="#55-static关键字有哪些作用？" class="headerlink" title="55 static关键字有哪些作用？"></a>55 static关键字有哪些作用？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第一，为某特定数据类型或对象分配单一的存储空间，而与创建对象的个数无关。</span><br><span class="line">第二，实现某个方法或属性与类而不是对象关联在一起</span><br></pre></td></tr></table></figure><h3 id="56-volatile关键字有哪些作用？"><a href="#56-volatile关键字有哪些作用？" class="headerlink" title="56 volatile关键字有哪些作用？"></a>56 volatile关键字有哪些作用？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.线程的可见性：当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。</span><br><span class="line">2. 顺序一致性：禁止指令重排序。</span><br></pre></td></tr></table></figure><h3 id="57-值传递与引用传递有哪些区别？"><a href="#57-值传递与引用传递有哪些区别？" class="headerlink" title="57 值传递与引用传递有哪些区别？"></a>57 值传递与引用传递有哪些区别？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">值传递：方法调用时，实际参数把它的值传递给对应的形式参数，方法执行中形式参数值的改变不影响实际参数的值。</span><br><span class="line">引用传递: 也称为传地址。方法调用时，实际参数的引用(地址，而不是参数的值)被传递给方法中相对应的形式参数，在方法执行中，对形式参数的操作实际上就是对实际参数的操作，方法执行中形式参数值的改变将会影响实际参数的值。</span><br></pre></td></tr></table></figure><h3 id="58-自动类型转换和强制类型转换是什么？"><a href="#58-自动类型转换和强制类型转换是什么？" class="headerlink" title="58 自动类型转换和强制类型转换是什么？"></a>58 自动类型转换和强制类型转换是什么？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">自动类型转换：对于某些类型的转换编译器可隐式地自动进行，不需人工干预，自动类型转换</span><br><span class="line">强制类型转换：类型转换需要编程者显式指定</span><br></pre></td></tr></table></figure><h3 id="59-Math类中round、ceil和floor方法的区别？"><a href="#59-Math类中round、ceil和floor方法的区别？" class="headerlink" title="59 Math类中round、ceil和floor方法的区别？"></a>59 Math类中round、ceil和floor方法的区别？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">round:取接近的整数</span><br><span class="line">ceil:向上取整</span><br><span class="line">floor:向下取整</span><br></pre></td></tr></table></figure><h3 id="60-i-与-i的区别？"><a href="#60-i-与-i的区别？" class="headerlink" title="60 i++与++i的区别？"></a>60 i++与++i的区别？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i++是先赋值，然后再自增；</span><br><span class="line">++i是先自增，后赋值。</span><br></pre></td></tr></table></figure><h3 id="61-lengt与length-的区别？"><a href="#61-lengt与length-的区别？" class="headerlink" title="61 lengt与length()的区别？"></a>61 lengt与length()的区别？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">length：用于基本类型数组，得到数组容量。</span><br><span class="line">length():用于String类型的字符串中，用于获取字符串的长度。</span><br></pre></td></tr></table></figure><h3 id="62-异常处理的原理是什么？"><a href="#62-异常处理的原理是什么？" class="headerlink" title="62 异常处理的原理是什么？"></a>62 异常处理的原理是什么？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">抛出异常：当方法出现错误而引发异常时，方法创建异常对象并交付运行系统，异常对象包含异常类型和异常出现时的程序状态等异常信息。运行系统负责寻找处置异常的代码并执行</span><br><span class="line">捕捉异常：方法抛出异常后，运行系统寻找合适的异常处理器。潜在的异常处理器是异常发生时依次存留在调用栈中方法集合。当异常处理器所能处理的异常类型与方法抛出的异常类型相符时，即为合适的异常处理器。运行系统从发生异常的方法开始，依次回查调用栈中的方法，直至找到含有合适异常处理器的方法并执行。当运行系统遍历调用栈而未找到合适的异常处理器，则运行系统终止。</span><br></pre></td></tr></table></figure><h3 id="63-run-与start-的区别？"><a href="#63-run-与start-的区别？" class="headerlink" title="63 run()与start()的区别？"></a>63 run()与start()的区别？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、start方法用来启动相应的线程；</span><br><span class="line">2、run方法只是thread的一个普通方法，在主线程里执行；</span><br><span class="line">3、需要并行处理的代码放在run方法中，start方法启动线程后自动调用run方法；</span><br><span class="line">4、run方法必须是public的访问权限，返回类型为void。</span><br></pre></td></tr></table></figure><h3 id="64-amp-与-amp-amp-的区别？"><a href="#64-amp-与-amp-amp-的区别？" class="headerlink" title="64 &amp;与&amp;&amp;的区别？"></a>64 &amp;与&amp;&amp;的区别？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">按位与：a&amp;b是把a和b都转换成二进制数然后再进行与的运算；</span><br><span class="line">逻辑与：a&amp;&amp;b就是当且仅当两个操作数均为 true时，其结果才为 true，只要有一个为false，a&amp;&amp;b就为false</span><br></pre></td></tr></table></figure><h3 id="65-short-s1-x3D-1-s1-x3D-s1-1-有什么错"><a href="#65-short-s1-x3D-1-s1-x3D-s1-1-有什么错" class="headerlink" title="65 short s1 &#x3D; 1; s1 &#x3D; s1 + 1;有什么错?"></a>65 short s1 &#x3D; 1; s1 &#x3D; s1 + 1;有什么错?</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s1 + 1，s1是short类型，1是int型，s1会自动转换为int型的1，与1相加后，得到int型的2，与左边类型不匹配</span><br></pre></td></tr></table></figure><h3 id="66-在JAVA中如何跳出当前的多重嵌套循环？"><a href="#66-在JAVA中如何跳出当前的多重嵌套循环？" class="headerlink" title="66 在JAVA中如何跳出当前的多重嵌套循环？"></a>66 在JAVA中如何跳出当前的多重嵌套循环？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、使用break</span><br><span class="line">2、循环条件限制</span><br><span class="line">3、循环内抛出异常</span><br></pre></td></tr></table></figure><h3 id="67-使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？"><a href="#67-使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？" class="headerlink" title="67 使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？"></a>67 使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">引用不能变</span><br></pre></td></tr></table></figure><h3 id="68-静态变量和实例变量的区别？"><a href="#68-静态变量和实例变量的区别？" class="headerlink" title="68 静态变量和实例变量的区别？"></a>68 静态变量和实例变量的区别？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">实例变量属于某个对象的属性，必须创建了实例对象，其中的实例变量才会被分配空间，才能使用这个实例变量</span><br><span class="line">静态变量不属于某个实例对象，而是属于整个类。只要程序加载了类的字节码，不用创建任何实例对象，静态变量就回被分配空间，静态变量就可以被使用了</span><br></pre></td></tr></table></figure><h3 id="69-接口是否可继承接口"><a href="#69-接口是否可继承接口" class="headerlink" title="69 接口是否可继承接口?"></a>69 接口是否可继承接口?</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以</span><br></pre></td></tr></table></figure><h3 id="70-抽象类是否可实现接口"><a href="#70-抽象类是否可实现接口" class="headerlink" title="70 抽象类是否可实现接口?"></a>70 抽象类是否可实现接口?</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以</span><br></pre></td></tr></table></figure><h3 id="71-抽象类是否可继承具体类"><a href="#71-抽象类是否可继承具体类" class="headerlink" title="71 抽象类是否可继承具体类?"></a>71 抽象类是否可继承具体类?</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以</span><br></pre></td></tr></table></figure><h3 id="72-抽象类中是否可以有静态的main方法？"><a href="#72-抽象类中是否可以有静态的main方法？" class="headerlink" title="72 抽象类中是否可以有静态的main方法？"></a>72 抽象类中是否可以有静态的main方法？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以</span><br></pre></td></tr></table></figure><h3 id="73-java中实现多态的机制是什么？"><a href="#73-java中实现多态的机制是什么？" class="headerlink" title="73 java中实现多态的机制是什么？"></a>73 java中实现多态的机制是什么？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过将子类对象引用赋值给超类对象引用变量（向上转型）来实现动态方法调用</span><br></pre></td></tr></table></figure><h3 id="74-error和exception有什么区别？"><a href="#74-error和exception有什么区别？" class="headerlink" title="74 error和exception有什么区别？"></a>74 error和exception有什么区别？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Error属于程序无法处理的错误，是JVM需要负担的责任，无法通过try-catch来进行捕获</span><br><span class="line">Exception: 程序本身可以处理的异常，可以通过catch来进行捕获，通常遇到这种错误，应对其进行处理，使应用程序可以继续正常运行</span><br></pre></td></tr></table></figure><h3 id="75-throw与throws的区别？"><a href="#75-throw与throws的区别？" class="headerlink" title="75 throw与throws的区别？"></a>75 throw与throws的区别？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">throw：作用在方法内，表示抛出具体异常，由方法体内的语句处理；</span><br><span class="line">一定抛出了异常；</span><br><span class="line">throws：作用在方法的声明上，表示抛出异常，由调用者来进行异常处理；</span><br><span class="line">可能出现异常，不一定会发生异常；</span><br></pre></td></tr></table></figure><h3 id="76-sleep-和-wait-有什么区别"><a href="#76-sleep-和-wait-有什么区别" class="headerlink" title="76 sleep() 和 wait() 有什么区别?"></a>76 sleep() 和 wait() 有什么区别?</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、sleep()是Thread类的静态方法。wait()是Object类的方法。</span><br><span class="line">2、sleep()是不释放锁的。wait()是释放锁的。</span><br><span class="line">3、sleep()常用于一定时间内暂停线程执行。wait()常用于线程间交互和通信。</span><br><span class="line">4、sleep()方法睡眠指定时间之后，线程会自动苏醒。wait()方法被调用后，可以通过notify()或notifyAll()来唤醒wait的线程</span><br></pre></td></tr></table></figure><h3 id="77-当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法"><a href="#77-当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法" class="headerlink" title="77 当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法?"></a>77 当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法?</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、一个线程在访问一个对象的一个synchronized方法时，另一个线程可以同时访问这个对象的非同步方法</span><br><span class="line">2、一个线程在访问一个对象的一个synchronized方法时，另一个线程不可以同时访问这个对象的普通同步方法</span><br><span class="line">3、一个线程在访问一个对象的一个synchronized方法时，另一个线程可以同时访问这个对象的静态同步方法 </span><br><span class="line">4、一个线程在访问一个对象的一个static synchronized方法时，另一个线程不可以同时访问这个对象的静态同步方法</span><br></pre></td></tr></table></figure><h3 id="78-线程的基本状态以及状态之间的关系是什么？"><a href="#78-线程的基本状态以及状态之间的关系是什么？" class="headerlink" title="78 线程的基本状态以及状态之间的关系是什么？"></a>78 线程的基本状态以及状态之间的关系是什么？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">线程状态：就绪、运行、阻塞</span><br><span class="line">就绪状态代表线程具备了运行的所有条件，等待CPU的调度；当CPU调度线程后，将进入运行状态；在运行时遇到I/O中断、线程休眠、调用了对象的wait方法就会进入阻塞状态</span><br></pre></td></tr></table></figure><h3 id="79-List、Map、Set三个接口，存取元素时，各有什么特点？"><a href="#79-List、Map、Set三个接口，存取元素时，各有什么特点？" class="headerlink" title="79 List、Map、Set三个接口，存取元素时，各有什么特点？"></a>79 List、Map、Set三个接口，存取元素时，各有什么特点？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List存放元素可以重复，存放元素是有序的</span><br><span class="line">Set 存放元素不可重复</span><br><span class="line">Map存放键值对，键不可重复，值可重复</span><br></pre></td></tr></table></figure><h3 id="80-两个对象值相同-x-equals-y-x3D-x3D-true-，但却可有不同的hashcode，这句话对不对？"><a href="#80-两个对象值相同-x-equals-y-x3D-x3D-true-，但却可有不同的hashcode，这句话对不对？" class="headerlink" title="80 两个对象值相同(x.equals(y) &#x3D;&#x3D; true)，但却可有不同的hashcode，这句话对不对？"></a>80 两个对象值相同(x.equals(y) &#x3D;&#x3D; true)，但却可有不同的hashcode，这句话对不对？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不对</span><br></pre></td></tr></table></figure><h3 id="81-什么是java序列化，如何实现java序列化？或者请解释Serializable接口的作用。"><a href="#81-什么是java序列化，如何实现java序列化？或者请解释Serializable接口的作用。" class="headerlink" title="81 什么是java序列化，如何实现java序列化？或者请解释Serializable接口的作用。"></a>81 什么是java序列化，如何实现java序列化？或者请解释Serializable接口的作用。</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">序列化是通过实现serializable接口，该接口没有需要实现的方法，implement Serializable只是为了标注该对象是可被序列化的，使用一个输出流（FileOutputStream）来构造一个ObjectOutputStream对象，接着使用ObjectOutputStream对象的writeObejct（Object object）方法就可以将参数的obj对象到磁盘，需要恢复的时候使用输入流。</span><br></pre></td></tr></table></figure><h3 id="82-什么是构造函数？"><a href="#82-什么是构造函数？" class="headerlink" title="82 什么是构造函数？"></a>82 什么是构造函数？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">构造函数，也叫构造方法，是JAVA中一种特殊的函数，与函数名相同，无返回值</span><br></pre></td></tr></table></figure><h3 id="83-内部类有哪些？"><a href="#83-内部类有哪些？" class="headerlink" title="83 内部类有哪些？"></a>83 内部类有哪些？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、静态内部类 </span><br><span class="line">2、成员内部类 </span><br><span class="line">3、局部内部类 </span><br><span class="line">4、匿名内部类</span><br></pre></td></tr></table></figure><h3 id="84-instanceof有什么用？"><a href="#84-instanceof有什么用？" class="headerlink" title="84 instanceof有什么用？"></a>84 instanceof有什么用？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">判断一个引用类型变量所指向的对象是否是一个类的实例</span><br></pre></td></tr></table></figure><h3 id="85-什么是GC？"><a href="#85-什么是GC？" class="headerlink" title="85 什么是GC？"></a>85 什么是GC？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GC是垃圾收集的意思，内存处理是开发人员容易出现问题的地方，忘记或者错误地内存回收会导致程序或者系统的不稳定甚至崩溃，Java提供的垃圾回收机制可以自动检测对象是否超过作用域从而达到自动回收的目的</span><br></pre></td></tr></table></figure><h3 id="86-Java中是否存在内存泄漏的问题，并举例说明？"><a href="#86-Java中是否存在内存泄漏的问题，并举例说明？" class="headerlink" title="86 Java中是否存在内存泄漏的问题，并举例说明？"></a>86 Java中是否存在内存泄漏的问题，并举例说明？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、在堆中申请了空间没有被释放；</span><br><span class="line">2、对象已不再被使用，但还仍然在内存中保留着</span><br></pre></td></tr></table></figure><h3 id="87-Java中的堆内存与栈内存有什么区别？"><a href="#87-Java中的堆内存与栈内存有什么区别？" class="headerlink" title="87 Java中的堆内存与栈内存有什么区别？"></a>87 Java中的堆内存与栈内存有什么区别？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">堆内存是区别于栈区、全局数据区和代码区的另一个内存区域。堆允许程序在运行时动态地申请某个大小的内存空间。栈内存在函数中定义的一些基本类型的变量和对象的引用变量都在函数的栈内存中分配。</span><br></pre></td></tr></table></figure><h3 id="88-什么是栈内存溢出？"><a href="#88-什么是栈内存溢出？" class="headerlink" title="88 什么是栈内存溢出？"></a>88 什么是栈内存溢出？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">栈溢出指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致与其相邻的栈中的变量的值被改变</span><br></pre></td></tr></table></figure><h3 id="89-什么是堆内存溢出？"><a href="#89-什么是堆内存溢出？" class="headerlink" title="89 什么是堆内存溢出？"></a>89 什么是堆内存溢出？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">申请内存空间时，超出最大堆内存空间，系统给不了</span><br></pre></td></tr></table></figure><h3 id="90什么是整数溢出？"><a href="#90什么是整数溢出？" class="headerlink" title="90什么是整数溢出？"></a>90什么是整数溢出？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">整数在内存里面保存在一个固定长度的空间内，它能存储的最大值和最小值是固定的，如果我们尝试去存储一个数，而这个数又大于这个固定的最大值时，就会导致整数溢出</span><br></pre></td></tr></table></figure><h3 id="91-同步和异步有什么区别？"><a href="#91-同步和异步有什么区别？" class="headerlink" title="91 同步和异步有什么区别？"></a>91 同步和异步有什么区别？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">同步:发送一个请求,等待返回,然后再发送下一个请求 </span><br><span class="line">异步:发送一个请求,不等待返回,随时可以再发送下一个请求</span><br></pre></td></tr></table></figure><h3 id="92-终止线程的方法有哪些？"><a href="#92-终止线程的方法有哪些？" class="headerlink" title="92 终止线程的方法有哪些？"></a>92 终止线程的方法有哪些？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、正常运行结束 </span><br><span class="line">2、使用退出标签退出线程 </span><br><span class="line">3、Interrupt方法结束线程 </span><br><span class="line">4、stop方法结束线程</span><br></pre></td></tr></table></figure><h3 id="93-什么是单例模式？"><a href="#93-什么是单例模式？" class="headerlink" title="93 什么是单例模式？"></a>93 什么是单例模式？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">保证一个类只有一个实列，并提供一个访问它的全局访问点。</span><br></pre></td></tr></table></figure><h3 id="94-什么是工厂模式？"><a href="#94-什么是工厂模式？" class="headerlink" title="94 什么是工厂模式？"></a>94 什么是工厂模式？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">定义一个创建对象的接口，但由子类决定需要实例化哪一个类。使得子类实例化过程推迟。</span><br></pre></td></tr></table></figure><h3 id="95-什么是适配器模式？"><a href="#95-什么是适配器模式？" class="headerlink" title="95 什么是适配器模式？"></a>95 什么是适配器模式？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将一个类的接口转换成用户希望得到的另一种接口。使原本不相容的接口得以协同工作。</span><br></pre></td></tr></table></figure><h3 id="96-什么是观察者模式？"><a href="#96-什么是观察者模式？" class="headerlink" title="96 什么是观察者模式？"></a>96 什么是观察者模式？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖它的对象都得到通知并自动更新。</span><br></pre></td></tr></table></figure><h3 id="97-什么是代理模式？"><a href="#97-什么是代理模式？" class="headerlink" title="97 什么是代理模式？"></a>97 什么是代理模式？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">为其他对象提供一种代理以控制这个对象的访问。</span><br></pre></td></tr></table></figure><h3 id="98-什么是NIO？"><a href="#98-什么是NIO？" class="headerlink" title="98 什么是NIO？"></a>98 什么是NIO？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">同步非阻塞NIO：NIO主要是想解决BIO的大并发问题，BIO是每一个请求分配一个线程，当请求过多时，每个线程占用一定的内存空间，服务器瘫痪了。</span><br></pre></td></tr></table></figure><h3 id="99-迭代器的实现原理是什么？"><a href="#99-迭代器的实现原理是什么？" class="headerlink" title="99 迭代器的实现原理是什么？"></a>99 迭代器的实现原理是什么？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在ArrayList类下有一个成员内部类Itr,它实现了Iterator接口，内部类中定义了一个游标成员变量，通过hasNext方法来判断游标后是否有下一个元素，如果有就把元素添加到Object数组中，然后继续下一个判断；如果没有就结束</span><br></pre></td></tr></table></figure><h3 id="100-垃圾回收有哪些算法并详细阐述原理"><a href="#100-垃圾回收有哪些算法并详细阐述原理" class="headerlink" title="100 垃圾回收有哪些算法并详细阐述原理"></a>100 垃圾回收有哪些算法并详细阐述原理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、引用计数法：假设有一个对象A，任何一个对象对A的引用，那么对象A的引用计数器+1，当引用失败时，对象A的引用计数器就-1，如果对象A的计算器的值为0，就说明对象A没有引用了，可以被回收。</span><br><span class="line">2、标记清除法：标记 ：从根节点开始标记引用的对象。</span><br><span class="line"> 清除 ：未被标记引用的对象就是垃圾对象，可以被清理</span><br><span class="line">3、标记压缩算法：在标记清除法的基础上在清理阶段，并不是简单的清理未标记的对象，而是将存活的对象压缩到内存的一端，然后清理边界以外的垃圾</span><br><span class="line">4、复制算法：复制算法的核心就是，将原有的内存空间一分为二，每次只用其中的一块，在垃圾回收时，将正在使用的对象复制到另一个内存空间中，然后将该内存空间清空，交换两个内存的角色，完成垃圾的回收。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git</title>
      <link href="/post/69c3279c.html"/>
      <url>/post/69c3279c.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、版本控制工具简介"><a href="#一、版本控制工具简介" class="headerlink" title="一、版本控制工具简介"></a>一、版本控制工具简介</h1><p>版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统，方便查看更改历史，备份以及恢复以前的版本，保证多人的协作不出问题</p><h2 id="1-原始的版本控制"><a href="#1-原始的版本控制" class="headerlink" title="1.  原始的版本控制"></a>1.  原始的版本控制</h2><p>版本控制工具的黑暗时代：</p><ul><li>最原始的版本控制是纯手工的版本控制：修改文件，保存文件副本</li><li>保存副本命名随意→版本难辨新旧，不能辨别每一版的修改内容</li></ul><h2 id="2-版本控制的起源：diff与patch"><a href="#2-版本控制的起源：diff与patch" class="headerlink" title="2.  版本控制的起源：diff与patch"></a>2.  版本控制的起源：diff与patch</h2><ul><li>在最初的版本控制软件出现之前，其实已经有了比较好用的源码比较与打补丁的工具：diff与patch</li><li>Linus Torvalds(Linux之父)也对这两个工具偏爱有佳</li><li>在1991-2002年之间，即使CVS出现之后，Linus一直使用diff和patch管理着Linux的代码</li><li>diff与patch是用于源码版本控制中的两个最基本的概念</li></ul><h3 id="2-1-diff简介：diff用来比较两个文件或者目录之间的差异"><a href="#2-1-diff简介：diff用来比较两个文件或者目录之间的差异" class="headerlink" title="2.1  diff简介：diff用来比较两个文件或者目录之间的差异"></a>2.1  diff简介：diff用来比较两个文件或者目录之间的差异</h3><p><img src="/post/69c3279c/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220418195948906.png" alt="image-20220418195948906"></p><h3 id="2-2-Patch简介：Patch是diff的反向操作"><a href="#2-2-Patch简介：Patch是diff的反向操作" class="headerlink" title="2.2  Patch简介：Patch是diff的反向操作"></a>2.2  Patch简介：Patch是diff的反向操作</h3><p>我们把上述差异结果保存到文件中，例如diff.txt中，那么这个diff.txt就可以用来从left.c推算出right.c的内容，或者从right.c推算出left.c的内容</p><p><img src="/post/69c3279c/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220418200233010.png" alt="image-20220418200233010"></p><h2 id="3-RCS：最早期的本地版本控制工具"><a href="#3-RCS：最早期的本地版本控制工具" class="headerlink" title="3.  RCS：最早期的本地版本控制工具"></a>3.  RCS：最早期的本地版本控制工具</h2><p><strong>RCS(Revision Control System)</strong></p><ul><li>RCS作为非常古老的版本工具，远远在SVN和已经退役的CVS之前，它的古老程度应该比Web开发的ASP前代的CGI还要久远</li><li>如果想对版本管理实现方式进行深入研究的话，研究RCS是一种最为简单的入手方式</li><li>RCS采用把diff的集合，采用RCS自己的格式保存到磁盘中(可以通过diff -n left.c right.c 产生RCS格式的diff内容)，能通过这些diff集合，重新回到文件修改的任何历史中的点</li></ul><h2 id="4-CVS-amp-SVN：集中式版本控制工具"><a href="#4-CVS-amp-SVN：集中式版本控制工具" class="headerlink" title="4.CVS &amp; SVN：集中式版本控制工具"></a>4.CVS &amp; SVN：集中式版本控制工具</h2><p><img src="/post/69c3279c/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220418201017293.png" alt="image-20220418201017293"></p><h2 id="5-Git：Linus的第二个伟大作品"><a href="#5-Git：Linus的第二个伟大作品" class="headerlink" title="5.Git：Linus的第二个伟大作品"></a>5.Git：Linus的第二个伟大作品</h2><h3 id="5-1Git的起源"><a href="#5-1Git的起源" class="headerlink" title="5.1Git的起源"></a>5.1Git的起源</h3><p>Linux之父Linus是坚定的CVS反对者，他也同样的反对SVN。2002年Linus顶着开源社区精英的口诛笔伐，选择了一个商业版本控制系统BitKeeper作为Linux内核的代码管理工具。和CVS&#x2F;SVN不同，BitKeeper是属于分布式版本控制系统。</p><p><strong>Git诞生大事记：</strong></p><ul><li>2005年4月3日，开始开发Git</li><li>2005年4月6日，项目发布</li><li>2005年4月7日，Git就可以作为自身的版本控制工具</li><li>2005年4月18日，发生第一个多分支合并</li><li>2005年4月29日，Git的性能就已经达到了Linus的预期</li><li>2005年6月16日，Linux核心2.6.12发布，那时Git已经在维护Linux核心的源代码</li></ul><h3 id="5-2集中式-VS-分布式"><a href="#5-2集中式-VS-分布式" class="headerlink" title="5.2集中式 VS 分布式"></a>5.2集中式 VS 分布式</h3><h4 id="1-记录差异还是记录快照"><a href="#1-记录差异还是记录快照" class="headerlink" title="(1)记录差异还是记录快照"></a>(1)记录差异还是记录快照</h4><ul><li>Git和其他版本控制系统(包括Subversion和近似工具)的主要差别在于<strong>Git对待数据的方法</strong></li><li>感念上来区分，其他大部分系统以文件变更列表的方式存储信息</li><li>这类系统(CVS,Subversion,Perforce,Bazaar等等)将保存的信息看作是一组基本文件和每个文件随时间逐步积累的差异</li></ul><p><img src="/post/69c3279c/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220418202024388.png" alt="image-20220418202024388"></p><ul><li>Git不按照以上方式对待或保存数据，反之，Git更像是把数据看作是对小型文件系统的一组快照</li><li>每次提交更新，或在Git中保存项目状态时，它主要对当时的全部文件制作一个快照并保存这个快照的索引</li><li>为了高效，如果文件没有修改，Git不再重新存储该文件，而是只保留一个链接指向之前存储的文件，Git对待数据更像是一个<strong>快照流</strong></li></ul><p><img src="/post/69c3279c/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220418202424479.png" alt="image-20220418202424479"></p><h4 id="2-脆弱的中央库-VS-强壮的分布库"><a href="#2-脆弱的中央库-VS-强壮的分布库" class="headerlink" title="(2)脆弱的中央库 VS 强壮的分布库"></a>(2)脆弱的中央库 VS 强壮的分布库</h4><p><img src="/post/69c3279c/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220418202545487.png" alt="image-20220418202545487"></p><h3 id="5-3选择合适的版本控制工具"><a href="#5-3选择合适的版本控制工具" class="headerlink" title="5.3选择合适的版本控制工具"></a>5.3选择合适的版本控制工具</h3><h4 id="SVN不适合的领域："><a href="#SVN不适合的领域：" class="headerlink" title="SVN不适合的领域："></a>SVN不适合的领域：</h4><p>跨地域的协同开发</p><p>对代码的高质量追求和代码门禁</p><h4 id="Git不适合的领域："><a href="#Git不适合的领域：" class="headerlink" title="Git不适合的领域："></a>Git不适合的领域：</h4><p>不适合Word等二进制文档的版本控制</p><p>因为：Git无锁定&#x2F;解锁模式，故不能排他式修改，整体的读授权，不能将读授权精细到目录级别</p><p>解决方案：版本库按目录拆分</p><h2 id="6-结语：Git是什么"><a href="#6-结语：Git是什么" class="headerlink" title="6.结语：Git是什么"></a>6.结语：Git是什么</h2><p>Git是一个版本控制工具，而且是一个开源的分布式版本控制工具</p><p>按照Linus本人的描述，Git的很多命令设计是源于BitKeeper，但是Git有更多属性</p><ul><li>极快的速度</li><li>简单的设计</li><li>对非线性开发模式的强力支持(允许成千上万个并行开发的分支)</li><li>完全分布式</li><li>有能力高效管理类似Linux内核一样的超大规模项目(速度和数据量)</li></ul><h2 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h2><ul><li>版本控制工具的发展历史经过：原始人工维护状态，本地RCS，集中式如CVS,SVN和分布式如Git</li><li>版本控制工具提供了协作开发的能力，借助它们我们可以回到任何时间的代码状态</li><li>集中式版本控制工具，几乎所有的动作都需要服务器的参与，并且数据安全性与服务器关系很大</li><li>Git是分布式版本控制工具，除了服务器之前进行按需同步之外，所有的提交操作都不需要服务器</li></ul><h1 id="二、Git安装与配置"><a href="#二、Git安装与配置" class="headerlink" title="二、Git安装与配置"></a>二、Git安装与配置</h1><h2 id="1-Linux下安装Git"><a href="#1-Linux下安装Git" class="headerlink" title="1.Linux下安装Git"></a>1.Linux下安装Git</h2><p>Git诞生于Linux平台并作为版本控制系统率先服务于Linux核心，因此在Linux安装Git是非常方便的。可以通过不同的方法在Linux上安装Git</p><p><strong>安装Git的两种方式：</strong></p><ul><li>一种方法是通过Linux发行版的包管理器安装已经编译好的二进制格式的Git软件包</li><li>另外一种方式就是从Git源码开始安装</li></ul><h3 id="1-1包管理器安装"><a href="#1-1包管理器安装" class="headerlink" title="1.1包管理器安装"></a>1.1包管理器安装</h3><p><strong>Linux系统 Ubuntu 10.10(maverick)或更新版本，Debian(squeeze)或更新版本</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo aptitude install git</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo aptitude install git-doc git-svn git-email gitk</span></span><br></pre></td></tr></table></figure><p>其中Git软件包包含了大部分Git命令，是必装的软件包</p><p>软件包git-svn,git-email,gitk本来也是Git软件包的一部分，但是因为有着不一样的软件包依赖(如更多perl模组，tk等)，所以单独作为软件包发布</p><p><strong>Linux系统：RHRL,Fedora,CentOS等版本：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yum install git</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yum install git-svn git-email gitk</span></span><br></pre></td></tr></table></figure><h3 id="1-2源码安装"><a href="#1-2源码安装" class="headerlink" title="1.2源码安装"></a>1.2源码安装</h3><p>访问Git的官方网站：<a href="http://git-scm.com/">http://git-scm.com/</a> 下载Git源码包，例如：git-2.19.0.tar.gz</p><p>展开源码包，并进入到相应的目录中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tar -jxvf git-2.19.0.tar.bz2</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> git-2.19.0</span></span><br></pre></td></tr></table></figure><p>安装方法写在INSTALL文件当中，参照其中的指示完成安装，下面的命令将Git安装在&#x2F;usr&#x2F;local&#x2F;bin中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make prefix=/usr/local all</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo make prefix=/usr/local install</span></span><br></pre></td></tr></table></figure><p>安装Git文档(可选)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make prefix=/usr/local doc info</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo make prefix=/usr/local install-doc install-html install-info</span></span><br></pre></td></tr></table></figure><h3 id="1-3命令补齐"><a href="#1-3命令补齐" class="headerlink" title="1.3命令补齐"></a>1.3命令补齐</h3><p>Linux的shell环境(bash)通过bash-completion软件包提供命令补齐功能，能够实现在录入命令参数时按一下或两下TAB键，实现参数的自动补齐或提示。例如输入git com后按下TAB键，会自动补齐为git commit</p><p>将Git源码包中的命令补齐脚本复制到bash-completion对应的目录中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cp</span> contrib/completion/git-completion.bash /etc/bash_completion.d/</span></span><br></pre></td></tr></table></figure><p>重新加载自动补齐脚本，使之在当前shell中生效：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">. /etc/bash_completion</span></span><br></pre></td></tr></table></figure><p>为了能够在终端开启时自动加载bash.completion脚本，需要在本地配置文件~&#x2F;.bash_profile或全局文件&#x2F;etc&#x2F;bashrc文件中添加下面的内容:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if [ -f /etc/bash_completion ]; then</span><br><span class="line">. /etc/bash_completion</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h2 id="2-Windows下安装Git"><a href="#2-Windows下安装Git" class="headerlink" title="2.Windows下安装Git"></a>2.Windows下安装Git</h2><p>目前Git提供的Windows安装包自带MinGW(Minimalist GNU for Windows,最简GNU工具集)，在安装后MinGW提供了一个bash提供的shell环境(Git Bash)以及其他相关工具软件，组成了一个最简系统(Minimal SYStem),这样在Git Bash中，Git的使用和在Linux下使用完全一致</p><h3 id="2-1安装Git"><a href="#2-1安装Git" class="headerlink" title="2.1安装Git"></a>2.1安装Git</h3><p><strong>Step1</strong>：到<a href="https://git-scm.com/download/win%E4%B8%8B%E8%BD%BDWindows%E5%AE%89%E8%A3%85%E5%8C%85%EF%BC%8C%E4%BE%8B%E5%A6%82:Git-2.19.0-64-bit.exe">https://git-scm.com/download/win下载Windows安装包，例如:Git-2.19.0-64-bit.exe</a></p><p>执行开始安装，如图：</p><p><img src="/post/69c3279c/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220419101536015.png" alt="image-20220419101536015"></p><p>默认安装到C:\Program Files\Git目录中</p><p><img src="/post/69c3279c/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220419101553318.png" alt="image-20220419101553318"></p><p><strong>Step2</strong>：这里选择一些必要的组件，开源的git-lfs存在一些问题，建议把勾选去掉</p><p><img src="/post/69c3279c/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220419101729289.png" alt="image-20220419101729289"></p><p><strong>Step3</strong>：Git默认的编辑器，建议保持默认，当然你也可以选择其他的，例如 Notepad++</p><p><img src="/post/69c3279c/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220419101854039.png" alt="image-20220419101854039"></p><p><strong>Step4</strong>：在安装过程中会询问是否修改环境变量，建议选择“Use Git Bash Only”,即只在MinGW提供的shell环境中使用Git，不修改PATH环境变量，避免Git自带的工具与Windows下已有的产生冲突</p><p><img src="/post/69c3279c/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220419102353200.png" alt="image-20220419102353200"></p><p>如果不清楚PATH，可以参考<a href="https://en.wikpedia.org/wiki/PATH_%28variable%29,%E7%AE%80%E5%8D%95%E6%9D%A5%E8%AE%B2%E5%B0%B1%E6%98%AF%E4%BD%A0%E8%BE%93%E5%87%BA%E4%B8%80%E6%9D%A1%E5%91%BD%E4%BB%A4%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E7%B3%BB%E7%BB%9F%E4%BC%9A%E4%BB%8EPATH%E8%BF%99%E4%B8%AA%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%AF%BB%E6%89%BE%E5%AE%9E%E7%8E%B0%E8%BF%99%E6%9D%A1%E5%91%BD%E4%BB%A4%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%8C%E6%89%BE%E5%88%B0%E5%90%8E%E5%B0%B1%E5%90%AF%E5%8A%A8%E7%A8%8B%E5%BA%8F">https://en.wikpedia.org/wiki/PATH_%28variable%29,简单来讲就是你输出一条命令的时候，系统会从PATH这个配置中寻找实现这条命令的程序在哪里，找到后就启动程序</a></p><p><strong>Step5</strong>：其他后续提示可以都采取缺省配置，进行安装过程。安装完成后，我们可以在Windows任意目录下，右键单击选中“Git Bash”启动Git Bash</p><p><img src="/post/69c3279c/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220419102558899.png" alt="image-20220419102558899"></p><p>可以执行git version 查看安装的git版本信息</p><p><img src="/post/69c3279c/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220419102609762.png" alt="image-20220419102609762"></p><h3 id="2-2安装TortoiseGit"><a href="#2-2安装TortoiseGit" class="headerlink" title="2.2安装TortoiseGit"></a>2.2安装TortoiseGit</h3><p>在Windows下安装和使用Git有两个不同的方案，除了刚刚的Git安装包，再有一个就是基于msysGit的图形界面工具—TortoiseGit</p><p><strong>TortoiseGit简介</strong></p><p>TortoiseGit提供了Git和Windows资源管理器的整合，提供了Git的图形化操作界面</p><p>像其他TortoiseGit系列产品(TortoiseCVS,TortoiseSVN)一样，Git工作区的目录和文件的图标附加了标识版本控制状态的图像，可以非常直观的看到哪些文件被更改了需要提交。通过对右键菜单的扩展，可以非常方便的在资源管理器中操作Git版本库</p><p><strong>TortoiseGit安装</strong></p><p>安装TortoiseGit非常简单，访问网站<a href="http://code.google.com/p/tortoisegit/,%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85%E5%8C%85%EF%BC%8C%E7%84%B6%E5%90%8E%E6%A0%B9%E6%8D%AE%E6%8F%90%E7%A4%BA%E5%AE%8C%E6%88%90%E5%AE%89%E8%A3%85">http://code.google.com/p/tortoisegit/,下载安装包，然后根据提示完成安装</a></p><p>安装过程中会询问要使用的SSH客户端，缺省使用内置的TortoisePLink(来自PuTTY项目)做为SSH客户端。TortoisePLink和TortoiseGit的整合性更好，可以直接通过对话框设置SSH私钥(PuTTY格式)，而无需再到字符界面去配置SSH私钥和其他配置文件</p><p><img src="/post/69c3279c/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220419103707176.png" alt="image-20220419103707176"></p><p>如果你的本地同时安装了命令行的Git版本，可以通过TortoiseGit的设置对话框选中Git提供的SSH客户端，这样在下载SSH协议的代码仓库的时候，通过命令行与TortoiseGit图形界面都可以使用同一套公钥和密钥</p><p><img src="/post/69c3279c/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220419103949277.png" alt="image-20220419103949277"></p><h2 id="3-Git配置"><a href="#3-Git配置" class="headerlink" title="3.Git配置"></a>3.Git配置</h2><p>Git有三种配置，分别以文件的形式存放在三个不同的地方。可以在命令行中使用git config工具查看这些变量</p><p><strong>系统配置(对所有用户都适用)</strong></p><p>存放在git的安装目录下：%Git%&#x2F;etc&#x2F;gitconfig:若使用git config时用–system选项，读写的就是这个文件：git config –system core。autocrlf</p><p><strong>用户配置(只适用于该用户)</strong></p><p>存放在用户目录下，例如Linux存放在：~&#x2F;gitconfig:若使用git config时用–global选项，读写的就是这个文件：git config –global user.name</p><p><strong>仓库配置(只对当前项目有效)</strong></p><p>当前仓库的配置文件(也就是工作目录中的.git&#x2F;config文件)；若使用git config时用–local选项，读写的就是这个文件：git config –local remote.origin.url</p><p><strong>注：</strong>每一个级别的配置都会覆盖上层的相同配置，例如.git&#x2F;config里的配置会覆盖%Git%&#x2F;etc&#x2F;gitconfig中的同名变量</p><h3 id="3-1配置个人身份"><a href="#3-1配置个人身份" class="headerlink" title="3.1配置个人身份"></a>3.1配置个人身份</h3><p>首次的Git设定(设定身份)</p><p>git config –global user.name “Zhang san”</p><p>git config –global user.email <a href="mailto:&#122;&#x68;&#97;&#x6e;&#x67;&#115;&#x61;&#x6e;&#x31;&#x32;&#51;&#x40;&#x68;&#x75;&#97;&#119;&#x65;&#x69;&#46;&#x63;&#111;&#x6d;">&#122;&#x68;&#97;&#x6e;&#x67;&#115;&#x61;&#x6e;&#x31;&#x32;&#51;&#x40;&#x68;&#x75;&#97;&#119;&#x65;&#x69;&#46;&#x63;&#111;&#x6d;</a></p><p>这个配置信息会在Git仓库中提交的修改信息中体现，但和Git服务器认证使用的密码或者公钥密码无关</p><h3 id="3-2文本换行符配置"><a href="#3-2文本换行符配置" class="headerlink" title="3.2文本换行符配置"></a>3.2文本换行符配置</h3><p>假如你正在Windows上写程序，又或者你正在和其他人合作，他们在Windows上编程，而你却在其他系统上，在这些情况下，你可能会遇到行尾结束符问题，这是因为Windows使用回车和换行两个字符来结束一行，而Mac和Linux只使用换行一个字符，虽然这是小问题，但它会极大的扰乱跨平台协作</p><hr><p>Git可以在你提交时自动的把行结束符CRLF转换成LF，而在迁出代码时把LF转换成CRLF。用core.autocrlf来打开此项功能，如果是在Windows系统上，把它设置成true，这样当迁出代码时，LF会被转换成CRLF:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global core. autocrlf <span class="literal">true</span></span></span><br></pre></td></tr></table></figure><hr><p>Linux或Mac系统使用LF作为行结束符,因此你不想Git在迁出文件时进行自动的转换;当一个以CRLF为行结束符的文件不小心被引入时你肯定想进行修正，把core.autocrlf设置成input来告诉Git在提交时把CRLF转换成LF ,签出时不转换:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global core. autocrlf input</span></span><br></pre></td></tr></table></figure><p>这样会在Windows系统上的签出文件中保留CRLF ,会在Mac和Linux系统上,包括仓库中保留LF。</p><hr><p>如果你是Windows程序员,且正在开发仅运行在Windows.上的项目,可以设置false取消此功能,把回车符记录在库中:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global core. autocrlf <span class="literal">false</span></span></span><br></pre></td></tr></table></figure><h3 id="3-3文本编码配置"><a href="#3-3文本编码配置" class="headerlink" title="3.3文本编码配置"></a>3.3文本编码配置</h3><ul><li>**i18n.commitEncoding 选项:**用来让git commit log存储时,采用的编码,默认UTF-8.</li><li>**i18n.logOutputEncoding选项:**查看git log时,显示采用的编码,建议设置为UTF-8.</li></ul><p><img src="/post/69c3279c/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220419110618742.png" alt="image-20220419110618742"></p><h3 id="3-4与服务器的认证配置"><a href="#3-4与服务器的认证配置" class="headerlink" title="3.4与服务器的认证配置"></a>3.4与服务器的认证配置</h3><h4 id="3-4-1常见的两种协议认证方式"><a href="#3-4-1常见的两种协议认证方式" class="headerlink" title="3.4.1常见的两种协议认证方式"></a>3.4.1常见的两种协议认证方式</h4><p><strong>http &#x2F; https协议认证</strong></p><p>设置口令缓存:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git : config --global credential . helper store</span><br></pre></td></tr></table></figure><p>添加HTTPS证书信任:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config http. sslverify false</span><br></pre></td></tr></table></figure><p><strong>SSH协议认证</strong><br>SSH协议是种非常常用的Git仓库访问协议 ，使用公钥认证、无需输入密码,加密传输,操作便利又保证安全性</p><h4 id="3-4-2-ssh认证的配置过程"><a href="#3-4-2-ssh认证的配置过程" class="headerlink" title="3.4.2 ssh认证的配置过程"></a>3.4.2 ssh认证的配置过程</h4><p><strong>生成公钥:</strong><br>Git工具安装成功后运行Git Bash ,在弹出的客户端命令行界面中输入下面提示的命令。(比如你的邮箱是<a href="mailto:&#x7a;&#x68;&#x61;&#x6e;&#x67;&#115;&#97;&#110;&#49;&#49;&#50;&#x33;&#x40;&#72;&#117;&#97;&#x77;&#x65;&#x69;&#x2e;&#99;&#x6f;&#x6d;">&#x7a;&#x68;&#x61;&#x6e;&#x67;&#115;&#97;&#110;&#49;&#49;&#50;&#x33;&#x40;&#72;&#117;&#97;&#x77;&#x65;&#x69;&#x2e;&#99;&#x6f;&#x6d;</a>)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ssh-keygen -t rsa -C zhangsan1123@huawei . com</span></span><br></pre></td></tr></table></figure><p><strong>添加公钥到代码平台:</strong></p><ol><li>登录代码平台</li><li>进入”Profile Settings’”</li><li>点击左侧栏的”SSH Keys”</li><li>点击”Add SSH Key” ,将刚生成的公钥文件的内容,复制到”Public Key”栏,保存即可。</li></ol><p><strong>生成公钥举例：</strong></p><p><img src="/post/69c3279c/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220419111126099.png" alt="image-20220419111126099"></p><h1 id="三、Git基本命令"><a href="#三、Git基本命令" class="headerlink" title="三、Git基本命令"></a>三、Git基本命令</h1><h2 id="1-Git版本控制下的三种工程区域-amp-文件状态"><a href="#1-Git版本控制下的三种工程区域-amp-文件状态" class="headerlink" title="1 Git版本控制下的三种工程区域&amp;文件状态"></a>1 Git版本控制下的三种工程区域&amp;文件状态</h2><p><strong>Git版本控制下的工程区域只有3种:</strong></p><ol><li><p>版本库( Repository )</p><p>在工作区中有一个隐藏目录.git,这个文件夹就是Git的版本库，里面存放了Git用来管理该工程的所有版本数据，也可以叫本地仓库。</p></li><li><p>工作区( Working Directory )</p><p>日常工作的代码文件或者文档所在的文件夹。</p></li><li><p>暂存区( stage )</p><p>一般存放在工程根目录.git&#x2F;index文件中，所以我们也可以把暂存区叫作索引(index) 。</p></li></ol><p><strong>Git版本控制下的文件状态只有三种:</strong></p><ol><li><p>已提交( committed )</p><p>该文件已经被安全地保存在本地数据库中了;</p></li><li><p>已修改(modified)</p><p>修改了某个文件，但还没有提交保存;</p></li><li><p>已暂存(staged)</p><p>把已修改的文件放在下次提交时要保存的清单中。</p></li></ol><h2 id="2-Git常用命令"><a href="#2-Git常用命令" class="headerlink" title="2 Git常用命令"></a>2 Git常用命令</h2><p><strong>工程准备</strong></p><p>工程克隆一git clone</p><p><strong>查看工作区</strong></p><p>查看工作区的修改内容一git diff</p><p>查看工作区文件状态一git status</p><p><strong>文件修改后提交推送</strong></p><p>新增&#x2F;删除&#x2F;移动文件到暂存区一git add&#x2F; git rm&#x2F; git mv</p><p>提交更改的文件一git commit</p><p>推送远端仓库一git push</p><p><strong>查看日志</strong></p><p>查看当前分支上的提交日志一git log</p><p><strong>分支管理</strong></p><p>列出本地分支一git branch</p><p>新建分支一git branch 1 git checkout -b</p><p>删除分支一git branch -d</p><p>切换分支一git checkout</p><p>更新分支一git pull</p><p>合并分支一git merge</p><p><strong>撤销操作</strong></p><p>强制回退到历史节点一git reset</p><p>回退本地所有修改而未提交的一git checkout</p><p><strong>分支合并</strong></p><p>合并目标分支内容到当前分支一git merge&#x2F;git rebase</p><h2 id="3-Git常用命令实操"><a href="#3-Git常用命令实操" class="headerlink" title="3 Git常用命令实操"></a>3 Git常用命令实操</h2><h3 id="3-1工程准备"><a href="#3-1工程准备" class="headerlink" title="3.1工程准备"></a>3.1工程准备</h3><h4 id="git-init用于在本地目录下新建git项目仓库。"><a href="#git-init用于在本地目录下新建git项目仓库。" class="headerlink" title="git init用于在本地目录下新建git项目仓库。"></a><strong>git init用于在本地目录下新建git项目仓库。</strong></h4><p>执行git init后,当前目录下自动生成一-个名为.git的目录， 这代表当前项目所在目录已纳入Git管理。.git目录下存放着本项目的Git版本库,在此强烈不建议初学者改动.git目录下的文件内容。下图可知，Git仓库下的.git目录默认是不可见的，有一-定程度 上是出于防止用户误操作考虑。</p><p><img src="/post/69c3279c/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220419141804788.png" alt="image-20220419141804788"></p><h4 id="git-clone用于克隆远端工程到本地磁盘"><a href="#git-clone用于克隆远端工程到本地磁盘" class="headerlink" title="git clone用于克隆远端工程到本地磁盘"></a><strong>git clone用于克隆远端工程到本地磁盘</strong></h4><p>如果想从远端服务器获取某个工程，那么:</p><ol><li>确定自己Git账号拥有访问、 下载该工程的权限</li><li>获取该工程的Git仓库URL</li><li>本地命令行执行git clone [URL]或 git 1fs clone [URL]</li></ol><p><img src="/post/69c3279c/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220419141937805.png" alt="image-20220419141937805"></p><p>**注:**如果你所在的项目git服务器支持git-lfs,对二进制文件进行了区别管理,那么克隆工程的时候务必使用git lfs clone。否则克隆操作无法下载到工程中的二进制文件,工程内容不完整。</p><h3 id="3-2新增-x2F-删除-x2F-移动文件到暂存区"><a href="#3-2新增-x2F-删除-x2F-移动文件到暂存区" class="headerlink" title="3.2新增&#x2F;删除&#x2F;移动文件到暂存区"></a>3.2新增&#x2F;删除&#x2F;移动文件到暂存区</h3><h4 id="在提交你修改的文件之前，需要git-add把文件添加到暂存区。"><a href="#在提交你修改的文件之前，需要git-add把文件添加到暂存区。" class="headerlink" title="在提交你修改的文件之前，需要git add把文件添加到暂存区。"></a><strong>在提交你修改的文件之前，需要git add把文件添加到暂存区。</strong></h4><p>如果该文件是新创建，尚未被git跟踪的，需要先执行git add. 将该文件添加到暂存区，再执行提交。如果文件已经被git追踪，即曾经提交过的。在早期版本的git中，需要git add再提交;在较新版本的git中,不需要git add即可提交。</p><p><img src="/post/69c3279c/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220419142507412.png" alt="image-20220419142507412"></p><h4 id="git-rm将指定文件彻底从当前分支的缓存区删除，因此它从当前分支的下一个提交快照中被删除。"><a href="#git-rm将指定文件彻底从当前分支的缓存区删除，因此它从当前分支的下一个提交快照中被删除。" class="headerlink" title="git rm将指定文件彻底从当前分支的缓存区删除，因此它从当前分支的下一个提交快照中被删除。"></a><strong>git rm将指定文件彻底从当前分支的缓存区删除，因此它从当前分支的下一个提交快照中被删除。</strong></h4><p>如果一个文件被git rm后进行了提交,那么它将脱离git跟踪,这个文件在之后的节点中不再受git工程的管理。执行git rm后， 该文件会在缓存区消失。你也可以直接从硬盘上删除文件，然后对该文件执行git commit, git会自动将删除的文件从索引中移除，效果一样。</p><p><img src="/post/69c3279c/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220419142649937.png" alt="image-20220419142649937"></p><h4 id="git-mv命令用于移动文件，也可以用于重命名文件。"><a href="#git-mv命令用于移动文件，也可以用于重命名文件。" class="headerlink" title="git mv命令用于移动文件，也可以用于重命名文件。"></a><strong>git mv命令用于移动文件，也可以用于重命名文件。</strong></h4><p>例1:需要将文件codehunter_ nginx.conf从当前目录移动到config目录下，可执行: </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git mv codehunter_ nginx . conf config</span><br></pre></td></tr></table></figure><p>例2:需要将文件codehunter_ nginx.conf重命名为new_ nginx.conf, 可执行:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git mv config/ codehunter_ _nginx . conf config/ new_ nginx. conf</span><br></pre></td></tr></table></figure><h3 id="3-3查看工作区"><a href="#3-3查看工作区" class="headerlink" title="3.3查看工作区"></a>3.3查看工作区</h3><h4 id="git-diff用于比较项目中任意两个版本-分支-的差异，也可以用来比较当前的索引和上次提交间的差异。"><a href="#git-diff用于比较项目中任意两个版本-分支-的差异，也可以用来比较当前的索引和上次提交间的差异。" class="headerlink" title="git diff用于比较项目中任意两个版本(分支)的差异，也可以用来比较当前的索引和上次提交间的差异。"></a><strong>git diff用于比较项目中任意两个版本(分支)的差异，也可以用来比较当前的索引和上次提交间的差异。</strong></h4><p>比较两个节点之间的差异</p><p><img src="/post/69c3279c/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220419143104996.png" alt="image-20220419143104996"></p><p>比较两个分支之间的差异</p><p><img src="/post/69c3279c/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220419143117128.png" alt="image-20220419143117128"></p><p>当前的索引和上次提交间的差异</p><p><img src="/post/69c3279c/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220419143124820.png" alt="image-20220419143124820"></p><p>在diff后面加–name-status参数，只看文件列表</p><p><img src="/post/69c3279c/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220419143133769.png" alt="image-20220419143133769"></p><h4 id="git-status-命令用于显示工作目录和暂存区的状态"><a href="#git-status-命令用于显示工作目录和暂存区的状态" class="headerlink" title="git status 命令用于显示工作目录和暂存区的状态"></a><strong>git status 命令用于显示工作目录和暂存区的状态</strong></h4><p>使用此命令能看到修改的git文件是否已被暂存,新增的文件是否纳入了git版本库的管理。</p><p>下例中的信息表明: modeules&#x2F;_ init_ .py已被修改并暂存, LICENSE已被修改但未暂存，README.md已被删除但未暂存，extend.txt已被新建但未跟踪。</p><p><strong>注意</strong>：请保证能理解git status回显的每一 -行文字含义。</p><p><img src="/post/69c3279c/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220419143316688.png" alt="image-20220419143316688"></p><h3 id="3-4提交更改的文件"><a href="#3-4提交更改的文件" class="headerlink" title="3.4提交更改的文件"></a>3.4提交更改的文件</h3><h4 id="git-commit主要是将暂存区里的文件改动提交到本地的版本库。"><a href="#git-commit主要是将暂存区里的文件改动提交到本地的版本库。" class="headerlink" title="git commit主要是将暂存区里的文件改动提交到本地的版本库。"></a><strong>git commit主要是将暂存区里的文件改动提交到本地的版本库。</strong></h4><p>在此强调，提交这个动作是本地动作，是往本地的版本库中记录改动,不影响远端服务器。git commit一般需要附带提交描述信息，所以常见用法是: </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit file_ name -m “commit message”</span><br></pre></td></tr></table></figure><p><img src="/post/69c3279c/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220419143841548.png" alt="image-20220419143841548"></p><p>提交成功后，git日志可查到此次提交的id和提交描述信息</p><p><img src="/post/69c3279c/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220419143800170.png" alt="image-20220419143800170"></p><p>如果要一次性提交所有在暂存区改动的文件到版本库，可以执行:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -am&quot;commit message”</span><br></pre></td></tr></table></figure><h3 id="3-5查看日志"><a href="#3-5查看日志" class="headerlink" title="3.5查看日志"></a>3.5查看日志</h3><h4 id="git-log用于查看提交历史"><a href="#git-log用于查看提交历史" class="headerlink" title="git  log用于查看提交历史"></a><strong>git  log用于查看提交历史</strong></h4><p>默认加其他参数的话，git log会按提交时间由近到远列出所有的历史提交日志。每个日志基本包含提交节点、作者信息、提交时间、提交说明等。常用的日志命令格式: git log</p><p>git log配合不同参数具有相当灵活强大的展示功能，常见的如一name-status&#x2F;-p&#x2F;–pretty&#x2F;–graph等等。</p><p><img src="/post/69c3279c/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220419144038646.png" alt="image-20220419144038646"></p><h3 id="3-6推送远端仓库"><a href="#3-6推送远端仓库" class="headerlink" title="3.6推送远端仓库"></a>3.6推送远端仓库</h3><h4 id="在使用git-commit命令将自己的修改从暂存区提交到本地版本库后，可以使用git-push将本地版本库的分支推送到远程服务器-上对应的分支。"><a href="#在使用git-commit命令将自己的修改从暂存区提交到本地版本库后，可以使用git-push将本地版本库的分支推送到远程服务器-上对应的分支。" class="headerlink" title="在使用git commit命令将自己的修改从暂存区提交到本地版本库后，可以使用git push将本地版本库的分支推送到远程服务器.上对应的分支。"></a><strong>在使用git commit命令将自己的修改从暂存区提交到本地版本库后，可以使用git push将本地版本库的分支推送到远程服务器.上对应的分支。</strong></h4><p>成功推动远端仓库后,其他开发人员可以获取到你新提交的内容。</p><p>常用的推送命令格式:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin branch_name</span><br></pre></td></tr></table></figure><p>branch_ name决定了你的本地分支推送成功后，在远端服务器.上的分支名，其他人据此可以获取该分支上的改动内容。</p><p>你的本地分支名可以与推送到远端的分支名不同: </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin branch_ _name:new_ _branch_ _name</span><br></pre></td></tr></table></figure><p><img src="/post/69c3279c/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220419144259562.png" alt="image-20220419144259562"></p><h3 id="3-7分支管理"><a href="#3-7分支管理" class="headerlink" title="3.7分支管理"></a>3.7分支管理</h3><h4 id="git-branch命令即可查看本地工程的所有git分支名称。"><a href="#git-branch命令即可查看本地工程的所有git分支名称。" class="headerlink" title="git branch命令即可查看本地工程的所有git分支名称。"></a><strong>git branch命令即可查看本地工程的所有git分支名称。</strong></h4><p>下图可见，git返回了当前本地工程所有的分支名称，其中master分支前面的“*” 表示一当前工作区所在<br>的分支是master。</p><p><img src="/post/69c3279c/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220419144417591.png" alt="image-20220419144417591"></p><p>如果想查看远端服务器.上拥有哪些分支，那么执行git branch -r即可，返回的分支名带origin前缀，表示在远端;</p><p>如果想查看远端服务器和本地工程所有的分支，那么执行git branch -a即可。</p><p><img src="/post/69c3279c/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220419144454869.png" alt="image-20220419144454869"></p><h4 id="git-branch和git-checkout-的异同"><a href="#git-branch和git-checkout-的异同" class="headerlink" title="git. branch和git checkout -的异同:"></a><strong>git. branch和git checkout -的异同:</strong></h4><p><strong>相同点:</strong></p><ul><li>git branch和git checkout -b都可以用于新建分支(默认基于当前分支节点创建)。</li></ul><p><strong>区别点:</strong></p><ul><li>git branch新建分支后并不会切换到新分支;</li><li>git checkout -b新建分支后会自动切换到新分支。</li></ul><p>常用的新建分支命令格式: </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch new_branch_name / git checkout -b branch_name</span><br></pre></td></tr></table></figure><p><img src="/post/69c3279c/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220419144742329.png" alt="image-20220419144742329"></p><h4 id="git-branch-d和git-branch-D都可以用来删除本地分支，后者大写表示强制删除。"><a href="#git-branch-d和git-branch-D都可以用来删除本地分支，后者大写表示强制删除。" class="headerlink" title="git branch -d和git branch -D都可以用来删除本地分支，后者大写表示强制删除。"></a><strong>git branch -d和git branch -D都可以用来删除本地分支，后者大写表示强制删除。</strong></h4><p>有时候当事分支上包含了未合并的改动，或者当事分支是当前所在分支，则-d无法删除，需要使用强制删除来达到目的。</p><p>常用的删除分支命令格式: </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d branch_ _name/git branch -D branch_ _name</span><br></pre></td></tr></table></figure><p>删除服务器上的远程分支可以使用git branch -d -r branch__name, 其中 branch_ name为本地分支名。<br>删除后，还要推送到服务器.上才行，即git push origin : branch_ name</p><p><img src="/post/69c3279c/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220419145020378.png" alt="image-20220419145020378"></p><h4 id="git-checkout-命令除了创建分支，还用来切换分支，当然比较官方的叫法是“检出”"><a href="#git-checkout-命令除了创建分支，还用来切换分支，当然比较官方的叫法是“检出”" class="headerlink" title="git checkout 命令除了创建分支，还用来切换分支，当然比较官方的叫法是“检出”"></a><strong>git checkout 命令除了创建分支，还用来切换分支，当然比较官方的叫法是“检出”</strong></h4><p>有时候，当前分支工作区存在修改而未提交的文件，与目的分支上的内容冲突，会导致checkout切换失败,这时候，可以使用git checkout -f进行强制切换。</p><p>常用的切换分支命令格式: </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout branch_ name</span><br></pre></td></tr></table></figure><p>git checkout对象可以是分支,也可以是某个提交节点或者节点下的某个文件。</p><p><img src="/post/69c3279c/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220419145138271.png" alt="image-20220419145138271"></p><h4 id="git-pull的作用是，从远端服务器中获取某个分支的更新，再与本地指定的分支进行自动合并。"><a href="#git-pull的作用是，从远端服务器中获取某个分支的更新，再与本地指定的分支进行自动合并。" class="headerlink" title="git pull的作用是，从远端服务器中获取某个分支的更新，再与本地指定的分支进行自动合并。"></a><strong>git pull的作用是，从远端服务器中获取某个分支的更新，再与本地指定的分支进行自动合并。</strong></h4><p>常用的切换分支命令格式: </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin remote_ branch:local_ branch</span><br></pre></td></tr></table></figure><p>如果远程指定的分支与本地指定的分支相同，则可直接执行git pull origin remote_branch</p><p><img src="/post/69c3279c/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220419145246969.png" alt="image-20220419145246969"></p><h4 id="git-fetch的作用是，从远端服务器中获取某个分支的更新到本地仓库。"><a href="#git-fetch的作用是，从远端服务器中获取某个分支的更新到本地仓库。" class="headerlink" title="git fetch的作用是，从远端服务器中获取某个分支的更新到本地仓库。"></a><strong>git fetch的作用是，从远端服务器中获取某个分支的更新到本地仓库。</strong></h4><p><strong>注意</strong>:与git. pull不同，git fetch在获取到更新后，并不会进行合并(即git merge) 操作,这样能留给用户一个操作空间，确认git fetch内容符合预期后，再决定是否手动合并节点。</p><p>常用的获取远端分支更新命令格式: </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin remote_branch: local_branch</span><br></pre></td></tr></table></figure><p>如果远程指定的分支与本地指定的分支相同，则可直接执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin remote_branch</span><br></pre></td></tr></table></figure><p><img src="/post/69c3279c/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220419145429654.png" alt="image-20220419145429654"></p><h3 id="3-8分支合并"><a href="#3-8分支合并" class="headerlink" title="3.8分支合并"></a>3.8分支合并</h3><h4 id="git-merge命令是用于从指定的分支-节点-合并到当前分支的操作"><a href="#git-merge命令是用于从指定的分支-节点-合并到当前分支的操作" class="headerlink" title="git merge命令是用于从指定的分支(节点)合并到当前分支的操作"></a><strong>git merge命令是用于从指定的分支(节点)合并到当前分支的操作</strong></h4><p>git会将指定的分支与当前分支进行比较，找出二者最近的一个共同节点base,之后将指定分支在base之后分离的节点合并到当前分支上。分支合并,实际上是分支间差异提交节点的合并。</p><p>常用的切换分支命令格式: </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge branch_name</span><br></pre></td></tr></table></figure><p><img src="/post/69c3279c/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220419145712538.png" alt="image-20220419145712538"></p><h4 id="git-rebase用于合并目标分支内容到当前分支。"><a href="#git-rebase用于合并目标分支内容到当前分支。" class="headerlink" title="git rebase用于合并目标分支内容到当前分支。"></a><strong>git rebase用于合并目标分支内容到当前分支。</strong></h4><p>git rebase这条命令用于分支合并，git merge也是用于分支合并。如果你要将其他分支的提交节点合并到当前分支，那么git rebase和git merge都可以达到目的。</p><p>常用的合并命令格式: </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase branch_ name</span><br></pre></td></tr></table></figure><p><img src="/post/69c3279c/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220419145847505.png" alt="image-20220419145847505"></p><h3 id="3-9强制回退到历史节点"><a href="#3-9强制回退到历史节点" class="headerlink" title="3.9强制回退到历史节点"></a>3.9强制回退到历史节点</h3><h4 id="git-reset通常用于撤销当前工作区中的某些git-add-x2F-commit操作，-可将工作区内容回退到历史提交节点。"><a href="#git-reset通常用于撤销当前工作区中的某些git-add-x2F-commit操作，-可将工作区内容回退到历史提交节点。" class="headerlink" title="git reset通常用于撤销当前工作区中的某些git add&#x2F;commit操作， 可将工作区内容回退到历史提交节点。"></a><strong>git reset通常用于撤销当前工作区中的某些git add&#x2F;commit操作， 可将工作区内容回退到历史提交节点。</strong></h4><p>常用的工作区回退命令格式: </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset commit_id</span><br></pre></td></tr></table></figure><p><img src="/post/69c3279c/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220419145954589.png" alt="image-20220419145954589"></p><h4 id="git-checkout-用于回退本地所有修改而未提交的文件内容。"><a href="#git-checkout-用于回退本地所有修改而未提交的文件内容。" class="headerlink" title="git checkout.用于回退本地所有修改而未提交的文件内容。"></a><strong>git checkout.用于回退本地所有修改而未提交的文件内容。</strong></h4><p>git checkout.这是条有风险的命令,因为它会取消本地工作区的修改(相对于暂存区),用暂存区的所有文件直接覆盖本地文件，达到回退内容的目的。但它不给用户任何确认机会，<strong>所以谨慎使用</strong>。</p><p>常用的回退命令格式: </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout.</span><br></pre></td></tr></table></figure><p>如果仅仅想回退某个文件的未提交改动，可以使用git checkout -filename来达到目的;如果想将工具区回退(检出)到某个提交版本，可以使用git checkout commit_ _id。</p><p><img src="/post/69c3279c/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220419150159795.png" alt="image-20220419150159795"></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JDBC</title>
      <link href="/post/8fe47ff4.html"/>
      <url>/post/8fe47ff4.html</url>
      
        <content type="html"><![CDATA[<h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><h2 id="1、jdbc简介"><a href="#1、jdbc简介" class="headerlink" title="1、jdbc简介"></a>1、jdbc简介</h2><p>JDBC(Java Database Connectivity)是一个独立于特定数据库管理系统的。通用的SQL数据库存取和操作的公共接口（一组API）,定义了用来采访数据库的标准java类库,使用这个类库可以以一种标准的方法,方便的访问数据库资源（java.sql包中）</p><p>JDBC为访问不同的数据库提供了一种统一的途径，JDBC对开发组屏蔽了一些细节问题。</p><p>JDBC的目标是使应用程序开发人员使用JDBC可以连接任何提供了JDBC驱动程序的数据库系统,这样就使得程序员无需对特定的数据库系统的特点有过多的了解，从而大大简化和加快了开发过程。</p><p>JDBC包括两个层次</p><ol><li><p>面向应用的API:Java API,抽象接口，供应用程序开发人员使用（连接数据库，执行SQL语句，获得结果集）</p></li><li><p>面向数据库API:Java Driver API,供开发数开发数据库驱动程序</p></li></ol><p>主要概念</p><p>DriverManager(java.sql.DriverManager)</p><p>   装载驱动程序，管理应用程序与驱动程序之间的连接</p><p>Driver(由驱动程序开放式提供)</p><p>​           将应用程序的API请求转换为特定的数据库请求</p><p>​        Connection(java.sql.Connection)</p><p>​           将应用程序连接到特定的数据库</p><p>​         Statement</p><p>在一个给定的连接中，用于执行一个数据库SQL语句u</p><p>​         ResultSet</p><p>​            SQL语句完成 后，返回的数据库结果集(包括行、列)</p><h2 id="2、jdbc操作"><a href="#2、jdbc操作" class="headerlink" title="2、jdbc操作"></a>2、jdbc操作</h2><p>​       1&gt;添加jar文件，测试jar文件是否添加成功</p><p>​       2&gt;加载驱动</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);<span class="comment">//加载类</span></span><br></pre></td></tr></table></figure><p>​       3&gt;获取与数据库的链接   </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String url=<span class="string">&quot;jdbc:mysql:///oa?characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=UTC&amp;rewriteBatchedStatements=true&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">String pwd=<span class="string">&quot;123456&quot;</span>;</span><br><span class="line"><span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span>  DriverManager.getConnection(url,username,pwd);</span><br></pre></td></tr></table></figure><p>​           链接数据库需要提供什么？  链接的url      用户名     密码</p><p>​            5.x  链接数据库的url   jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test      如果是本机，端口号没改变     jdbc:mysql:&#x2F;&#x2F;&#x2F;test</p><p>​            8.x  url  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jdbc:mysql:<span class="comment">///test?characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=UTC&amp;rewriteBatchedStatements=true</span></span><br></pre></td></tr></table></figure><p>​      4&gt;创建通道，发送sql指令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span>  connection.createStatement();</span><br></pre></td></tr></table></figure><p>​             创建Statement  通过改对象发送sql指令 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、execute  该方法可以发送select或者 insert update delete语句，如果是增删改方法 返回false,如果是select语句返回true</span><br><span class="line">            该方法不常用</span><br><span class="line">2、executeUpdate  返回sql语句影响的行数</span><br><span class="line">3、exexuteQuery   返回结果集</span><br></pre></td></tr></table></figure><p>​      5&gt;需要处理结果集</p><p>​         ResultSet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String sql=<span class="string">&quot;SELECT deptid did,deptname dname FROM dept&quot;</span>;</span><br><span class="line">           rs =  stmt.executeQuery(sql);</span><br><span class="line">           <span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">             <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span>   rs.getInt(<span class="string">&quot;did&quot;</span>);<span class="comment">//通过查询结果的列名获取数据</span></span><br><span class="line">             <span class="type">int</span> <span class="variable">id1</span> <span class="operator">=</span>   rs.getInt(<span class="number">1</span>);<span class="comment">//通过列序号，从1开始</span></span><br><span class="line">               System.out.println(id+<span class="string">&quot;---&quot;</span>+id1);</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure><p>​      6&gt;关闭资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           Class.forName(JDBCUtils.DRIVER);</span><br><span class="line">           connection =  DriverManager.getConnection(JDBCUtils.URL,JDBCUtils.USERNAME,JDBCUtils.PASSWORD);</span><br><span class="line">           stmt  =  connection.createStatement();</span><br><span class="line">           String sql=<span class="string">&quot;delete from dept where deptid=3&quot;</span>;</span><br><span class="line">           <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span>  stmt.executeUpdate(sql);</span><br><span class="line">           System.out.println(rows);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="keyword">if</span>(stmt!=<span class="literal">null</span>)&#123;</span><br><span class="line">                   stmt.close();</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span>(connection!=<span class="literal">null</span>)&#123;</span><br><span class="line">                   connection.close();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">               throwables.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> void main(String[] args) &#123;</span><br><span class="line">       Connection conn <span class="operator">=</span> <span class="keyword">null</span>;</span><br><span class="line">       Statement stmt <span class="operator">=</span> <span class="keyword">null</span>;</span><br><span class="line">       ResultSet rs <span class="operator">=</span> <span class="keyword">null</span>;</span><br><span class="line">       try &#123;</span><br><span class="line">           Class.forName(JDBCUtils.DRIVER);</span><br><span class="line">           conn <span class="operator">=</span>  DriverManager.getConnection(JDBCUtils.URL,JDBCUtils.USERNAME,JDBCUtils.PASSWORD);</span><br><span class="line">           stmt <span class="operator">=</span>  conn.createStatement();</span><br><span class="line">         <span class="operator">/</span><span class="operator">/</span>  String <span class="keyword">sql</span><span class="operator">=</span>&quot;select * from dept&quot;;</span><br><span class="line">           String <span class="keyword">sql</span><span class="operator">=</span>&quot;SELECT deptid did,deptname dname FROM dept&quot;;</span><br><span class="line">           rs <span class="operator">=</span>  stmt.executeQuery(<span class="keyword">sql</span>);</span><br><span class="line">           while(rs.next())&#123;</span><br><span class="line">             <span class="type">int</span> id <span class="operator">=</span>   rs.getInt(&quot;did&quot;);<span class="operator">/</span><span class="operator">/</span>通过查询结果的列名获取数据</span><br><span class="line">             <span class="type">int</span> id1 <span class="operator">=</span>   rs.getInt(<span class="number">1</span>);<span class="operator">/</span><span class="operator">/</span>通过列序号，从<span class="number">1</span>开始</span><br><span class="line">               System.out.println(id<span class="operator">+</span>&quot;---&quot;<span class="operator">+</span>id1);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; catch (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           try &#123;</span><br><span class="line">               if(rs<span class="operator">!=</span><span class="keyword">null</span>)&#123;</span><br><span class="line">                   rs.close();</span><br><span class="line">               &#125;</span><br><span class="line">               if(stmt<span class="operator">!=</span><span class="keyword">null</span>)&#123;</span><br><span class="line">                   stmt.close();</span><br><span class="line">               &#125;</span><br><span class="line">               if(conn<span class="operator">!=</span><span class="keyword">null</span>)&#123;</span><br><span class="line">                   conn.close();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; catch (<span class="keyword">SQLException</span> throwables) &#123;</span><br><span class="line">               throwables.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="3、sql注入与PreparedStatement"><a href="#3、sql注入与PreparedStatement" class="headerlink" title="3、sql注入与PreparedStatement"></a>3、sql注入与PreparedStatement</h2><p>​      1、sql注入的含义</p><p>通过拼接特殊sql语句，获取到不该获取的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String sql=<span class="string">&quot;SELECT * FROM users WHERE uname=&#x27;&quot;</span>+uname+<span class="string">&quot;&#x27; AND upwd=&#x27;&quot;</span>+upwd+<span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line"><span class="comment">//传入值的时候,密码传递的结果是   &#x27; OR &#x27;1&#x27;=&#x27;1     刚好拼接出一个  or &#x27;1&#x27;=&#x27;1&#x27;  恒成立的条件 获取到了所有的数据</span></span><br><span class="line"><span class="comment">//SELECT * FROM users WHERE uname=&#x27;aa&#x27; AND upwd=&#x27;&#x27; OR &#x27;1&#x27;=&#x27;1&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">       String inname =&quot;aa&quot;;</span><br><span class="line">       String inpwd = &quot;&#x27; OR &#x27;1&#x27;=&#x27;1&quot;;</span><br><span class="line">       Connection connection = null;</span><br><span class="line">       Statement stmt = null;</span><br><span class="line">       ResultSet rs = null;</span><br><span class="line">       try &#123;</span><br><span class="line">           Class.forName(JDBCUtils.DRIVER);</span><br><span class="line">           connection =   DriverManager.getConnection(JDBCUtils.URL,JDBCUtils.USERNAME,JDBCUtils.PASSWORD);</span><br><span class="line">           stmt =  connection.createStatement();</span><br><span class="line">           String sql=&quot;SELECT * FROM users WHERE uname=&#x27;&quot;+inname+&quot;&#x27; AND upwd=&#x27;&quot;+inpwd+&quot;&#x27;&quot;;</span><br><span class="line">           System.out.println(sql);</span><br><span class="line">           rs =  stmt.executeQuery(sql);</span><br><span class="line">           while (rs.next())&#123;</span><br><span class="line">             int id =   rs.getInt(&quot;uid&quot;);</span><br><span class="line">             String  name =   rs.getString(&quot;uname&quot;);</span><br><span class="line">             String  pwd =   rs.getString(&quot;upwd&quot;);</span><br><span class="line">             System.out.println(id+&quot;\t&quot;+name+&quot;\t&quot;+pwd);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; catch (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">         ....</span><br><span class="line">       //输入用户名和密码获取信息</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>如果避免,java提供了PreparedStatement 防止sql注入：在使用PreparedStatement的时候，sql语句中的参数，全部通过占位符的方式来使用，给占位符赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">....   </span><br><span class="line">String sql=<span class="string">&quot;SELECT * FROM users WHERE uname=? and upwd=? &quot;</span>;</span><br><span class="line">..... </span><br><span class="line">           pstmt =  connection.prepareStatement(sql);</span><br><span class="line">           pstmt.setString(<span class="number">1</span>,inname);</span><br><span class="line">           pstmt.setString(<span class="number">2</span>,inpwd);</span><br><span class="line"></span><br><span class="line">           rs =  pstmt.executeQuery();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">inname</span> <span class="operator">=</span><span class="string">&quot;zs&quot;</span>;</span><br><span class="line">   <span class="comment">//     String inpwd = &quot;&#x27; OR &#x27;1&#x27;=&#x27;1&quot;;</span></span><br><span class="line">        String inpwd=<span class="string">&quot;147258&quot;</span>;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">PreparedStatement</span>  <span class="variable">pstmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        String sql=<span class="string">&quot;SELECT * FROM users WHERE uname=? and upwd=? &quot;</span>;</span><br><span class="line">      <span class="comment">//  String sql=&quot;SELECT * FROM users WHERE uname=&#x27;&quot;+inname+&quot;&#x27; and upwd=&#x27;&quot;+inpwd+&quot;&#x27; &quot;;</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(JDBCUtils.DRIVER);</span><br><span class="line">            connection =   DriverManager.getConnection(JDBCUtils.URL,JDBCUtils.USERNAME,JDBCUtils.PASSWORD);</span><br><span class="line"></span><br><span class="line">           pstmt =  connection.prepareStatement(sql);</span><br><span class="line">           pstmt.setString(<span class="number">1</span>,inname);</span><br><span class="line">           pstmt.setString(<span class="number">2</span>,inpwd);</span><br><span class="line"></span><br><span class="line">            rs =  pstmt.executeQuery();</span><br><span class="line">            <span class="keyword">while</span> (rs.next())&#123;</span><br><span class="line">              <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span>   rs.getInt(<span class="string">&quot;uid&quot;</span>);</span><br><span class="line">              <span class="type">String</span>  <span class="variable">name</span> <span class="operator">=</span>   rs.getString(<span class="string">&quot;uname&quot;</span>);</span><br><span class="line">              <span class="type">String</span>  <span class="variable">pwd</span> <span class="operator">=</span>   rs.getString(<span class="string">&quot;upwd&quot;</span>);</span><br><span class="line">              System.out.println(id+<span class="string">&quot;\t&quot;</span>+name+<span class="string">&quot;\t&quot;</span>+pwd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ....</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输入用户名和密码获取信息</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           Class.forName(JDBCUtils.DRIVER);</span><br><span class="line">           connection =  DriverManager.getConnection(JDBCUtils.URL,JDBCUtils.USERNAME,JDBCUtils.PASSWORD);</span><br><span class="line">           String sql=<span class="string">&quot;INSERT INTO dept VALUES(NULL,?,?,?)&quot;</span>;</span><br><span class="line">           pstmt  =  connection.prepareStatement(sql);</span><br><span class="line">           pstmt.setString(<span class="number">1</span>,<span class="string">&quot;采购部&quot;</span>);</span><br><span class="line">           pstmt.setString(<span class="number">2</span>,<span class="string">&quot;pstmt实现&quot;</span>);</span><br><span class="line">           pstmt.setInt(<span class="number">3</span>,<span class="number">5</span>);</span><br><span class="line">           <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span>   pstmt.executeUpdate();</span><br><span class="line">           System.out.println(rows);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           JDBCUtils.close(connection,pstmt,rs);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>日期类型的处理</p><p>Java事务的类型有三种：JDBC事务、JTA(Java Transaction API)事务、容器事务。</p><p>事务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">       <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       System.out.println(<span class="string">&quot;请输入一个数&quot;</span>);</span><br><span class="line">       <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> input.nextInt();<span class="comment">//如果输入的是0 则代码执行不成功</span></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           Class.forName(JDBCUtils.DRIVER);</span><br><span class="line">           conn =  DriverManager.getConnection(JDBCUtils.URL,JDBCUtils.USERNAME,JDBCUtils.PASSWORD);</span><br><span class="line">           conn.setAutoCommit(<span class="literal">false</span>);<span class="comment">//手动事务</span></span><br><span class="line">           stmt =   conn.createStatement();</span><br><span class="line">           stmt.executeUpdate(<span class="string">&quot;INSERT INTO dept VALUES(NULL,&#x27;ceshinew2&#x27;,&#x27;xx&#x27;,0)&quot;</span>);</span><br><span class="line">           <span class="keyword">if</span>(num==<span class="number">0</span>)&#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;数据添加失败&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           stmt.executeUpdate(<span class="string">&quot;INSERT INTO dept VALUES(NULL,&#x27;ceshinew3&#x27;,&#x27;xx&#x27;,0)&quot;</span>);</span><br><span class="line">           conn.commit();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               conn.rollback();</span><br><span class="line">           &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">               throwables.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           JDBCUtils.close(conn,stmt,<span class="literal">null</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>打点事务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="type">JDBCUtils</span> <span class="variable">jdbcUtils</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JDBCUtils</span>();</span><br><span class="line">      <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">      <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">      <span class="type">Savepoint</span> <span class="variable">sp</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">      <span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">      System.out.println(<span class="string">&quot;请输入一个数&quot;</span>);</span><br><span class="line">      <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> input.nextInt();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          connection  =  jdbcUtils.getConnection();</span><br><span class="line">          connection.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line">          stmt = connection.createStatement();</span><br><span class="line">          stmt.executeUpdate(<span class="string">&quot;update account set balance=balance-50 where accid=1&quot;</span>);</span><br><span class="line">          sp = connection.setSavepoint();</span><br><span class="line">          stmt.executeUpdate(<span class="string">&quot;update account set balance=balance-5000 where accid=1&quot;</span>);</span><br><span class="line">          <span class="keyword">if</span>(num==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span>  <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;失败了&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          stmt.executeUpdate(<span class="string">&quot;update account set balance=balance+5000 where accid=2&quot;</span>);</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">           System.err.println(<span class="string">&quot;发生了数据库异常&quot;</span>);</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              connection.rollback(sp);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;<span class="keyword">catch</span> (RuntimeException e)&#123;</span><br><span class="line">         <span class="comment">// e.printStackTrace();</span></span><br><span class="line">          System.err.println(<span class="string">&quot;发生未知的异常:&quot;</span>+e.getMessage());</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              connection.rollback(sp);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (SQLException e1) &#123;</span><br><span class="line">              e1.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              connection.commit();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">              throwables.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">          jdbcUtils.close(connection,stmt,<span class="literal">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>批处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">JDBCUtils</span> <span class="variable">jdbcUtils</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JDBCUtils</span>();</span><br><span class="line">        <span class="comment">//插入1000调记录</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">PreparedStatement</span>  <span class="variable">pstmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = jdbcUtils.getConnection();</span><br><span class="line">            pstmt =   connection.prepareStatement(<span class="string">&quot;INSERT INTO cities VALUES(NULL,?,NULL)&quot;</span>);</span><br><span class="line">           <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10000</span>;i++)&#123;</span><br><span class="line">                pstmt.setString(<span class="number">1</span>,<span class="string">&quot;c&quot;</span>+i);</span><br><span class="line">                pstmt.addBatch();</span><br><span class="line">                <span class="keyword">if</span>(i%<span class="number">1000</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                    pstmt.executeBatch();</span><br><span class="line">                    pstmt.clearBatch();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">long</span> <span class="variable">end</span>  <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            System.out.println(<span class="string">&quot;====&quot;</span>+(end-start));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">            throwables.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            jdbcUtils.close(connection,pstmt,<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>获取自增主键的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="type">JDBCUtils</span> <span class="variable">jdbcUtils</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JDBCUtils</span>();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           conn = jdbcUtils.getConnection();</span><br><span class="line">           pstmt =  conn.prepareStatement(<span class="string">&quot;INSERT INTO cities VALUES(NULL,&#x27;c&#x27;,NULL),(NULL,&#x27;c2&#x27;,NULL);&quot;</span>, Statement.RETURN_GENERATED_KEYS);</span><br><span class="line"></span><br><span class="line">           pstmt.executeUpdate();</span><br><span class="line">           rs =   pstmt.getGeneratedKeys();<span class="comment">//为什么自增主键放到结果集中，因为一条sql语句可能插入多条记录</span></span><br><span class="line">           <span class="keyword">while</span> (rs.next())&#123;</span><br><span class="line">              <span class="type">Object</span> <span class="variable">id</span> <span class="operator">=</span>  rs.getObject(<span class="number">1</span>);</span><br><span class="line">               System.out.println(id);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">           throwables.printStackTrace();</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           jdbcUtils.close(conn,pstmt,rs);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>callabledStatement的使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="type">CallableStatement</span> <span class="variable">cstmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="type">JDBCUtils</span> <span class="variable">jdbcUtils</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JDBCUtils</span>();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">           conn = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql:///mydb?characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=UTC&amp;rewriteBatchedStatements=true&quot;</span>,<span class="string">&quot;root&quot;</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">           cstmt = conn.prepareCall(<span class="string">&quot;&#123;call demo08(?,?,?,?)&#125;&quot;</span>);</span><br><span class="line">           cstmt.setInt(<span class="number">1</span>,<span class="number">3</span>);<span class="comment">//输入类型的</span></span><br><span class="line">           cstmt.registerOutParameter(<span class="number">2</span>, Types.VARCHAR);<span class="comment">//输出的类型</span></span><br><span class="line">           cstmt.registerOutParameter(<span class="number">3</span>,Types.VARCHAR);</span><br><span class="line">           cstmt.registerOutParameter(<span class="number">4</span>,Types.INTEGER);</span><br><span class="line">           cstmt.execute();</span><br><span class="line">           <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span>   cstmt.getString(<span class="number">2</span>);</span><br><span class="line">           <span class="type">String</span> <span class="variable">subname</span> <span class="operator">=</span>   cstmt.getString(<span class="number">3</span>);</span><br><span class="line">           <span class="type">int</span>  <span class="variable">score</span> <span class="operator">=</span>   cstmt.getInt(<span class="number">4</span>);</span><br><span class="line">           System.out.println(name+<span class="string">&quot;\t&quot;</span>+subname+<span class="string">&quot;\t&quot;</span>+score);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           jdbcUtils.close(conn,cstmt,<span class="literal">null</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">CallableStatement</span> <span class="variable">cstmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">JDBCUtils</span> <span class="variable">jdbcUtils</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JDBCUtils</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">            conn = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql:///mydb?characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=UTC&amp;rewriteBatchedStatements=true&quot;</span>,<span class="string">&quot;root&quot;</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">            cstmt = conn.prepareCall(<span class="string">&quot;&#123;?=call fun_02(?)&#125;&quot;</span>);<span class="comment">//函数有返回值，第一个？接收饭盒的结果</span></span><br><span class="line">            cstmt.registerOutParameter(<span class="number">1</span>,Types.VARCHAR);</span><br><span class="line">            cstmt.setInt(<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">            cstmt.execute();</span><br><span class="line">            <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span>   cstmt.getString(<span class="number">1</span>);</span><br><span class="line">            System.out.println(res);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            jdbcUtils.close(conn,cstmt,<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>源数据【】</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入用户名</span><br><span class="line">xx</span><br><span class="line">输入密码</span><br><span class="line">xx</span><br><span class="line">1、查看信息    2、添加      3、修改      4、删除      0、退出  </span><br></pre></td></tr></table></figure><p>面向对象的思想操作数据库【必须掌握】</p><h2 id="4、内容回顾"><a href="#4、内容回顾" class="headerlink" title="4、内容回顾"></a>4、内容回顾</h2><p>​       1&gt;jdbc意义 接口  具体的实现是各个数据库厂商做的实现</p><p>​        2&gt;jdbc使用步骤</p><p>​              添加Jar</p><p>​              加载驱动</p><p>​              获取链接</p><p>​              创建通道 发送sql指令</p><p>​              处理结果集</p><p>​              关闭资源</p><p>​        3&gt;Statement  sql注入</p><p>​        4&gt;RestultSet  next()   getXXX()</p><p>​        5&gt;PrepareStatement      ？ 占位符的方式</p><p>​        6&gt;事务与批处理 主键自增        自动事务，可以设置手动   打点事务        pstmt批处理   </p><p>​        7&gt;CallabledStatement   调用存储过程和存储 函数的</p><h2 id="5、面向对象的思想操作数据库"><a href="#5、面向对象的思想操作数据库" class="headerlink" title="5、面向对象的思想操作数据库"></a>5、面向对象的思想操作数据库</h2><p>​           java                                                                  数据库【crud操作】</p><p>​            类                                                                        表</p><p>​            属性类型                                                          列类型</p><p>​            属性属性名                                                       列名</p><p>​            对象                                                                  记录</p><p>​       业务中也是crud操作</p><p>分层：单人单职</p><p>​       bean:实体类，与数据库表对应的，属性和数据库的字段对应</p><p>​       dao:数据访问层，与底层数据交互</p><p>​       view:与使用软件的人交互</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HCIA</title>
      <link href="/post/2d58191d.html"/>
      <url>/post/2d58191d.html</url>
      
        <content type="html"><![CDATA[<h1 id="HCIA"><a href="#HCIA" class="headerlink" title="HCIA"></a>HCIA</h1><h2 id="Day1"><a href="#Day1" class="headerlink" title="Day1"></a>Day1</h2><h3 id="HCIA是什么"><a href="#HCIA是什么" class="headerlink" title="HCIA是什么?"></a>HCIA是什么?</h3><p>HCIA(华为认证的初级网络工程师)分为网络安全，Route switch，硬件安全三类方向</p><p>HCIP(华为认证的高级网络工程师)</p><p>HCIE(华为认证的专家级网络工程师)</p><h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><p><img src="/post/2d58191d/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20211024203057031.png" alt="image-20211024203057031"></p><p>云技术分为云存储和云计算</p><p>云存储：因为普通的电脑存储空间小，所以用户可以把数据存储在服务器中。如：百度网盘</p><p>云计算源于分布式计算，分布式计算可以理解为一台电脑处理不了的信息使用多台电脑进行处理</p><p>网络安全中有种攻击叫DOS (拒绝服务攻击 ),意思是攻击一台电脑时可以向它一直发送垃圾信息，这台电脑就会一直在处理这些垃圾信息，消耗了计算机处理数据的资源也占用了带宽资源，导致其无法工作。还有种升级版攻击DDOS (分布式拒绝服务攻击)因为一台电脑很难发送垃圾信息使服务器瘫痪，所以黑客会通过控制多台电脑，来一起攻击服务器，从而使服务器瘫痪。</p><p>计算机技术</p><p>计算机的首要工作是将抽象语言转换为电信号</p><p>1.抽象语言—-编码           应用层</p><p>2.编码        —- 二进制      表示层</p><p>3.二进制    —- 电信号      介质（硬件）访问控制层</p><p>4.处理电信号                    物理层</p><p>通信技术</p><p>在计算机技术出现之前通信技术就已经出现了，1876年，贝尔获得了电话专利，当时出现了通信网络叫公共交换电话网，也出现了 电路交换，1888年实现了机器代替人工。到1946年2月14日 第一台电子计算机诞生，美国国防部用它来进行弹道计算。</p><p>互联网前身叫阿帕网，由于当时算力有限，所以美国人使用多台计算机，就组成了阿帕网 。后来美国人发现计算机还可以用在民用，就把阿帕网分开了，一部分用于军事，另一部分用于民用，逐渐变成Internet。</p><h3 id="如何把对等网扩大称互联网？"><a href="#如何把对等网扩大称互联网？" class="headerlink" title="如何把对等网扩大称互联网？"></a>如何把对等网扩大称互联网？</h3><p>最早的网络称之为对等网</p><p><img src="/post/2d58191d/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20211026212830824.png" alt="image-20211026212830824"></p><h4 id="1，延长传输距离"><a href="#1，延长传输距离" class="headerlink" title="1，延长传输距离"></a>1，延长传输距离</h4><p>延长传输距离 —- 中继器（放大器） —- 物理层设备</p><p>可以延长5倍的传输距离</p><h5 id="双绞线"><a href="#双绞线" class="headerlink" title="双绞线"></a>双绞线</h5><p>RJ-45双绞线，RJ-45是指头的型号，由8根铜丝构成，分为4组，两两相绞。目的是为了抵消电磁干扰。</p><p>选用铜的原因是，铜的导电性好而且便宜，没有银那么贵，导电性比铝和金好，但市面上的双绞线用的也不是纯铜，商家为了降低成本会在里面加入铝</p><p>传输介质：铜丝     传输信号：电信号</p><p><img src="https://img0.baidu.com/it/u=863443218,3301767168&fm=253&fmt=auto&app=138&f=PNG?w=500&h=500" alt="img"></p><p>屏蔽双绞线有屏蔽壳，可以减少干扰，在外界强干扰的情况下会使用</p><p>非屏蔽双绞线日常使用比较多</p><p>目前最常用的是超5类线 (1000Mbps)，线类越高，铜丝会越粗，而且绞得越紧, 传输距离100米，延长会使信号衰弱</p><p>速率计算公式：100MB的宽带100 &#x2F; 8 * 0.85 &#x3D; 10.625 MB</p><p>通常运营商承诺的是 100Mbps，指的是宽带一秒传输100M的bit</p><h5 id="光纤"><a href="#光纤" class="headerlink" title="光纤"></a>光纤</h5><p>传输介质：光导纤维（玻璃纤维） 传输的信号：光信号</p><p>电信号 — 光信号：发光二极管，注入式激光二极管</p><p>光信号 — 电信号：光电二极管</p><p>单模光纤：注入式激光二极管 — 信号畸变小</p><p>多模光纤：发光二极管</p><h4 id="2，增加网络节点数量"><a href="#2，增加网络节点数量" class="headerlink" title="2，增加网络节点数量"></a>2，增加网络节点数量</h4><h5 id="网络拓扑结构"><a href="#网络拓扑结构" class="headerlink" title="网络拓扑结构"></a>网络拓扑结构</h5><p>1，直线型拓扑</p><p><img src="/post/2d58191d/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20211026221521443.png" alt="image-20211026221521443"></p><p>优点：连接简单</p><p>缺点：不能跨机接触，容错率低，不安全，延迟高</p><p>2，环形拓扑</p><p><img src="/post/2d58191d/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20211026222459533.png" alt="image-20211026222459533"></p><p>优点：连接简单，一个断了还能传，容错率比直线型高</p><p>缺点：不能跨机接触，容错率低，不安全，延迟高</p><p>3，星型拓扑</p><p><img src="/post/2d58191d/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20211024203606494.png" alt="image-20211024203606494"></p><p>优点：容错率高，性价比高</p><p>缺点：对中间设备要求高，</p><p>4，网状型拓扑</p><p><img src="/post/2d58191d/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20211024203644737.png" alt="image-20211024203644737"></p><p>优点：传输效率高，每个节点都有网线连接：容错率高，安全</p><p>缺点：太复杂，成本高</p><p>5，混合型 —- 多环型拓扑</p><p><img src="/post/2d58191d/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20211026223030427.png" alt="image-20211026223030427"></p><p>优点：容错率高，安全</p><p>缺点：对中间设备要求高，复杂，成本高</p><p>性价比最高的拓扑 —- 星型拓扑</p><p>衍生出树形拓扑，企业规模大会用到</p><p><img src="/post/2d58191d/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20211026223207825.png" alt="image-20211026223207825"></p><h5 id="集线器（hub）-—-物理层设备"><a href="#集线器（hub）-—-物理层设备" class="headerlink" title="集线器（hub） —- 物理层设备"></a>集线器（hub） —- 物理层设备</h5><p><img src="/post/2d58191d/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20211026223405240.png" alt="image-20211026223405240"></p><p>1，地址</p><p>地址是全球唯一且格式统一，使用MAC地址。</p><p>MAC地址：所有芯片出厂时厂家烧录的一个串号，全球唯一。由48位二进制构成。前24位为厂商标识，后24位位厂商分配的串号用来区分不同的芯片。 —- 二层地址（介质访问控制层地址）</p><p>例物理地址: 20-1E-88-AF-F2-71</p><p>使用ipconfig &#x2F;all 可以在CMD命令行界面查看MAC地址</p><p>介质访问控制层在将二进制转化为电信号之前需要先给里面添加两个地</p><p>址，一个SMAC(源MAC)，一个DMAC(目标MAC)。</p><p>2，冲突  使用CSMA&#x2F;CD(载波侦听多路访问技术&#x2F;冲突检测),通俗讲就是排队</p><p>3，安全</p><p>4，延迟</p><p>因为集线器还有一些问题解决不了，所以提出了新要求：</p><p>1，无限延长传输距离</p><p>2，完全没有冲突 — 所有节点可以同时收发数据</p><p>3，实现单播 — 一对一的通讯</p><h5 id="交换机-—-二层设备"><a href="#交换机-—-二层设备" class="headerlink" title="交换机 — 二层设备"></a>交换机 — 二层设备</h5><p><img src="/post/2d58191d/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20211026224057113.png" alt="image-20211026224057113"></p><p>交换机的转发原理：数据由电信号进入到交换机，交换机转换为二进制，交换机先看源MAC地址，将源MAC地址和进入接口的映射关系记录在MAC地址表中；然后看目标MAC地址，根据目标MAC地址查看MAC地址表。如果存在对应的记录，则按记录从对应的接口转发出去，实现单播。若没有记录，则进行泛洪。(除了进入的接口外，将数据转发给其他所有接口)。</p><p>交换机的一个接口可以对应多个MAC地址，一个MAC地址只能对应一个接口。</p><p>MAC地址泛洪攻击:黑客可以不停的发送虚拟的源MAC地址，填满交换机MAC地址表，使所有消息只能泛洪，泛洪的消息就会被黑客获取，而且可能会造成网络瘫痪</p><p>MAC地址表的老化时间为300S：为了防止交换机MAC地址表被填满，每个MAC地址300s后会被删除。</p><p>一个交换机最多只能连200台计算机，因为有泛洪，过多的计算机会导致网络瘫痪</p><h5 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h5><p>应用层</p><p>表示层</p><p>网络层</p><p>介质访问控制层</p><p>物理层</p><p>路由器相当于网络设备，作用于网络层</p><p>路由器的作用</p><p>1，隔离泛洪范围 —- 路由器的一个接口对应一个泛洪范围</p><p>2，转发</p><p>逻辑地址</p><p>IP — 互联网协议</p><p>IPV4 — 32位二进制构成的 — 43亿</p><p>IPV6 — 128位二进制构成的</p><h2 id="Day2"><a href="#Day2" class="headerlink" title="Day2"></a>Day2</h2><h3 id="路由器-1"><a href="#路由器-1" class="headerlink" title="路由器"></a>路由器</h3><p>应用层</p><p>表示层</p><p>网络层</p><p>介质访问控制层</p><p>物理层</p><p>三层设备</p><p>1.隔离泛洪范围(广播域，一个接口对应一个广播域)</p><p>2.转发</p><h3 id="IP-互联网协议"><a href="#IP-互联网协议" class="headerlink" title="IP(互联网协议)"></a>IP(互联网协议)</h3><p>IPV4是32位二进制构成 —- 点分十进制</p><p>IPV6是128位二进制构成 —- 冒分16进制</p><p>例:IPv4 地址: 192.168.43.105</p><h4 id="二进制与十进制的转换"><a href="#二进制与十进制的转换" class="headerlink" title="二进制与十进制的转换"></a>二进制与十进制的转换</h4><p>次方轴:</p><p>00000001 &#x3D;&#x3D; 1</p><p>00000010 &#x3D;&#x3D; 2</p><p>00000100 &#x3D;&#x3D; 4</p><p>00001000 &#x3D;&#x3D; 8</p><p>00010000 &#x3D;&#x3D; 16</p><p>00100000 &#x3D;&#x3D; 32</p><p>01000000 &#x3D;&#x3D; 64</p><p>10000000 &#x3D;&#x3D; 128</p><p>十进制转二进制 — 凑</p><p>128 64 32 16 8 4 2 1</p><p>例:</p><p>192</p><p>11000000</p><p>168</p><p>10101000</p><p>43</p><p>00101011</p><p>105</p><p>01101001</p><p>二进制转十进制—加</p><p>128 64 32 16 8 4 2 1</p><p>例:</p><p>11001110，11110010，11100101，10101010</p><p>128+64+8+4+2&#x3D;206</p><p>128+64+32+16+2&#x3D;242</p><p>128+64+32+4+1&#x3D;229</p><p>128+32+8+2&#x3D;170</p><p>206.242.229.170</p><p>练习：</p><p>十进制转换为二进制</p><p>11100011.11111110.10101001.01001010</p><p>227.254.169.74</p><h4 id="网络位和主机位"><a href="#网络位和主机位" class="headerlink" title="网络位和主机位"></a>网络位和主机位</h4><p>网络位 —- 网络位不同表示不同的泛洪范围(相当于区号)</p><p>主机位 —- 在同一个泛洪范围内区分不同的主机(相当于个人标识)</p><p>11100011.11111110.10101001.01001010</p><p>11111111.11111111.00000000.00000000 —- 1代表网络位，0代表主机位</p><p>子网掩码：由连续的0和连续的1组成，用来区分网络位和主机位，其中，1代表网络位；0代表主机位</p><p>Ping —- 检测网络联通性的工具。实际是发送一个ICMP协议的数据包，其特点是可以强制要求对方回包。</p><h3 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h3><p>ARP协议(地址解析协议)</p><p>可以通过一种地址获取另一种地址</p><p>48位二进制全1 — 12位16进制全F — 广播地址</p><p>广播:逼交换机泛洪  但广播不等于泛洪(广播属于主动,泛洪是被动)</p><p>广播域 &#x3D; 泛洪范围</p><p>ARP的工作原理：</p><p>ARP先通过广播发送请求包，所有收到广播包的设备都将将源IP和源MAC的映射关系记录在本地的<strong>ARP缓存表</strong>中，然后再看请求的IP，如果不是自己本地的IP地址，则将数据包丢弃；若是自己本地的IP地址，则将以单播的形式进行ARP应答。在之后的传输中，将优先查看本地的ARP缓存表，若本地有缓存记录，则直接按照缓存记录发包；若没有，则再发送ARP请求。</p><p>ARP缓存表的老化时间 — 180S</p><p>ARP欺骗:发送假的数据包(回包回的比真的慢，覆盖真的地址)，继承目标地址，从而窃听信息</p><p>ARP分类</p><p>正向ARP — 通过IP地址获取MAC地址</p><p>反向ARP — 通过MAC地址获取IP地址</p><p>免费ARP — 利用正向ARP的工作原理请求自己的IP地址</p><p>​                    1，自我介绍；2，检测地址冲突。</p><h3 id="IP地址的分类"><a href="#IP地址的分类" class="headerlink" title="IP地址的分类"></a>IP地址的分类</h3><p>分为A，B，C，D，E </p><p>A：0xxx xxxx 以0开头，其他任意。取值范围（0-127） 1-126（0和127为特殊IP）<br>B：10xx xxxx以10开头，其他任意。取值范围128-191<br>C：110x xxxx以110开头，其他任意。取值范围192-223<br>D：1110 xxxx以1110开头，其他任意。取值范围224-239<br>E：1111 xxxx以1111开头，其他任意。取值范围240-255</p><p>A，B，C三类为单播地址：既可以做源IP地址也可以做目标IP地址</p><p>D为组播地址：只能做为目标IP的使用</p><p>E为保留地址</p><p>通信方式</p><p>单播：一对一关系，主机会发很多次数据包<br>组播：前提需要将电脑放在组中，而且每台电脑都需要配置组播环境将单播和广播组合，一对多关系(同一个组播组)<br>广播：前提在同一广播域，在同一广播域下不能出现多余的电脑，否则会出现安全问题，一对多关系</p><p>A,B,C的区别</p><p>A — 对应大型网络</p><p>255.0.0.0</p><p>B — 对应中型网络</p><p>255.255.0.0</p><p>C — 对用小型网咯</p><p>255.255.255.0</p><h3 id="特殊IP地址"><a href="#特殊IP地址" class="headerlink" title="特殊IP地址"></a>特殊IP地址</h3><p>1，127.0.0.1 - 127.255.255.254 — 环回地址 用于检查，排错，可以通过ping环回地址127.0.0.1，如果ping不通，则物理网卡出错，ping自己的ip地址也ping不通，则主机有错。</p><p>2，255.255.255.255 —- 受限（受路由器的限制）广播地址 — 只能作为目标IP来使用</p><p>3，主机位全1 —- 192.168.1.X&#x2F;24(192.168.1.255) —- 直接广播地址 —- 只能作为目标IP来使用</p><p>4，主机位全0 —- 192.168.1.X&#x2F;24(192.168.1.0&#x2F;24) —- 网段 &#x2F; 网络号中可使用的192.168.1.1 -192.168.1.254</p><p>5，0.0.0.0 —- 1，可以表示为没有IP；2，可以代表所有IP</p><p>6，169.254.0.0&#x2F;16 本地链路地址&#x2F;自动私有地址，在多次发送数据包请求其他主机分配IP地址时无反应，则自己配IP地址</p><h3 id="关于IP的技术"><a href="#关于IP的技术" class="headerlink" title="关于IP的技术"></a>关于IP的技术</h3><h4 id="VLSM-—-可变长子网掩码（子网划分）"><a href="#VLSM-—-可变长子网掩码（子网划分）" class="headerlink" title="VLSM — 可变长子网掩码（子网划分）"></a>VLSM — 可变长子网掩码（子网划分）</h4><p>例：</p><p>192.168.1.0&#x2F;24转化为二进制（加粗为网络位）</p><p><strong>11000000.10101000.00000001</strong>.0 0000000  24</p><p>借一位变成网络位，借过来可能为1或0</p><p><strong>11000000.10101000.00000001.0</strong> 0000000 </p><p>192.168.1.0&#x2F;25     1-126</p><p><strong>11000000.10101000.00000001.1</strong> 0000000 </p><p>192.168.1.128&#x2F;25  129-254</p><p><strong>11111111.11111111.11111111.1</strong> 0000000 (子网掩码)</p><p>255.255.255.128（子网掩码）</p><p>练习:</p><p>172.16.0.0&#x2F;16 —- 划分8个网段，并且写出每个网段的取值范围</p><p><strong>172.16</strong>.00000000.00000000</p><p><strong>172.16.000</strong> 00000.000000000 —- 172.16.0.0&#x2F;19</p><p>172.16.0.1 – 172.16.31.254</p><p><strong>172.16.001</strong> 00000.000000000 —- 172.16.32.0&#x2F;19</p><p>172.16.32.1 – 172.16.63.254</p><p><strong>172.16.010</strong> 00000.000000000 —- 172.16.64.0&#x2F;19</p><p>172.16.64.1 – 172.16.95.254</p><p><strong>172.16.011</strong> 00000.000000000 —- 172.16.96.0&#x2F;19</p><p>172.16.96.1 – 172.16.127.254</p><p><strong>172.16.100</strong> 00000.000000000 —- 172.16.128.0&#x2F;19</p><p>172.16.128.1 – 172.16.159.254</p><p><strong>172.16.101</strong> 00000.000000000 —- 172.16.160.0&#x2F;19</p><p>172.16.160.1 – 172.16.191.254</p><p><strong>172.16.110</strong> 00000.000000000 —- 172.16.192.0&#x2F;19</p><p>172.16.192.1 – 172.16.223.254</p><p><strong>172.16.111</strong> 00000.000000000 —- 172.16.224.0&#x2F;19</p><p>172.16.224.1 – 172.16.255.254</p><h4 id="CIDR-—-无类域间路由-—-汇总"><a href="#CIDR-—-无类域间路由-—-汇总" class="headerlink" title="CIDR — 无类域间路由 — 汇总"></a>CIDR — 无类域间路由 — 汇总</h4><p>“取相同，去不同” </p><p>例:</p><p>192.168.0.0&#x2F;24</p><p>192.168.1.0&#x2F;24</p><p><strong>192.168.00000000</strong>.00000000·</p><p><strong>192.168.00000001</strong>.00000000</p><p><strong>192.168.0000000 0</strong>.00000000 192.168.0.0&#x2F;23</p><p>192.168.1.0&#x2F;24</p><p>192.168.2.0&#x2F;24</p><p>192.168.3.0&#x2F;24</p><p><strong>192.168.00000000</strong>.00000000</p><p><strong>192.168.00000001</strong>.00000000</p><p><strong>192.168.00000010</strong>.00000000</p><p><strong>192.168.00000011</strong>.00000000</p><p><strong>192.168.000000 00</strong>.00000000</p><p>192.168.0.0&#x2F;22 —– 超网(超越C类)</p><p>172.16.0.0&#x2F;24</p><p>172.16.1.0&#x2F;24</p><p>172.16.2.0&#x2F;24</p><p>172.16.3.0&#x2F;24</p><p>172.16.0.0&#x2F;22 —- 子网汇总</p><h2 id="Day3"><a href="#Day3" class="headerlink" title="Day3"></a>Day3</h2><h3 id="OSI七层参考模型"><a href="#OSI七层参考模型" class="headerlink" title="OSI七层参考模型"></a>OSI七层参考模型</h3><p>OSI&#x2F;RM —- 开放式系统互联参考模型</p><p>1979年iso(国际标准化组织) 提出</p><p>OSI的核心思想 — 分层</p><p>属于同一层面的不同功能，其目的和作用是相似或者相近的；属于不同层面的不同功能，其目的和作用存在明显的差异。每一层都在下层的基础上提供增值服务，最上层提供的是人机交互的应用服务。</p><p>作用：</p><p>1，更易标准化</p><p>2，降低层次之间的关联性，层次之间可以独立发展</p><p>3，更易学习或理解</p><p>应用层</p><p>表示层</p><p><strong>会话层</strong> —- 保持网络应用和网络服务器之间的会话连接。会话层地址</p><p><strong>传输层</strong> —- 实现端到端的传输，应用到应用的传输。端口号（传输层地址 — 区分和标定不同应用的） — 0 - 65535 （16位二进制构成）0号为保留端口号 1 - 65535。1- 1023 知名端口号</p><p>网络层</p><p><strong>数据链路层</strong> — MAC（介质访问控制层），LLC（逻辑链路控制层） —- FCS（帧校验序列)用于验数据完整性的，依靠CRC(循环冗余算法)，只能检验出物理的破坏，如果被黑客篡改过很难检验出来 </p><p>物理层</p><h3 id="TCP-x2F-IP模型"><a href="#TCP-x2F-IP模型" class="headerlink" title="TCP&#x2F;IP模型"></a>TCP&#x2F;IP模型</h3><p><img src="/post/2d58191d/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20211104112452442.png" alt="image-20211104112452442"></p><p>OSI分的太细，分配不均衡，所以TCP&#x2F;IP模型用的较多</p><p>TCP&#x2F;IP协议族（协议簇）</p><p><img src="/post/2d58191d/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20211101213655689.png" alt="image-20211101213655689"></p><p>TCP&#x2F;IP四层模型 — TCP&#x2F;IP标准模型</p><p>​认为数据链路层和物理层不可分割应该合成一层</p><p>TCP&#x2F;IP五层模型 — TCP&#x2F;IP对等模型</p><p>​数据链路层和物理层的原理上差异较大</p><p><img src="/post/2d58191d/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20211101213714015.png" alt="image-20211101213714015"></p><p><strong>PDU — 协议数据单元(也就是单位)</strong></p><p>在OSI模型中:</p><p>L1PDU(第一层的单位)</p><p>L2PDU </p><p>…</p><p>L7PDU</p><p>在TCP&#x2F;IP模型中:</p><p><strong>应用层</strong> —- 报文</p><p><strong>传输层</strong> —- 段</p><p><strong>网络层</strong> —- 包</p><p><strong>数据链路层</strong> —- 帧</p><p><strong>物理层</strong> —- 比特流</p><h3 id="封装和解封装"><a href="#封装和解封装" class="headerlink" title="封装和解封装"></a>封装和解封装</h3><p>封装:每一层添加数据的过程</p><p>解封装:还原原始数据</p><p><strong>应用层</strong>—有封装但取决于具体的应用</p><p><strong>传输层</strong> —- 端口号 — TCP&#x2F;UDP</p><p><strong>网络层</strong> —- Ip地址 — IP</p><p><strong>数据链路层</strong> —- MAC地址 — 以太网：早期局域网的解决方案，依靠MAC地址进行寻址的网络。现在也应用于广域网当中。工作在1，2层的网络。</p><p><img src="/post/2d58191d/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20211101213729466.png" alt="image-20211101213729466"></p><p>以太网Ⅱ型帧</p><p>DestinationAdress—Dmac</p><p>SourceAdress—Smac</p><p>Type —- 表示上层所使用的协议类型</p><p>Preamble—前导符</p><p><strong>物理层</strong></p><h4 id="应用层的协议-有端口号的一定是应用层协议"><a href="#应用层的协议-有端口号的一定是应用层协议" class="headerlink" title="应用层的协议 (有端口号的一定是应用层协议)"></a>应用层的协议 (有端口号的一定是应用层协议)</h4><p>HTTP tcp 80 — 超文本传输协议 — 提供浏览网页服务的</p><p>HTTPS TCP 443 — HTTP + SSL（TLS）（安全传输协议）</p><p>FTP TCP 20&#x2F;21 — 文件传输协议 — 提供互联网文件资源共享服务</p><p>TFTP UDP 69 —- 简单文件传输协议 </p><p>Telnet TCP 23 —- 远程登录标准协议 — 提供远程管理服务</p><p>SSH TCP 22</p><p>Dns UDP&#x2F;TCP 53 —- 域名解析协议</p><p>DHCP UDP 67&#x2F;68 — 动态主机配置协议</p><h4 id="TCP和UDP协议："><a href="#TCP和UDP协议：" class="headerlink" title="TCP和UDP协议："></a>TCP和UDP协议：</h4><h5 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h5><p>1，TCP是面向连接的协议，而UDP是无连接的协议</p><p>面向连接：在数据传输之前，先使用预备的协议建立点到点的连接，然后再传输数据的过程</p><p>2，TCP协议传输是可靠的，而UDP协议传输是“尽力而为”</p><p>3，TCP可以进行流控，而UDP不行</p><p>4，TCP可以进行数据分段，而UDP不行</p><p>5，TCP耗费资源比较大，传输速度比较慢；UDP耗费资源比较小，传输速度快</p><p>TCP和UDP的应用场景：TCP适用于效率要求较低，但是对准确性要求较高的场景；UDP适用于对效率要求较高，但是对准确性要求较低的场景（即时类通讯软件）</p><h5 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h5><p><img src="/post/2d58191d/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20211101213749149.png" alt="image-20211101213749149"></p><p>TCP — 可变长头部</p><p>URG—紧急位(激活紧急指针)ACK—确认位(激活确认信号)PSHRST—断开位SYN—请求位 FIN—结束位</p><p>校验和 — 确保数据的完整性 — 伪头部校验 — 将网络层封装的12个字节的内容一起进行校验：32位源IP地址，32目标IP地址，8位协议号，8位保留，16位的报文长度</p><p><img src="/post/2d58191d/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20211101213810372.png" alt="image-20211101213810372"></p><p>TCP建立连接的过程 — 三次握手</p><p><img src="/post/2d58191d/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20211101213831479.png" alt="image-20211101213831479"></p><p>TCP断开连接的过程 — 四次挥手</p><p><img src="/post/2d58191d/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20211101213843275.png" alt="image-20211101213843275"></p><p>TCP的传输是可靠的 —- 确认，重传，排序，流控 — 滑动窗口机制</p><h5 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h5><p><img src="/post/2d58191d/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20211101213820906.png" alt="image-20211101213820906"></p><p>UDP校验和可有可无</p><h4 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h4><p><img src="/post/2d58191d/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20211101213855881.png" alt="image-20211101213855881"></p><p>IPV4 — 也是可变长头部</p><p>TTL —- 生存时间 —- 数据包每经过一个路由器，TTL值将减一。当TTL值减到0时，数据包将不会被路由器转发，将直接丢弃。</p><p>协议号(上层使用的协议)：</p><p>ICMP — 1</p><p>TCP — 6</p><p>UDP — 17</p><p>IP分片</p><p>MTU(限制IP分片) — 最大传输单元 — 1500字节</p><p>MSS(限制TCP分段) — 最大段长度 — 1460 — 需要协商，当两方不同时，将按照小的一方执行（在三次握手中的前两次SYN包中进行协商）</p><p>为什么要分:因为MTU最大传输单元为1500字节</p><h2 id="Day4"><a href="#Day4" class="headerlink" title="Day4"></a>Day4</h2><h3 id="接口的区别"><a href="#接口的区别" class="headerlink" title="接口的区别"></a>接口的区别</h3><p>GE—- 1000Mbps&#x3D;1Gbps</p><p>Ethernet—- 100Mbps</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>先配路由器的IP地址，再配pc的</p><p>华为根据配置权限的不同，将CLI界面分成了不同的视图</p><h4 id="用户视图"><a href="#用户视图" class="headerlink" title="用户视图"></a>用户视图</h4><p><Huawei> —- 用户视图 —- 仅具有查看配置的操作权限，不能进行配置操作 — &lt; &gt;</Huawei></p><p><Huawei>display ip interface brief —- 查看端口IP地址配置情况</Huawei></p><p>Physical — 如果UP — 代表该接口具备物理层面的通信条件</p><p>Protocol —- 如果UP —- 代表该接口具备协议层面的通信条件</p><p>只有一个接口双UP，才代表该接口可以完成通信。</p><h4 id="系统视图"><a href="#系统视图" class="headerlink" title="系统视图"></a>系统视图</h4><p><Huawei>system-view —- 进入到系统视图</Huawei></p><p>[Huawei] — 系统视图 —- 可以进行一些全局类的配置 — [ ]</p><p>[Huawei]sysname aa —- 修改路由器名称</p><p>[aa]</p><p>[aa]quit — 退回到上一个视图</p><p>​q —- 华为支持简写模式</p><p>Ctrl + Z —- 直接回到用户视图</p><h4 id="接口试图"><a href="#接口试图" class="headerlink" title="接口试图"></a>接口试图</h4><p>[aa]interface GigabitEthernet 0&#x2F;0&#x2F;0 —- 进入接口视图，没有提高权限，只是更精准了—- [ - ]</p><p>[aa-GigabitEthernet0&#x2F;0&#x2F;0]ip address 192.168.1.1 255.255.255.0 — 给接口配置IP地址的命令</p><p>[aa-GigabitEthernet0&#x2F;0&#x2F;1]ip address 192.168.2.1 24—简写</p><p>[aa-GigabitEthernet0&#x2F;0&#x2F;1]undo ip address 192.168.2.1 24 — 删除命令 — 在命令前面加undo即可</p><p>[aa-GigabitEthernet0&#x2F;0&#x2F;0]display this — 展示当前视图所作的所有配置</p><p>[aa]display current-configuration — 查看当前的配置操作 — 查看缓存中的配置 — 缓存的特点是断电丢失</p><p>闪存 — FLASH</p><p><aa>display saved-configuration — 查看闪存中的配置内容 </aa></p><p>为什么跨网络传输的第一个包会丢失？—因为ARP缓存表的存在</p><p>帮助系统：</p><p>Tab —- 可以补全命令</p><p>？ — 可以查看后续命令或者是后续可以跟的参数</p><p>访问网络中的服务器</p><p>1，通过IP地址访问</p><p>2，通过域名来访问</p><p>3，通过应用程序或APP来访问</p><h3 id="DNS协议"><a href="#DNS协议" class="headerlink" title="DNS协议"></a>DNS协议</h3><p>DNS — 域名解析协议 — 基于UDP&#x2F;TCP协议的53号端口传输数据</p><p>典型的C&#x2F;S架构的协议 —- DNS客户端 — 通过域名上网的电脑</p><p>​                                      —- DNS服务器 — 完成域名解析的服务器 — 记录IP地址和域名的映射关系</p><p>DNS的工作原理：上网前先根据域名去找DNS服务器查对应的IP地址，之后再根据IP地址访问服务器。</p><p><a href="http://www.baidu.com/">www.baidu.com</a> — 从右往左，一个点号分隔一个域名层次，层次逐渐降低，范围逐渐精准。</p><p><img src="/post/2d58191d/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20211106205745226.png" alt="image-20211106205745226"></p><p><img src="/post/2d58191d/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20211106205801845.png" alt="image-20211106205801845">为配合这种层次化的域名结构，我们DNS服务器按照联机分布式数据库系统来部署</p><p><img src="/post/2d58191d/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20211106205816197.png" alt="image-20211106205816197">DNS服务器支持的查询方式 —- 递归查询</p><p>​                                                     迭代查询</p><p>电脑 –（递归查询 – UDP 53）– 本地DNS服务器 –（迭代查询 — TCP 53）– 根服务器</p><p><img src="/post/2d58191d/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20211106205826180.png" alt="image-20211106205826180"></p><h3 id="DHCP协议"><a href="#DHCP协议" class="headerlink" title="DHCP协议"></a>DHCP协议</h3><p>DHCP — 动态主机配置协议 — 使用的是UDP的67和68端口进行通信</p><p>典型的C&#x2F;S架构协议 —- DHCP客户端 — 需要获取IP地址的设备 — 68端口</p><p>​  —- D HCP服务器 — 提供IP地址的设备 — 67端口</p><h4 id="第一种场景：PC首次获取IP地址"><a href="#第一种场景：PC首次获取IP地址" class="headerlink" title="第一种场景：PC首次获取IP地址"></a>第一种场景：PC首次获取IP地址</h4><p>1，DHCP客户端 — DHCP服务器 ：DHCP - Discover —- 以广播的形式发送  </p><p>2，DHCP服务器 — DHCP客户端：DHCP - offer —- 单播&#x2F;广播</p><p>​offer包中会携带一个有效的IP地址，并暂时为DHCP客户端保留</p><p>3，DHCP客户端 — DHCP服务器 ：DHCP - request包 — 广播（当DHCP客户端获得多个DHCP-OFFER包时，将会选择第一个获取到的offer包中的IP地址作为请求IP。）</p><p>4，DHCP服务器 — DHCP客户端：DHCP-ACK —- 单播&#x2F;广播</p><h4 id="第二种场景：PC再次获取IP地址"><a href="#第二种场景：PC再次获取IP地址" class="headerlink" title="第二种场景：PC再次获取IP地址"></a>第二种场景：PC再次获取IP地址</h4><p>1，DHCP客户端 — DHCP服务器 ：DHCP - request包 — 广播</p><p>2，DHCP服务器 — DHCP客户端：DHCP - ACK&#x2F;DHCP - NAK (同意&#x2F;不同意)</p><p>​DHCP-Release — DHCP客户端主动释放IP地址</p><h4 id="租期-—-24H"><a href="#租期-—-24H" class="headerlink" title="租期 — 24H"></a>租期 — 24H</h4><p>T1 — 租期的50% — 12H — DHCP客户端 — DHCP服务器 ：DHCP - request包 —- 单播</p><p>T2 — 租期的87.5% — 21H — DHCP客户端 — DHCP服务器 ：DHCP - request包 —- 广播</p><h4 id="DHCP服务器的配置"><a href="#DHCP服务器的配置" class="headerlink" title="DHCP服务器的配置"></a>DHCP服务器的配置</h4><p>1，开启DHCP服务</p><p>​[aa]dhcp enable </p><p>2，创建一个地址池</p><p>​[aa]ip pool aa</p><p>​Info: It’s successful to create an IP address pool.</p><p>​[aa-ip-pool-aa]</p><p>3，配置地址池</p><p>​[aa-ip-pool-aa]network 192.168.1.0 mask 24 —- 写入IP地址池中所有的网段</p><p>​[aa-ip-pool-aa]gateway-list 192.168.1.1 — 配置网关</p><p>​[aa-ip-pool-aa]dns-list 114.114.114.114 8.8.8.8 — 配置DNS服务器信息</p><p>4，去接口选择全局配置</p><p>​[aa-GigabitEthernet0&#x2F;0&#x2F;0]dhcp select global </p><h3 id="路由器-2"><a href="#路由器-2" class="headerlink" title="路由器"></a>路由器</h3><p>路由器的作用</p><p>1，隔离广播域</p><p>2，转发</p><p>路由表</p><p>路由器的转发：当一个数据包来到路由器，路由器将基于数据包中的目标IP地址查询本地<strong>路由表</strong>，若表中存在记录，则将<strong>无条件</strong>按记录转发；若没有记录，则将直接丢弃该数据包。</p><p><aa>display ip routing-table — 查看路由表</aa></p><p>Destination&#x2F;Mask —- 目标网段和掩码 — 目的地</p><p>Proto — 协议的意思，可以理解为该路由的类型</p><p>Direct — 直连路由</p><p>​路由器接口直接通过网线连接形成的网段 — 直连网段 — 直连网段对应的路由 — 直连路由</p><p>NextHop — 下一跳 — （经过路由器的一次转发称为一跳）数据下一个需要经过的路由器的入接口的IP地址。</p><p>Interface — 出接口 — 数据包发出的接口</p><p>直连路由：自动生成</p><p>​条件：1，接口具备IP地址</p><p>​ 2，接口双UP</p><h2 id="Day5"><a href="#Day5" class="headerlink" title="Day5"></a>Day5</h2><p>路由器和路由器之间的链路 — 骨干链路（总线链路） — 骨干链路一般不放用户</p><h3 id="路由器获取未知网段路由条目的方法："><a href="#路由器获取未知网段路由条目的方法：" class="headerlink" title="路由器获取未知网段路由条目的方法："></a>路由器获取未知网段路由条目的方法：</h3><p>静态路由：由网络管理员手写的路由条目。</p><p>动态路由：所有路由器上运行相同的一种动态路由协议，之后通过路由器之间的沟通，协商最终计算生成的路由条目。</p><h4 id="静态路由"><a href="#静态路由" class="headerlink" title="静态路由"></a>静态路由</h4><p>[r1]ip route-static 192.168.3.0 24 192.168.2.2 — 静态路由添加命令</p><p>192.168.3.0&#x2F;24 Static 60 0 RD 192.168.2.2 GigabitEthernet0&#x2F;0&#x2F;1</p><p>PRE — 优先级 — 当两条路由条目的目标网段相同时，仅加载优先级高的路由条目到路由表中。</p><p>​注意：优先级数值越小，优先级反而越高。优先级的取值范围 0 - 255</p><p>​华为设备：直连路由优先级默认为0，静态路由优先级默认为60。</p><p>RD —- 该路由条目需要递归查找出接口</p><p>[r1]ip route-static 192.168.3.0 24 GigabitEthernet 0&#x2F;0&#x2F;1 192.168.2.2 —- 加上出接口添加静态路由</p><p>配置拓扑的流程：</p><p>1.数广播域</p><p>2.分配网段</p><p>3.配IP，先给路由器配看，再给PC</p><p>4.写路由</p><p>路由环路会导致路由器崩溃</p><h3 id="拓展配置"><a href="#拓展配置" class="headerlink" title="拓展配置"></a>拓展配置</h3><p>1，负载均衡：当路由器访问同一个目标具有<strong>多条开销相似</strong>的路径时，可以让设备将流量拆分后延多条路径同时传输，达到叠加带宽的效果。</p><p>192.168.6.0&#x2F;24 Static 60 0 RD 192.168.2.2 GigabitEthernet0&#x2F;0&#x2F;1</p><p>​Static 60 0 RD 192.168.3.2 GigabitEthernet0&#x2F;0&#x2F;2</p><p>2，环回接口：路由器配置的虚拟接口。一般用在虚拟实验，不受设备的限制(实的不行来虚的)</p><p>[r1]interface LoopBack 0 — 创建环回接口</p><p>[r1-LoopBack0]</p><p>[r1]ping -a 192.168.1.1 192.168.3.1 —- 指定源IP发送Ping包</p><p>3，手工汇总：当路由器可以访问多个连续的子网时，若均通过相同的下一跳，可以将这些网段进行汇总计算，之后仅编辑到达汇总网段的静态路由即可，以达成减少路由条目，提高转发效率的目的。</p><p>4，路由黑洞：在汇总中，若包含网络内实际不存在的网段时，可能使流量又去无回，造成链路资源的浪费。</p><p>​合理的子网划分和汇总可以减少黑洞的产生。</p><p>5，缺省路由：一条不限定目标的路由条目；查表时，若本地所有路由均未匹配，则将匹配缺省路由。</p><p>​一旦路由黑洞和缺省路由相遇，将100%出环</p><p>6，空接口路由：在黑洞路由器上，配置一条到达汇总网段指向空接口的路由。</p><p>​1，空接口：null0口，路由器的一个虚拟接口，如果一条路由的出接口为空接口则代表将该流量丢弃。</p><p>​2，路由表的匹配原则：最长匹配原则（精准匹配原则）</p><p>​[r1]ip route-static 192.168.0.0 22 NULL 0</p><p>7，浮动静态路由：通过修改静态路由的默认优先级，实现静态路由的备份效果</p><p>​[r1]ip route-static 192.168.2.0 24 21.0.0.2 preference 61</p><p>​[r1]display ip routing-table protocol static </p><h2 id="Day6"><a href="#Day6" class="headerlink" title="Day6"></a>Day6</h2><p>静态路由:由网络管理员手写的路由条目。</p><p>动态路由:所有路由器上运行相同的一种动态路由协议，之后通过路由器之间的沟通，协商最终计算生成的路由条目。</p><h3 id="静态路由-1"><a href="#静态路由-1" class="headerlink" title="静态路由"></a>静态路由</h3><p>​优点:</p><p>​1，选录由由管理员选择，相对更容易掌控</p><p>​2，不需要占用额外的资源</p><p>​3，更加安全</p><p>​缺点：</p><p>​1，在复杂的网络环境中，配置量较大</p><p>​2，一旦网络结构发生变化，静态路由不能基于拓扑的变化而变化（收敛—<strong>不能基于拓扑的变化而自动收敛）</strong></p><h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><p>​优点:</p><p>​1，可以基于拓扑的变化而自动收敛</p><p>​2，部署简单，仅需在所有路由器上运行相同的路由协议即可</p><p>​缺点：</p><p>​1，路径由单一算法得出，不一定是最优路径，甚至可能出现环路</p><p>​2，会额外占用路由器硬件资源和链路带宽资源</p><p>​3，因为设备之间存在信息传递，所以，比较容易被利用产生安全问题</p><p>总结：</p><p>​1，静态路由适合小型简单的网络环境</p><p>​2，动态路由设用于复杂的网络环境中</p><h3 id="AS"><a href="#AS" class="headerlink" title="AS"></a>AS</h3><p>AS—自治系统—将网路分块管理—由单一的机构或组织所管理的一系列IP网络及其设备所构成的集合</p><p>AS的管理—-AS存在编号—由16位二进制构成(0-65535)—现在也有拓展版的AS编号—32位二进制构成</p><p>AS的通信:</p><p>​AS内部通信所使用的协议—IGP(内部网关协议) —RIP,OSPF,is-is，eigrp等</p><p>​AS之间的通信协议—EGP(外部网关协议)—BGP</p><p>IGP根据算法进行分类</p><p>​距离矢量型协议(DV) — 路由器之间直接发送路由条目信息。 —使用的算法：贝尔曼-福特算法(Bellman-Ford算法) — “依据传闻的理由协议” — RIP</p><p>​链路状态型协议(LS) —链路状态信息(LSA — 链路状态通告) —使用的算法：SPF算法 —将图形结构转换为树形结构 — OSPF，IS-IS</p><h4 id="RIP-—路由信息协议"><a href="#RIP-—路由信息协议" class="headerlink" title="RIP —路由信息协议"></a>RIP —路由信息协议</h4><p><img src="/post/2d58191d/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20211117102131179.png" alt="image-20211117102131179"></p><p>邻居 —相邻的两个路由器，可以直接通过网段进行通信</p><p>Destination&#x2F;Mask，度量值(Metric)在华为体系中叫 开销值(Cost) —动态路由重要的选路依据</p><p>开销值：当动态路由计算出多条到达相同网段的路径时，将比较他们的开销值，会选择开销值最小的加入到路由表中。</p><p>不同协议之间，比较优先级；相同 协议之间，比较开销值。</p><p>不同路由协议之间，他们的开销值的度量标准是不一样的，不同协议的开销值没有可比性。</p><p>RIP是以跳数作为开销度量的</p><p>RIP支持等开销负载均衡</p><p>RIP的默认优先级 — 100 (华为中定义的)</p><p>RIP存在一个工作半径 — 15跳。当RIP收到一个目标网段路由的开销值为16跳的时候，则认为该网段不可达。</p><p>RIP在传递路由条目的数据包中所携带的cost &#x3D; 本地路由表中该网段的开销值 + 1.</p><h5 id="Bellman-Ford算法"><a href="#Bellman-Ford算法" class="headerlink" title="Bellman-Ford算法"></a>Bellman-Ford算法</h5><p>1.AR1收到AR2发送的2.2.2.0&#x2F;24网段的路由信息，但是，AR1本地路由表中没有这条网段的路由信息；则直接将该路由<strong>刷新</strong>到AR1的路由表中。</p><p>Destination&#x2F;MaskProtoPreCostFlagsNextHopInterface</p><p>2.2.2.0&#x2F;24  RIP1001D    12.0.0.2 G 0&#x2F;0&#x2F;0</p><p>2.AR1收到AR2发送的2.2.2.0&#x2F;24 网段的路由信息，但是，AR1本地路由表中有这条网段的路由信息；则看下一跳，本地路由表中的下一跳就是AR2，这种情况下将直接将R2发送的路由信息<strong>刷新</strong>到路由表中。</p><p>3.AR1收到AR2发送的2.2.2.0&#x2F;24网段的路由信息，但是，AR1本地路由表中有这条网段的路由信息；则看下一跳，本地路由表中的下一跳不是AR2，则比较开销值。若本地的开销值大于AR2发来的路由的开销值；则将AR2发的路由信息<strong>刷新</strong>到路由表中。</p><p>4.AR1收到AR2发送的2.2.2.0&#x2F;24网段的路由信息，但是，AR1本地路由表中有这条网段的路由信息；则看下一跳，本地路由表中的下一跳不是AR2，则比较开销值。若本地的开销值小于AR2发来的路由的开销值；则<strong>不刷新</strong>AR2发送的路由信息。</p><h5 id="RIP的版本"><a href="#RIP的版本" class="headerlink" title="RIP的版本"></a>RIP的版本</h5><p>​一共存在3个版本—RIPV1,RIPV2,RIPNG</p><p>​RIPV1,RIPV2 — IPV4</p><p>​RIPNG — IPV6</p><p>RIPV1和RIPV2的区别</p><ol><li>v1是有类别的路由协议，v2是无类别的路由协议</li></ol><p>​v1在发送目标网段信息时，不携带子网掩码；</p><p>​v2在发送目标网段信息时，携带子网掩码。</p><ol start="2"><li><p>v1不支持手工认证，v2支持手工认证 — 通过相同的口令完成身份认证</p></li><li><p>v1采用广播的形式发送信息；v2是通过组播的形式发送信息；—224.0.0.9</p><p>RIP传输层使用的是UDP协议，通信端口为520端口。</p></li></ol><h5 id="RIP的数据包"><a href="#RIP的数据包" class="headerlink" title="RIP的数据包"></a>RIP的数据包</h5><p>​request — 请求包</p><p>​response — 响应包（包含路由信息）— 更新包</p><p>​RIP在收敛完成之后，依然会每隔30s发送一个response —RIP的周期更新</p><p>​1.弥补RIP自身没有确认机制</p><p>​2.弥补RIP自身没有保活机制</p><p>RIP的周期更新 –异步周期更新</p><p> </p><p>##### RIP的计时器 </p><p>1，周期更新计时器 – 30S </p><p>2，无效计时器—180S—路由条目刷新后将启动一个180S的无效计时器，若计时器结束路由未刷新，则认为路由不可达。则将该路由从全局路由表中删除掉，并将该路由条目的开销值改为16。并且将其存放在缓存当中，之后周期更新的时候依然会携带。 —-带毒传输 </p><p>3，垃圾回收计时器 —120S—无效计时器归0后，开始计时，120S时间到则将彻底删除该路由。更新时也不再发送。 </p><h5 id="RIP的破环机制"><a href="#RIP的破环机制" class="headerlink" title="RIP的破环机制"></a>RIP的破环机制</h5><p>1，触发更新 —当网络拓扑结构发生变化时，第一时间将变化信息传递出去</p><p>2，水平分割—从哪个接口学来的不再从哪个接口发出去<br>3，毒性逆转 —从哪个接口学来的还从哪个接口发出去，但是要带毒。</p><p>​        因为毒性逆转和水平分割做法矛盾，所以只能二选其一。华为设备默认开启水平分割，但如果水平分割和毒性逆转同时开启，华为设备将按照毒性逆转的规则来执行。</p><h5 id="RIP的配置"><a href="#RIP的配置" class="headerlink" title="RIP的配置"></a>RIP的配置</h5><p>1，启动RIP进程<br>[r1]rip1 —- 仅具有本地意义，区分多个RIP进程使用（如果不带进程号，默认进入进程1）</p><p>[r1-rip-1]</p><p>2，选择RIP的版本</p><p>[r1-rip-1]version 1 </p><p>3，宣告<br>        宣告的要求∶1，所有直连网段都需要宣告<br>                                2，必须按照主类宣告<br>        [r1-rip-1]network 1.0.0.0 </p><p>宣告的目的<br>1，激活接口— 只有激活的接口才可以收发RIP的数据包<br>2，发布路由—只有激活的接口所对应的网段的路由信息才能发布出去</p><p>[r1]display rip 1 route —查看RIP的路由表</p><h5 id="RIP的拓展配置"><a href="#RIP的拓展配置" class="headerlink" title="RIP的拓展配置"></a><strong>RIP的拓展配置</strong></h5><p>1，RIPV2的手工认证<br>[r1-GigabitEthernet0&#x2F;0&#x2F;0]rip authentication-mode md5 usual plain 123456 (前两个要一样，最后一个都可以)</p><p>2，RIPV2的手工汇总<br>[r1-GigabitEthernet0&#x2F;0&#x2F;0]rip summary-address 192.168.0.0255.255.254.0 </p><p>3，沉默接口<br>[r1-rip-1]silent-interface GigabitEthernet 0&#x2F;O&#x2F;1 </p><p>4，加快收敛—修改计时器<br>[r1-rip-1]timers rip 30 180120 —-修改计时器时不能修改他们的倍数关系</p><p>5，缺省路由<br>[r3-rip-1]default-route originate</p><h3 id="ACL"><a href="#ACL" class="headerlink" title="ACL"></a>ACL</h3><p>ACL—访问控制列表—策略<br>        配置了ACL的网络设备根据事先设定好的报文匹配规则，对经过该设备的流量按照规则进行匹配.对匹配.上的流量执行设定好的动作。</p><p><strong>ACL的功能</strong></p><p>1，访问控制∶在路由器流量流入或者流出的接口上，匹配流量，然后执行设定好的动作。- permit （允许）;deny（拒绝）<br>2，抓取感兴趣流∶ACL和其他服务结合使用，ACL负责匹配对应的流量，而其他的服务对匹配到的流量执行相应的动作。（流量控制 —- ACL和Qos–服务质量技术）</p><p>ACL控制列表的匹配规则<br>自上而下逐一匹配，匹配上，则按照对应的动作执行，不再向下匹配。<br>思科体系的设备，在ACL访问列表的末尾隐含了一条拒绝所有的规则</p><p>华为体系的设备，在ACL访问列表的末尾隐含了一条允许所有的规则</p><p><strong>ACL的分类</strong><br>基本ACL∶仅关注数据包中的源IP。（只看你是谁）<br>高级ACL∶除了关注数据包中的源IP以外，还会关注数据包中的目标IP，及协议和端口号。（不光看你是谁，还要看你去哪，去干嘛）</p><p>二层ACL </p><p>用户自定义ACL</p><p>例：</p><p><img src="/post/2d58191d/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20211118210854732.png" alt="image-20211118210854732"></p><p>需求一∶PC1可以可以访问3.0网段，但是PC2不行<br>基础ACL的位置原则∶由于基础ACL仅关注数据包中的源IP地址，故调用时应尽量靠近目标，避免对其他地址访问误伤</p><p>1，创建 ACL列表</p><p>[r2]acl ?<br>INTEGER&lt;2000-2999&gt; Basic access-list（add to current using rules） -— 基础ACL编号范围<br>INTEGER&lt;3000-3999&gt; Advanced access-list(add to current using rules)—高级ACL编号范围</p><p>INTEGER&lt;4000-4999&gt; Speci fy a L2 acl group —- 二层ACL编号范围<br>ipv6ACL IPv6 </p><p>name Speci fy a named ACL<br>number Speci fy a numbered ACL<br>[r2]acl 2000 </p><p>2，在ACL列表中添加规则<br>[r2-acl-basic-2000]rule deny source 192.168.1.3 0.0.0.0—通配符– 0对应位不可变，1对应位可变。0和1可以穿插使用<br>[r2-acl-basic-2000]rule permit source any – 允许所有</p><p>[r2]display acl 2000 – 查看ACL列表<br>[r2-acl-basic-2000]rule 6 deny source 192.168.1.2 0.0.0.0 —– 通过序号来添加规则<br>[r2-acl-basic-2000]undo rule 6 — 按照序号删除规则<br>华为默认以5为步调自动添加规则序号，其目的时为了方便在中间插入规则。</p><p>3，接口上调用ACL列表<br>[r2-GigabitEthernet0&#x2F;0&#x2F;0]traffic-filter outbound acl 2000<br>切记∶一个接口的一个方向上只能调用一张ACL列表。</p><p> 需求二∶要求PC1可以ping通PC3，但是不能ping通PC4。<br>高级ACL的位置原则;由于高级ACL对流量进行精确匹配，可以避免误伤，所以，调用时应尽量靠近源，减少链路资源的浪费。<br>[r1]aclname xuqiu2 3000 —- 通过重命名的方式创建ACL列表</p><p>[r1-acl-adv-xuqiu2]<br>[r1-acl-adv-xuqiu2]rule deny icmp source 192.168.1.2 0.0.0.0 destination 192.168.3.2 0.0.0.0<br>[r1-GigabitEthernet0&#x2F;0&#x2F;0]traffic-filter inbound acl name xuqiu2 –通过重命名的方式调用ACL列表</p><p>需求三∶要求PC1可以ping通R2，但是不能telnet R2</p><p>telnet – 远程登录协议</p><p>带内管理 — 通过网络对设备进行管理控制<br>        通过telnet&#x2F;SSH管理设备</p><p>​通过web进行设备管理</p><p>​通过SNMP协议进行设备管理<br>带外管理 — 不需要通过网络对设备进行管理控制<br>​通过console口进行管理</p><p>​通过AUX接口进行管理</p><p>telnet实现远程登录的两个必要条件<br>        1，登陆设备和被登录设备网络可达</p><p>​2，被登录设备必须开启telnet服务</p><p>telnet -— 典型C&#x2F;S架构的协议。登录设备扮演telnet客户端的角色，被登录设备扮演telnet服务器的角色。 — TCP 23</p><p>路由器开启telnet服务的方法</p><p>1，进入aaa服务</p><p>[r2]asa—- 专门存储和管理账号的地方</p><p>[r2-aaa]<br>2，创建登录用的用 户名和密码<br>[r2-aaa]local-user admin privilege level 15 password cipher 123456 </p><p>[r2-aa]<br>3，定义该用户所对应的服务<br>[r2-aaa]local-user admin service-type telnet </p><p>4，开启虚拟的登录端口<br>[2]user-interface vty 0 4 -—– 同时开启5个虚拟的登录端口</p><p>[r2-ui-vty0-4]</p><p>5，定义登录认证模式<br>[r2-ui-vtyO-4]authentication-mode aaa</p><p>[r1-acl-adv-3000]rule deny tcp source 192.168.1.10 0.0.0.0 destination 192.168.2.2 0.0.0.0 destination-port eq 23 </p><p>[r1-GigabitEthernetO&#x2F;0&#x2F;0]traffic-filter inbound acl 3000</p><h2 id="Day7"><a href="#Day7" class="headerlink" title="Day7"></a>Day7</h2><h3 id="OSPF"><a href="#OSPF" class="headerlink" title="OSPF"></a>OSPF</h3><p>1，选路的好坏</p><p>2，收敛速度</p><p>3，占用资源大小</p><p>选路佳，收敛快，占用资源小<br>0SPF —- 开放式最短路径优先协议 —– 典型的链路状态型协议<br>RIP — RIPV1, RIPV2 – IPV4 </p><p>​RIPNG — IPV6<br>ospf —- OSPFV1（在实验室阶段夭折了），0SPFV2 — IPV4<br>​OSPFV3 – IPV6</p><h4 id="RIPV2和0SPFV2的相同点和不同点"><a href="#RIPV2和0SPFV2的相同点和不同点" class="headerlink" title="RIPV2和0SPFV2的相同点和不同点"></a>RIPV2和0SPFV2的相同点和不同点</h4><p><strong>相同点</strong>∶</p><p>1，0SPFV2和RIPV2都是无类别的路由协议，都支持VLSM和CIDR<br>传递路由信息时携带子网掩码<br>2，OSPFV2和RIPV2都是以组播的形式发送。<br>RIPV2 —224.0.0.9<br>ospfv2 -—- 224.0.0.5和224.0.0.6<br>3，ospfv2和RIPV2一样都支持等开销负载均衡</p><p><strong>不同点</strong>∶<br>RIP只能应用在小型的网络环境当中，但是OSPF可以应用在中大型网络环境当中。</p><h4 id="区域划分"><a href="#区域划分" class="headerlink" title="区域划分"></a>区域划分</h4><p>0SPF为了适应中大型的网络环境，需要进行<strong>结构化部署</strong>。– 区域划分<br>如果一个网络中只包含一个0OSPF区域，则我们将这样的网络称为单区域0SPF网络。<br>如果一个网络中只包含多个0SPF区域，则我们将这样的网络称为多区域0SPF网络。</p><p><strong>划分区域的主要目的</strong>∶区域内部传递拓扑信息，区域之间传递路由信息</p><p>区域边界路由器（ABR）;同时属于两个区域，一个接口属于一个区域，而且至少有一个接口在区域0。<br>区域之间可以存在多个ABR，一个ABR可以属于多个区域</p><p><strong>区域划分的要求</strong>∶</p><p>1，区域之间必须存在ABR </p><p>2，区域划分必须按照星型拓扑结构划分 — 所有区域都需要围绕骨干区域进行划分<br>为了方便管理，我们给0SPF的区域增加了编号标识 — 区域ID（area ID） —– 由32位二进制构成 — 我们规定，骨干区域的编号必须是区域0。</p><h4 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h4><h5 id="1，OSPF的数据包类型"><a href="#1，OSPF的数据包类型" class="headerlink" title="1，OSPF的数据包类型"></a><strong>1，OSPF的数据包类型</strong></h5><p>0SPF一共有5种数据包<br>1，hello包 —- 用来周期发现，建立和保活邻居关系的。<br>        0SPF的hello包默认是以10S为周期发送一个<br>        OSPF的失效判定时间为4倍的hello时间 —– 死亡时间（dead tme)</p><p>RID – 用来区分和标识0SPF网络中的路由器<br>            1，全网唯一（0SPF网络）;2，格式统一（统一按照IP地址的格式来定义） </p><p>RID的获取方法∶<br>        1，手动配置 —符合上述两个要求即可<br>        2，自动生成 — 先从环回地址中取最大的IP作为RID，若没有环回地址，则取物理接口中最大的IP作为RID。</p><p>hello包中会携带RID。</p><p>2，DBD包 — 数据库描述报文 -— lsdb（链路状态数据库） -—–菜单<br>3，LSR包 -— 链路状态请求报文 -— 基于DBD包请求未知的LSA信息<br>4，LSU包 — 链路状态更新报文 — 真正携带LSA信息的报文<br>5，LSACK包 —– 链路状态确认报文</p><p>0SPF存在每30Min一次的周期更新。</p><h5 id="2，OSPF的状态机"><a href="#2，OSPF的状态机" class="headerlink" title="2，OSPF的状态机"></a><strong>2，OSPF的状态机</strong></h5><p><img src="/post/2d58191d/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20211119093820817.png" alt="image-20211119093820817"></p><p>two - way -—- 双向通讯 –—— 标志着邻居关系的建立（条件匹配）–— 条件匹配成功，则进入下一个状态，如果匹配失败则停留在邻居关系，使用hello包进行保活</p><p><img src="/post/2d58191d/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20211119094556200.png" alt="image-20211119094556200"></p><p>EXSTART状态 — 使用未携带数据的DBD包（为了和之前的邻居关系进行区分），进行主从关系选举 -— 通过比较RID，RID大的为主，可以优先进入下一个状态 </p><p><img src="/post/2d58191d/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20211119095212306.png" alt="image-20211119095212306"></p><p>full — 转发状态 — 标志着邻接关系的建立。<br>            邻接状态 — 主要目的是为了和前面邻居状态进行区分。邻接关系之间才能真正的进行LSA信息的交换。而邻居之间仅使用hello包进行保活。</p><p><strong>总结</strong></p><p>1.down状态 –— 启动0SPF，发出hello包，进入下一个状态</p><p>2.init(初始化)状态 -—– 收到hello包中包含本地的RID，进入下一个状态<br>3.two-way(双向通讯)状态 — 标志着邻居关系的建立</p><p>(条件匹配)条件匹配成功，则进入下一个状态; 失败则停留在邻居状态，仅hello包保活。<br>4.exstart(预启动)状态 -— 使用未携带数据的DBD包(为了和之前的邻居关系进行区分)，进行主从关系选举 — 通过比较RID.RID大的为主，可以优先进入下一个状态<br>5.exchange(准交换)状态 —– 使用携带目录信息的DBD包进行目录共享</p><p>6.Loading(加载)状态 —– 查看对端发送的DBD包与本端LSDB数据库中的LSA信息进行对比，基于未知的LSA信息，使用LSR包请求，邻居使用LSU包进行回复.需要ACK确认。<br>7.FULL(转发)状态 —– 交换完成后进入，标志着邻接关系的建立。</p><h5 id="3，0SPF的工作过程"><a href="#3，0SPF的工作过程" class="headerlink" title="3，0SPF的工作过程"></a>3，0SPF的工作过程</h5><p>​启动配置完成后，OSPF将向本地所有运行协议的接口以组播224.0.0.5发送hello包;hello包，中携带本地的RID及本地己知的邻居的RID。之后，将收集到的邻居关系记录在一张表中 —- <strong>邻居表</strong></p><p>​邻居表建立完成后进行条件匹配。匹配失败则停留在邻居关系，仅使用hello包进行保活。<br>​匹配成功，则开始建立邻接关系。首先，使用未携带数据的DBD包，进行主从关系的选举。之后使用携带数据的DBD包共享数据库目录。之后。本地使用LSR&#x2F;LSU&#x2F;LSACK数据包，获取未知的LSA信息。完成本地数据库的建立。生成<strong>数据库表</strong>—- LSDB<br>​最后， 基于本地的链路状态数据库， 生成有向图及最短路径树，之后计算本地到达未知网段的路由信息，将生成的路由添加到<strong>路由表</strong>中。</p><p>​收敛完成，hello包依然会10S一次进行周期发送，周期保活。每30Min进行一次周期更新。</p><p><strong>网络结构发生突变∶</strong><br>        1，新增一个网段∶触发更新，直接发送携带LSA信息的LSU包进行更新，需要ACK确认<br>        2，断开一个网段∶触发更新，直接发送携带LSA信息的LSU包，进行更新，需要ACK确认<br>        3，无法沟通 — 40S 死亡时间</p><h5 id="4，0SPF的基本配置"><a href="#4，0SPF的基本配置" class="headerlink" title="4，0SPF的基本配置"></a>4，0SPF的基本配置</h5><p>1，启动0SPF进程<br>[r1]ospf 1 router-id 1.1.1.1 </p><p>r1-ospf-1]</p><p>2，创建区域</p><p>[r1-ospf-1]area 0 </p><p>[r1-ospf-1-area-0.0.0.0]</p><p>3，宣告<br>宣告的目的∶激活接口，发布路由<br>[r1-ospf-1-area-0.0.0.0]network 12.0.0.1 0.0.0.0-—反掩码(0代表不可变，1代表可变)(由连续的0和1组成)</p><p>[r1-ospf-1-area-0.0.0.0]network 1.1.1.1 0.0.0.255</p><p>[r1]display ospf peer—– 查看OSPF的邻居表<br>[r1]display ospf peer brief —- 查看0SPF的邻居表简表</p><p>[r1]display ospf lsdb -— 查看OSPF的链路状态数据库[r1]display ospf lsdb router 2.2.2.2 -— 查看具体LSA信息</p><p>华为设备0SPF协议的默认优先级为10</p><p>0SPF是以带宽作为COST值的评判标准<br>COST &#x3D; 参考带宽&#x2F;真实带宽 —- 华为设备参考带宽的默认值为100Mbps</p><p>[r1-ospf-1]bandwidth-reference 1000 — 修改参考带宽的方法<br>注意∶一台路由器的参考带宽修改了，则所有路由器的参考带宽都需要修改成一样的。</p><h6 id="条件匹配"><a href="#条件匹配" class="headerlink" title="条件匹配"></a>条件匹配</h6><p>指定路由器 —DR </p><p>备份指定路由器 — BDR </p><p>剩余的路由 —– DRother</p><p>DR和BDR虽然叫指定路由器或备份指定路由器，但其实是一个接口的概念。</p><p>条件匹配∶在一个广播域中，如果所有设备都保持邻接关系，可能会出现大量的重复更新;所以需要进行DR&#x2F;BDR的选举;所有非DR和BDR的设备之间仅保持邻居关系。</p><p>DR&#x2F;BDR的选举规则∶<br>1，先比较优先级，优先级大的为DR，次大的为BDR。优先级初始默认都为1。<br>        [r1-GigabitEthernet0&#x2F;0&#x2F;0]ospf dr-priority ?<br>        NTEGER&lt;0-255&gt; Router priority value </p><p>​优先级的取值范围是0-255<br>​如果优先级设置为0.则代表该接口放弃DR和BDR的选举。<br>2，当优先级相同时，则比较RID。RID大的路由器所对应的接口为DR，次大的为BDR。<br>​DR&#x2F;BDR的选举是非抢占模式的 – 即一旦DR和BDR选举完毕后，不会因为新加入的设备而重新选举。选举时间为40S。<br>​<r3>reset ospf 1 process —- 重启0SPF进程</r3></p><h5 id="5，0SPF的拓展配置"><a href="#5，0SPF的拓展配置" class="headerlink" title="5，0SPF的拓展配置"></a>5，0SPF的拓展配置</h5><p>1，手工认证<br>        [r1-GigabitEthernet0&#x2F;0&#x2F;0]ospf authentication-mode md5 1 cipher 123456</p><p>​1 —– 代表的是key ID，需要确保两端的keyID相同即可<br>2，手工汇总—0SPF区域之间传递路由信息，可以进行汇总，所以，0SPF的手工汇总实际上是区域汇总。<br>​[r2-ospf-1-area-0.0.0.0]abr-summary 192.168.0.0</p><p>​255.255.254.0 </p><p>3，沉默接口<br>        [r1-ospf-1]silent-interface GigabitEthernet 0&#x2F;0&#x2F;1 </p><p>4，加快收敛 — 减少计时器<br>        [r1-GigabitEthernet0&#x2F;0&#x2F;0]ospf timer hello 5<br>        注意∶邻居之间的hello时间必须一致，否则将无法建立邻居关系<br>        hello时间修改之后，死亡时间将自动按照四倍关系进行匹配</p><p>5，缺省路由<br>        [r3-ospf-1]default-route-advertise — 在边界路由器上下发缺省信息（OSPF要求边界路由器自身必须先有缺省才能下发缺省）<br>        [r3-ospf-1]default-route-advertise always — 在边界路由器上没有缺省路由时，可以添加always来强制下发缺省信息</p><h2 id="Day8"><a href="#Day8" class="headerlink" title="Day8"></a>Day8</h2><h3 id="VLAN"><a href="#VLAN" class="headerlink" title="VLAN"></a>VLAN</h3><p> V– 虚拟<br>LAN —– 局域网 – 地理覆盖范围较小的网络 </p><p>MAN — 城域网</p><p>WAN – 广域网</p><p>VLAN中的LAN指的是广播域</p><p>VLAN -— 虚拟局域网 —— 交换机和路由器协同工作后，将原来的一个广播域，逻辑上切分为多个虚拟的广播域。</p><p><strong>第一步∶创建VLAN</strong> </p><p><Huawe i>display vlan</Huawe></p><p>IEEE — 802.10标准 &#x3D; dot1q<br>        VID-— VLAN ID —— 用来区分和标定不同的VLAN。VID由12位二进制构成，取值范围0- 4095。0和4095作为保留，1-4094。</p><p>[Huaweij]vlan 2 -— 创建VLAN </p><p>[Huawe i-v lan2]<br>[Huawei]vlan batch 4 to 100 – 批量创建VLAN </p><p>[Huawei]undo vlan batch 4 to 100 —- 批量删除VLAN</p><p><strong>第二步∶将接口划分到VLAN中</strong><br>VID配置映射到交换机的接口，实现VLAN的划分 ——— 一层VLAN&#x2F;物理VLAN </p><p>VID配置映射MAC地址，来实现VLAN的划分 —— 二层VLAN<br>数据帧中类型字段标识是上层协议类型，和VID进行映射，来区分VLAN范围 —– 三层VLAN </p><p><img src="/post/2d58191d/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20211120201511102.png" alt="image-20211120201511102"></p><p>​交换机的转发原理∶数据通过接口来到交换机，交换机先记录源MAC地址和接口的映射关系，顺便，将接口对应的VID进行记录。之后，看目标MAC地址，若目标MAC地址在MAC地址表中有记录且VID和源MAC对应的VID相同，则进行单播;否则，进行泛洪 ，泛洪范围为VID与源MAC对应的VID相同的接口。<br>​因为以太网Ⅱ型针没有添加标签的位置，所以，802.1Q规定，在源MAC地址和type字段之间增加4个字节的tag（标签）（一定包含12位的VID）。这样新的帧结构我们称为802.10Q帧或者叫tagged帧。将没有打标签的帧称为untagged帧。<br>​我们把交换机和计算机之间的链路称为ACCESS链路，ACCESS链路只能通过untagged 的帧，并且，这些帧只能属于某一个特定的VLAN。我们把交换机和交换机之间链路称为trunk链路（trunk干道），trunk干道中运行通过tagged帧，且这些帧可以属于多个VLAN。</p><p>第二步配置<br>[sw1-GigabitEthernet0&#x2F;0&#x2F;1]port link-type access </p><p>[sw1-GigabitEthernet0&#x2F;0&#x2F;1]port default vlan 2<br>[sw1]port-group group-member GigabitEthernet 0&#x2F;0&#x2F;3 to GigabitEthernet 0&#x2F;0&#x2F;4<br>[sw1-port-gr oup] - 创建接口组</p><p><strong>第三步∶配置TRUNK千道（SW - SW，SW - R）</strong></p><p>第三步配置<br>[sw1-GigabitEthernet0&#x2F;0&#x2F;5]port link-type trunk —— 定义链路类型</p><p>[sw1-GigabitEthernet0&#x2F;0&#x2F;5]port trunk allow-pass vlan 2 to 3-— 放通对应VLAN流量<br>[sw2-GigabitEthernet0&#x2F;0&#x2F;1]port trunk allow-pass vlan all —— 放通所有流量</p><p><strong>第四步∶VLAN间路由 —单臂路由</strong><br>路由器的子接口 —— 路由器的虚拟接口 -— 将路由器的一个物理接口逻辑上划分为多个虚拟的子接口<br>[Huawei]int g 0&#x2F;0&#x2F;0.1<br>[Huawei-GigabitEthernet0&#x2F;0&#x2F;0.1]—- 创建子接口</p><p>配置子接口：<br>[Huawei-GigabitEthernet0&#x2F;0&#x2F;0.1]ip address 192.168.1.254 24</p><p> [Huawei-GigabitEthernet0&#x2F;0&#x2F;0.1]—- 给子接口配置IP地址<br>[Huawei-GigabitEthernet0&#x2F;0&#x2F;0.1]dot1q termination vid 2 —- 定义子接口管理的VID<br>[Huawei-GigabitEthernet0&#x2F;0&#x2F;0.1]arp broadcast enable— 开启ARP广播</p><h3 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h3><p>在IP地址空间中，A，B，C三类地址中各有一部分地址，他们被称为私有地址（私网IP地址），其余的所有地址都称为公有地址（公网IP地址）<br>A∶10.0.0.0-10.255.255.255 — 相当于一个A类的网段</p><p>B∶172.16.0.0- 172.31.255.255 —— 相当于16条B类网段</p><p>C∶192.168.0.0-192.168.255.255 —-相当于256条C类的网段</p><p>私网IP地址 –— 可复用性（仅保持私网内部的唯一性即可） —— 不能再互联网中使用<br>我们将使用私网IP地址搭建的网络称为私网，将使用公网IP地址进行通信的网络称为公网。<br>NAT技术 -— 网络地址转换技术 ——— 他的基本作用就是实现私网IP地址和公网IP地址之间的一个转换。</p><p>华为设备，所有NAT相关的配置，都是在边界路由器的出接口上进行配置的。</p><p>静态NAT </p><p>动态NAT </p><p>NAPT </p><p>端口映射</p><p><strong>静态NAT —一对一的NAT</strong><br>静态NAT就是通过配置，在私网边界路由器上建立维护一张<strong>静态地址映射表</strong>。静态地址映射表中记录的是公网IP地址和私网IP地址之间一一对应的关系。<br>[r2-GigabitEthernet0&#x2F;0&#x2F;2]nat staticglobal <strong>12.0.0.3</strong> inside 192.168.1.2 </p><p>1，必须和公网IP在同一个网段</p><p>2，这个IP地址一定是你花钱问ISP买来的</p><p>​12.0.0.3这个地址称为漂浮地址</p><p>[r2]di splay nat static —- 查看静态地址映射表</p><p><strong>动态NAT– 多对多的NAT</strong></p><p>1，创建公网IP地址组<br>[r2]nat address-group 1 12.0.0.4 12.0.0.8 </p><p>一定买的是连续的公网IP地址</p><p>2，通过ACL来抓取私网IP流量</p><p>[r2]acl 2000<br>[r2-acl-basic-2000]rule permit source 192.168.0.00.0.255.255 </p><p>3，将公网IP组和ACL抓取的流量绑定<br>[r2-GigabitEthernet0&#x2F;0&#x2F;2]nat outbound 2000 address-group1 no-pat</p><p>动态MAT在同一时间内，依然是一对一的NAT。当上网需求量过大时，延迟会较高。</p><p><strong>NAPT</strong> –— 网络地址端口转换 —– PAT </p><p>一对多的NAPT — EASY IP</p><p> 1，抓取私网流量<br>[r2-acl-basic-2000]rule permit source 192.168.0.0 0.0.255.255 </p><p>2.配置EASY IP<br>[r2-Gi gabitEthernet0&#x2F;0&#x2F;2]nat outbound 2000</p><p>多对多的NAPT </p><p>1，创建公网IP地址组<br>[r2]nat address-group 1 12.0.0.4 12.0.0.8<br>一定买的是连续的公网IP地址</p><p>2，通过ACL来抓取私网IP流量</p><p>[r2]ac I 2000<br>[r2-acl-basic-2000]rule permit source 192.168.0.0 0.0.255.255 </p><p>3，将公网IP组和ACL抓取的流量绑定<br>[r2-GigabitEthernet0&#x2F;0&#x2F;2]nat outbound 2000 address-group 1</p><p><strong>端口映射</strong><br>[r2-GigabitEthernet0&#x2F;0&#x2F;2]nat server protocol tcp global 12.0.0.1 80 inside 192. 168.1.10 80</p><p>[r2-GigabitEthernet0&#x2F;0&#x2F;2]nat server protocol tcp global current-interface 80 inside 192. 168.1.10 80<br>Warning:The port 80 is well-known port.If you continue it may cause function fai lure.<br>Are you sure to cont inue?[Y&#x2F;N]:y</p>]]></content>
      
      
      <categories>
          
          <category> HCIA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL</title>
      <link href="/post/c24675b4.html"/>
      <url>/post/c24675b4.html</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="一、初识MySQL"><a href="#一、初识MySQL" class="headerlink" title="一、初识MySQL"></a>一、初识MySQL</h2><p>MySQL是一个开放源代码的数据库管理系统（DBMS），是由MySQL 公司开发、发布并支持的。<br>MySQL是一个跨平台的开源关系型数据库管理系统，广泛地应用在Internet上的中小型网站开发中。</p><h3 id="1、数据库基础"><a href="#1、数据库基础" class="headerlink" title="1、数据库基础"></a>1、数据库基础</h3><p>数据库由一批数据构成有序的集合，这些数据被存放在结构化的数据表里。数据表之间相互关联，反映了客观事物间的本质联系。数据库系统提供对数据的安全控制和完整性控制。</p><h3 id="1-1-什么是数据库"><a href="#1-1-什么是数据库" class="headerlink" title="1.1 什么是数据库"></a>1.1 什么是数据库</h3><p>数据库的概念诞生于60年前，随着信息技术和市场的快速发展，数据库技术层出不穷，随着应用的拓展和深入，数据库的数量和规模越来越大，其诞生和发展给计算机信息管理带来了一场巨大的革命。数据库的发展大致划分为如下几个阶段：人工管理阶段、文件系统阶段、数据库系统阶段、高级数据库阶段。其种类大概有3种：层次式数据库、网络式数据库和关系式数据库。不同种类的数据库按不同的数据结构来联系和组织。对于数据库的概念，没有一个完全固定的定义，随着数据库历史的发展，定义的内容也有很大的差异，其中一种比较普遍的观点认为，数据库（DataBase，DB）是一个长期存储在计算机内的、有组织的、有共享的、统一管理的数据集合。它是一个按数据结构来存储和管理数据的计算机软件系统。数据库包含两层含义：保管数据的“仓库”，以及数据管理的方法和技术。<br>数据库的特点是：实现数据共享，减少数据冗余；采用特定的数据类型；具有较高的数据独立性；具有统一的数据控制功能。</p><h3 id="1-2-表"><a href="#1-2-表" class="headerlink" title="1.2 表"></a>1.2 表</h3><p>在关系数据库中，数据库表是一系列二维数组的集合，用来存储数据和操作数据的逻辑结构。它由纵向的列和横向的行组成。行被称为记录。是组织数据的单位。列被称为字段，每一列表示记录的一个属性，有相应的描述信息，如数据类型、数据宽度等。<br>比如我们有个员工表，用于保存员工的基本信息</p><p><img src="/post/c24675b4/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220412090813659.png" alt="image-20220412090813659"></p><h3 id="1-3-数据类型"><a href="#1-3-数据类型" class="headerlink" title="1.3 数据类型"></a>1.3 数据类型</h3><p>数据类型决定了数据在计算机中的存储格式，代表不同的信息类型。常用的数据类型有整数数据类型、浮点数数据类型、精确小数类型、二进制数 据类型、日期&#x2F;时间数据类型、字符串数据类型。表中的每一个字段就是某种指定数据类型。</p><table><thead><tr><th><strong>类型</strong></th><th><strong>大小</strong></th><th><strong>范围（有符号</strong></th><th><strong>范围（无符号</strong></th><th><strong>用途</strong></th></tr></thead><tbody><tr><td>TINYINT</td><td>1 Bytes</td><td>(-128，127)</td><td>(0，255)</td><td>小整数值</td></tr><tr><td>SMALLINT</td><td>2 Bytes</td><td>(-32  768，32 767)</td><td>(0，65  535)</td><td>大整数值</td></tr><tr><td>MEDIUMINT</td><td>3 Bytes</td><td>(-8  388 608，8 388 607)</td><td>(0，16  777 215)</td><td>大整数值</td></tr><tr><td>INT或  INTEGER</td><td>4 Bytes</td><td>(-2  147 483 648，  2  147 483 647)</td><td>(0，4  294 967  295)</td><td>大整数值</td></tr><tr><td>BIGINT</td><td>8 Bytes</td><td>(-9,223,372,036,854,775,808，  9  223 372 036 854 775 807)</td><td>(0，  18 446 744  073  709  551 615)</td><td>极大整数值</td></tr><tr><td>FLOAT</td><td>4 Bytes</td><td></td><td></td><td>单精度浮点数值</td></tr><tr><td>DOUBLE</td><td>8Bytes</td><td></td><td></td><td>双精度浮点数值</td></tr><tr><td>DECIMAL</td><td></td><td>对DECIMAL(M,D)  ，如果M&gt;D，为M+2否则为D+2</td><td></td><td>小数值</td></tr></tbody></table><p><strong>日期和时间类型</strong> 表示时间值的日期和时间类型为DATETIME、DATE、TIMESTAMP、TIME和YEAR。</p><table><thead><tr><th><strong>类型</strong></th><th><strong>大小</strong></th><th><strong>范围</strong></th><th><strong>格式</strong></th><th><strong>用途</strong></th></tr></thead><tbody><tr><td>DATE</td><td>3</td><td>1000-01-01&#x2F;9999-12-31</td><td>YYYY-MM-DD</td><td>日期值</td></tr><tr><td>TIME</td><td>3</td><td>‘-838:59:59’&#x2F;‘838:59:59’</td><td>HH:MM:SS</td><td>时间值或持续时间</td></tr><tr><td>YEAR</td><td>1</td><td>1901&#x2F;2155</td><td>YYYY</td><td>年份值</td></tr><tr><td>DATETIME</td><td>8</td><td>1000-01-01  00:00:00&#x2F;9999-  12-31  23:59:59</td><td>YYYY-MM-DD  HH:MM:SS</td><td>混合日期和时间值</td></tr><tr><td>TIMESTAMP</td><td>4</td><td>1970-01-01  00:00:00&#x2F;2038</td><td>YYYYMMDD  HHMMSS</td><td>混合日期和时间值，时间戳</td></tr></tbody></table><p><strong>字符串类型</strong></p><p>字符串类型指CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT。该节描述了这些类型如何工作以及如何在查询中使用这些类型。</p><table><thead><tr><th><strong>类型</strong></th><th><strong>大小</strong></th><th><strong>用途</strong></th></tr></thead><tbody><tr><td>CHAR</td><td>0-255  bytes</td><td>定长字符串</td></tr><tr><td>VARCHAR</td><td>0-65535  bytes</td><td>变长字符串</td></tr><tr><td>BLOB</td><td>0-65  535 bytes</td><td>二进制形式的长文本数据</td></tr><tr><td>TEXT</td><td>0-65  535 bytes</td><td>长文本数据</td></tr></tbody></table><p><strong>主键</strong><br>主键（Primary Key）又称主码，用于唯一地标识表中的每一条记录。可以定义表中的一列或多列为主键，主键列上既不能有两行相同的值，也不能为空值。假如，定义authors表，该表给每一个作者分配一个“作者编号”，该编号作为数据表的主键，如果出现相同的值，将提示错误，系统不能确定查询的究竟是哪一条记录；如果把作者的“姓名”作为主键，则不能出现重复的名字，这与现实中的情况不符，因此“姓名”字段不适合作为主键。</p><h3 id="1-4-数据库技术构成"><a href="#1-4-数据库技术构成" class="headerlink" title="1.4 数据库技术构成"></a>1.4 数据库技术构成</h3><p>数据库系统由硬件部分和软件部分共同构成。硬件主要用于存储数据库中的数据，包括计算机、存储设备等。软件部分主要包括DBMS、支持DBMS运行的操作系统，以及支持多种语言进行应用开发的访问技术等。<br>数据库系统 数据库系统有3个主要的组成部分<br>●数据库：用于存储数据的地方。<br>●数据库管理系统：用于管理数据库的软件。<br>●数据库应用程序：为了提高数据库系统的处理能力所使用的管理数据库的软件补充。<br>数据库系统（Database System）提供了一个存储空间，用以存储各种数据，可以将数据库视为一个存储数据的容器。一个数据库可能包含许多文件，一个数据库系统中通常包含许多数据库。<br>数据库管理系统（DataBase Management System，DBMS）是用户创 建、管理和维护数据库时所使用的软件，位于用户与操作系统之间，对数据库进行统一管理。DBMS能定义数据存储结构，提供数据的操作机制，维护数据库的安全性、完整性和可靠性。 数据库应用程序（DataBase Application）虽然已经有了DBMS，但是在很多情况下，DBMS无法满足对数据管理的要求。数据库应用程序的使用可以满足对数据管理的更高要求，还可以使数据管理过程更加直观和友好。数据库应用程序负责与DBMS进行通信，访问和管理DBMS中存储的数据，允许用户插入、修改、删除DB中的数据。  </p><h4 id="1-4-1-SQL语言"><a href="#1-4-1-SQL语言" class="headerlink" title="1.4.1 SQL语言"></a>1.4.1 SQL语言</h4><p>对数据库进行查询和修改操作的语言叫作SQL。SQL的含义是结构化查询语言（Structured Query<br>Language）。<br>SQL有许多不同的类型，有3个主要的标准：ANSI（美国国家标准机构）SQL；对ANSI SQL修改后在 1992年采纳的标准，称为SQL-92或SQL2； 近的SQL-99标准，从SQL2 扩充而来并增加了对象关系特征和许多其他新功能。各大数据库厂商提供不同版本的SQL。这些版本的SQL不但能包括原始的ANSI标准，而且在很大程度上支 持SQL-92标准。</p><p>SQL语言包含以下4部分。<br>（1）数据定义语言（Data Definition Language   DDL）：DROP、CREATE、ALTER等语句。<br>（2）数据操作语言（Data Manipulation Language  DML）：INSERT（插入）、UPDATE（修改）、DELETE（删除）语句。<br>（3）数据查询语言（Data Query Language   DQL）：SELECT语句。<br>（4）数据控制语言（Data Control Language DCL）：GRANT、REVOKE、COMMIT、 ROLLBACK等语句。</p><h4 id="1-4-2-数据库接口"><a href="#1-4-2-数据库接口" class="headerlink" title="1.4.2 数据库接口"></a>1.4.2 数据库接口</h4><p>不同的程序设计语言会有各自不同的数据库访问接口，程序语言通过这 些接口执行SQL语句，进行数据库管理。主要的数据库访问接口有ODBC、 JDBC、ADO.NET和PDO【PHP】。 </p><p>JDBC（Java Data Base Connectivity，Java数据库连接）用于Java应用程 序连接数据库的标准方法，是一种用于执行SQL语句的Java API，可以为多 种关系数据库提供统一访问，由一组用Java语言编写的类和接口组成。 </p><h2 id="二、MySQL"><a href="#二、MySQL" class="headerlink" title="二、MySQL"></a>二、MySQL</h2><p>MySQL是一个小型关系数据库管理系统。与其他大型数据库管理系统 （例如Oracle、DB2、SQL Server 等）相比，MySQL规模小、功能有限，但是它体积小、速度快、成本低，并且提供的功能对稍微复杂的应用来说已经够用，这些特性使得MySQL成为世界上 受欢迎的开放源代码数据库</p><h3 id="2-1-客户端-x2F-服务器软件"><a href="#2-1-客户端-x2F-服务器软件" class="headerlink" title="2.1 客户端&#x2F;服务器软件"></a>2.1 客户端&#x2F;服务器软件</h3><p>主从式架构（Client-Server Model）或客户端&#x2F;服务器（Client&#x2F;Server）结 构（简称C&#x2F;S结构），是一种网络架构，通常在该网络架构下的软件可分为客户端（Client）和服务器（Server）。服务器是整个应用系统资源的存储与管理中心，多个客户端则各自处理相应的功能，共同实现完整的应用。在客户端&#x2F;服务器结构中，客户端用户的请求被传送到数据库服务器，数据库服务器进行处理后，将结果返回给用户，从而减少了网络数据传输量。用户使用应用程序时，首先启动客户端通过有关命令告知服务器进行连接以完成各种操作，而服务器则按照此请示提供相应的服务。每一个客户端软件的实例都可以向一个服务器或应用程序服务器发出请求。这种系统的特点就是，客户端和服务器程序不在同一台计算机上运行，这些客户端和服务器程序通常归属不同的计算机。主从式架构通过不同的途径应用于很多不同类型的应用程序，比如现在人们 熟悉的在因特网上使用的网页。例如，当顾客想要在当当网站上买书 的时候，电脑和网页浏览器就被当作一个客户端，同时组成当当网的电脑、数据库和应用程序就被当作服务器。当顾客的网页浏览器向当当网请求搜寻 数据库相关的图书时，当当网服务器从当当网的数据库中找<br>出所有该类型的 图书信息，结合成一个网页，再发送回顾客的浏览器。服务器一般使用高性 能的计算机，并配合使用不同类型的数据库，比如Oracle、Sybase或者是MySQL等；客户端需要安装专门的软件，比如专门开发的客户端工具浏览。</p><p><strong>MySQL的不同版本</strong> </p><p>MySQL Community Server（社区版服务器）该版本完全免费，但是官方不提供技术支持。<br>  MySQL Enterprise Server（企业版服务器）能够以很高的性价比为企业提供数据仓库应用，支持ACID 事物处理，提供完整的提交、回滚、崩溃恢复和行级锁定功能。但是该版本需付费使用，官方提供电话技术支持。 MySQL Cluster主要用于架设集群服务器，需要在社区版或企业版基础上使用。<br>MySQL 8.0是 新开发的稳定（GA）发布系列，是将执行新功能的系列，目前已经可以正常使用。<br>MySQL 8.0是比较稳定（GA）发布系列。只针对漏洞修复重新发 布，没有增加会影响稳定性的新功能。<br>MySQL 5.7是前一稳定（产品质量）发布系列。只针对严重漏洞 修复和安全修复重新发布，没有增加会影响该系列的重要功能。 </p><p><strong>MySQL的优势：</strong><br>（1）速度：运行速度快。<br>（2）价格：MySQL对多数个人来说是免费的。（3）容易使用：与其他大型数据库的设置和管理相比，其复杂程度较低，易于学习<br>（4）可移植性：能够工作在众多不同的系统平台上，例如Windows、 Linux、UNIX、Mac OS等。<br>（5）丰富的接口：提供了用于C、C++、Eiffel、Java、Perl、PHP、 Python、Ruby和Tcl等语言的<br>API。<br>（6）支持查询语言：MySQL可以利用标准SQL语法和支持ODBC的应用程序。<br>（7）安全性和连接性：十分灵活和安全的权限和密码系统，允许基于主机的验证。连接到服务器时，所有的密码传输均采用加密形式，从而保证 了密码安全。由于MySQL是网络化的，因此可以在因特网上的任何地方访 问，提高数据共享的效率。</p><p>MySQL 8.0的新特性和MySQL 5.7相比，MySQL 8.0的新特性主要包括以下几个方面。<br><strong>1.数据字典</strong><br>MySQL 8.0包含一个事务数据字典，用于存储有关数据库对象的信息。在MySQL 8.0之前的版本中，字典数据存储在元数据文件和非事务表中。<br><strong>2.原子数据定义语句</strong><br>MySQL 8.0支持原子数据定义语言（DDL）语句。此功能称为原子 DDL。原子DDL语句将与DDL操作关联的数据字典更新，存储引擎操作和 二进制日志写入组合到单个原子事务中。即使服务器在操作期间暂停，也会 提交事务，并将适用的更改保留到数据字典、存储引擎和二进制日志，或者<br>回滚事务。通过在MySQL 8.0中引入MySQL数据字典，可以实现原子 DDL。在早期的MySQL版本中，元数据存储在元数据文件、非事务性表和 存储引擎特定的字典中，需要中间提交。MySQL数据字典提供的集中式事 务元数据存储消除了这一障碍，使得将DDL语句操作重组为原子事务成为可能。</p><p><strong>3.安全和账户管理</strong><br>MySQL 8.0通过以下功能增强数据库的安全性，并在账户管理中实现更<br>高的DBA灵活性。 MySQL数据库的授权表统一为InnoDB（事务性）表。每个语句都是事务性的，并且对所有创建的用户都是成功或者回滚，发生任何错误都无效。如果成功，就将语句写入二进制日志；如果失败则不写入，发生回滚并且不<br>进行任何更改。 MySQL 8.0开始支持角色，角色可以看成是一些权限的集合，为用户赋予统一的角色，权限的修改直接通过角色来进行，无须为每个用户单独授<br>权。管理员可以创建和删除角色。 MySQL 8.0开始维护有关密码历史的信息，从而限制了以前密码的重 用。管理员可以在全局以及每个账户的基础上建立密码重用策略，从而在密<br>码更改时限制使用以前使用过的密码。 MySQL 8.0允许账户具有双密码，从而在多服务器系统中无缝地执行分 阶段密码更改，无须停机。 </p><p><strong>4.资源管理</strong><br>MySQL现在支持资源组的创建和管理，并允许将服务器内运行的线程 分配给特定的资源组。资源组属性可以控制其资源，以启用或限制资源组中 线程的资源消耗。数据库管理员可以根据不同的工作负载修改这些属性。</p><p><strong>5.InnoDB增强功能</strong></p><p>MySQL 8.0增强了InnoDB的功能，主要表现如下：<br>（1）MySQL 8.0将自增主键的计数器持久化到重做日志中。每次计数<br>器发生改变，都会将其写入重做日志中。如果数据库重启，InnoDB会根据重做日志中的信息来初始化计数器的内存值。为了尽量减小对系统性能的影响，计数器写入重做日志时，并不会马上刷新数据库系统。<br>（2）如果索引损坏，InnoDB将索引损坏标志写入重做日志，从而使得<br>损坏标志安全。InnoDB还将内存中损坏标志数据写入每个检查点上的引擎专用系统表。在恢复期间，InnoDB从两个位置读取损坏标志并在将内存表和索引对象标记为损坏之前合并结果。<br>（3）新的动态变量innodb_deadlock_detect可用于禁用死锁检测。在高<br>并发系统上，当许多线程等待同一个锁时，死锁检测会导致速度减慢，此时禁用死锁检测可能更有效。<br>  <strong>6.字符集支持</strong><br>默认字符集已经更改latin1为utf8mb4。该utf8mb4字符集有几个新的排 序规则，其中包括 utf8mb4_ja_0900_as_cs。<br>  <strong>7.增加JSON功能</strong><br>MySQL增强JSON功能主要表现在以下几个方面：<br>（1）添加了-&gt;&gt;运算符，相当于调用JSON_UNQUOTE()的结果。<br>（2）添加了两个JSON聚合函数JSON_ARRAYAGG()和 39JSON_OBJECTAGG()。JSON_ARRAYAGG()将列或表达式作为其参数，并 将结果聚合为单个JSON数组。JSON_OBJECTAGG()取两个列或表达式，将 其解释为键和值，并将结果作为单个JSON对象返回。<br>（3）添加了JSON实用程序功能JSON_PRETTY()，JSON以易于阅读的 格式输出现有值；每个JSON对象成员或数组值都打印在一个单独的行上子对象或数组相对于其父对象是2个空格。<br>（4）添加的JSON_MERGE_PATCH()可以合并符合RFC 7396标准的 JSON。在两个JSON对象上使用时，可以将它们合并为单个JSON对象。<br> <strong>8.数据类型支持</strong><br>MySQL 8.0支持将表达式用作数据类型的默认值，包括BLOB、TEXT、 GEOMETRY和JSON数据类型，在以前的版本中是根本不会被分配默认值 的。</p><p><strong>9.查询的优化</strong><br>MySQL 8.0在查询方面的优化表现如下：<br>（1）MySQL<br>8.0开始支持不可见索引。优化器根本不使用不可见索 引，但会以其他方式正常维护。默认情况下，索引是可见的。通过不可见索 引，数据库管理员可以检测索引对查询性能的影响，而不会进行破坏性的更 改。<br>（2）MySQL8.0开始支持降序索引。DESC在索引定义中不再被忽略， 而且会降序存储索引字段。</p><h3 id="2-2MySQL的安装与配置"><a href="#2-2MySQL的安装与配置" class="headerlink" title="2.2MySQL的安装与配置"></a>2.2MySQL的安装与配置</h3><p>查看是否链接成功</p><p><img src="/post/c24675b4/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220412091517752.png" alt="image-20220412091517752"></p><h2 id="三、数据库基本操作"><a href="#三、数据库基本操作" class="headerlink" title="三、数据库基本操作"></a>三、数据库基本操作</h2><h3 id="3-1-创建数据库"><a href="#3-1-创建数据库" class="headerlink" title="3.1 创建数据库"></a>3.1 创建数据库</h3><p>MySQL安装完成之后，将会在其data目录下自动创建几个必需的数据 库，可以使用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> DATABASES;</span><br></pre></td></tr></table></figure><p>语句来查看当前所有存在的数据库， 输入语句如下。</p><p><img src="/post/c24675b4/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220412091543395.png" alt="image-20220412091543395"> </p><p>其中有六个库是mysql必须的，其余是自己创建的库。如何自己创建库呢？可以使用sql语句创建数据库;</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE database_name;</span><br></pre></td></tr></table></figure><p>可以使用命令查看数据库的定义</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> DATABASE mybatis;</span><br></pre></td></tr></table></figure><p><img src="/post/c24675b4/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220412091909792.png" alt="image-20220412091909792"></p><h3 id="3-2-删除数据库"><a href="#3-2-删除数据库" class="headerlink" title="3.2 删除数据库"></a>3.2 删除数据库</h3><p>删除数据库是将已经存在的数据库从磁盘空间上清除，清除之后，数据 库中的所有数据也将一同被删除。删除数据库语句和创建数据库的命令相 似，MySQL中删除数据库的基本语法格式为： </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> DATABASE database_name</span><br></pre></td></tr></table></figure><p>其中，“database_name”为要删除的数据库的名称。若指定的数据库不存 在，则删除出错</p><h3 id="3-3-InnoDB表"><a href="#3-3-InnoDB表" class="headerlink" title="3.3 InnoDB表"></a>3.3 InnoDB表</h3><p>从MySQL 8.0开始，系统表全部换成事务型的InnoDB表，默认的 MySQL实例将不包含任何MyISAM 表，除非手动创建MyISAM表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> ENGINE <span class="keyword">FROM</span> information_schema.`TABLES`;</span><br></pre></td></tr></table></figure><p><img src="/post/c24675b4/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220412092010416.png" alt="image-20220412092010416"></p><h3 id="面试题："><a href="#面试题：" class="headerlink" title="面试题："></a>面试题：</h3><p>InnoDB和MyISAM的区别</p><p><strong>区别：</strong></p><ol><li>InnoDB 支持事务，MyISAM 不支持事务。这是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；</li><li>InnoDB 支持外键，而 MyISAM 不支持。对一个包含外键的 InnoDB 表转为 MYISAM 会失败；  </li><li>InnoDB 是聚集索引，MyISAM 是非聚集索引。聚簇索引的文件存放在主键索引的叶子节点上，因此 InnoDB 必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而<br>MyISAM 是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。 </li><li>InnoDB 不保存表的具体行数，执行 select count(*) from table 时需要全表扫描。而MyISAM 用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；    </li><li>InnoDB 小的锁粒度是行锁，MyISAM 小的锁粒度是表锁。一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，因此并发访问受限。这也是 MySQL 将默认存储引擎从 MyISAM 变成<br>InnoDB 的重要原因之一；</li></ol><p><strong>如何选择：</strong></p><ol><li>是否要支持事务，如果要请选择 InnoDB，如果不需要可以考虑 MyISAM；</li><li>如果表中绝大多数都只是读查询，可以考虑 MyISAM，如果既有读写也挺频繁，请使用InnoDB。</li><li>系统奔溃后，MyISAM恢复起来更困难，能否接受，不能接受就选 InnoDB；</li><li>MySQL5.5版本开始Innodb已经成为Mysql的默认引擎(之前是MyISAM)，说明其优势是有目共睹的。如果你不知道用什么存储引擎，那就用InnoDB，至少不会差。</li><li>删除数据库时需要注意什么？<br>使用DROP DATABASE命令时要非常谨慎，在执行该命令时，MySQL 不会给出任何提醒确认信<br>息。用DROP DATABASE声明删除数据库后，数 据库中存储的所有数据表和数据也将一同被删除，而且不能恢复。</li></ol><h3 id="练习："><a href="#练习：" class="headerlink" title="练习："></a><strong>练习：</strong></h3><p>​    1.查看当前系统中的数据库<br>​    2.创建数据库mydb,使用语句查看数据库定义新新<br>​    3.删除数据库mydb</p><h2 id="四、数据表的基本操作"><a href="#四、数据表的基本操作" class="headerlink" title="四、数据表的基本操作"></a>四、数据表的基本操作</h2><h3 id="4-1-创建数据表"><a href="#4-1-创建数据表" class="headerlink" title="4.1 创建数据表"></a>4.1 创建数据表</h3><p>在创建完数据库之后，接下来的工作就是创建数据表。所谓创建数据 表，指的是在已经创建好的数据库中建立新表。创建数据表的过程是规定数 据列的属性的过程，同时也是实施数据完整性（包括实体完整性、引用完整 性和域完整性等）约束的过程。<br>数据表属于数据库，在创建数据表之前，应该使用语句“USE &lt;数据库 名&gt;”指定操作是在哪个数据库中进行，如果没有选择数据库，就会抛出“No database selected”的错误。</p><p><img src="/post/c24675b4/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220412092420575.png" alt="image-20220412092420575"></p><p>创建数据表的语句为CREATE TABLE，语法规则如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> TAB_NAME(</span><br><span class="line">字段<span class="number">1</span> 类型 约束 默认值,</span><br><span class="line">字段<span class="number">2</span> 类型 约束 默认值,</span><br><span class="line">字段n 类型 约束 默认值</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>使用CREATE TABLE创建表时，必须指定以下信息：<br>（1）要创建的表的名称，不区分大小写，不能使用SQL语言中的关键 字，如DROP、ALTER、INSERT 等。<br>（2）数据表中每一列（字段）的名称和数据类型，如果创建多列，就要用逗号隔开。<br>案例：创建员工表：employee</p><table><thead><tr><th><strong>字段名</strong></th><th><strong>数据类型</strong></th><th><strong>备注</strong></th></tr></thead><tbody><tr><td>emp_id</td><td>int</td><td>员工编号</td></tr><tr><td>emp_name</td><td>varchar(50)</td><td>员工名字</td></tr><tr><td>emp_sex</td><td>char(2)</td><td>员工性别</td></tr><tr><td>emp_salary</td><td>float</td><td>员工工资</td></tr><tr><td>emp_phone</td><td>varchar(50)</td><td>员工电话</td></tr><tr><td>emp_birth</td><td>date</td><td>员工生日</td></tr><tr><td>dept_id</td><td>int</td><td>所在部门</td></tr></tbody></table><p>创建表的sql语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employee(</span><br><span class="line">emp_id <span class="type">INT</span>,</span><br><span class="line">emp_name <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">emp_sex <span class="type">CHAR</span>(<span class="number">2</span>),</span><br><span class="line">emp_salary <span class="type">FLOAT</span>,</span><br><span class="line">emp_phone <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">emp_birth <span class="type">DATE</span>,</span><br><span class="line">dept_id <span class="type">INT</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><img src="/post/c24675b4/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220412092623208.png" alt="image-20220412092623208"></p><p>此时可以通过以下命令查看该库下的表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> TABLES;</span><br></pre></td></tr></table></figure><p><img src="/post/c24675b4/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220412092654756.png" alt="image-20220412092654756"></p><p>通过上图可以看到表中还有一些默认值，主键，非空等。这些都是属于表的约束。</p><h3 id="4-2-表约束"><a href="#4-2-表约束" class="headerlink" title="4.2 表约束"></a>4.2 表约束</h3><p><strong>1.数据完整性</strong></p><p>数据的完整性是指数据的可靠性和准确性<br>1.实体完整性：实体的完整性强制表的标识符列或主键的完整性(通过索引,唯一约束,主键约束或标识列属性).<br>2.域完整性：限制类型(数据类型),格式(通过检查约束和规则),可能值范围(通过外键约束,检查约束,默认值定义,非空约束和规则).<br>3.引用完整性：在删除和输入记录时,引用完整性保持表之间已定义的关系.引用完整性确保键值在所有表中一致.这样的一致辞性要求不能引用不存在的值.如果一个键值更改了,那么在整个数据库中,对该键值的引用要进行一致的更改.<br>4.自定义完整性：用户自己定义的业务规则.<br>四种完整性约束：</p><p>实体完整性：<em><strong>唯一约束、主键约束、标识列</strong></em> </p><p>域完完整性：<em><strong>限制数据类型、外键约束、默认值、非空约束</strong></em> </p><p>引用完整性：<em><strong>外键</strong></em><br>自定义完整性：过程，触发器等</p><p><strong>2.约束</strong><br>约束是在表上强制执行的一些数据校验规则，被插入、修改或删除的数据必须符合在相关字段上设置的这些约束条件。<br>五类完整性约束：<br>NOT NULL       非空<br>UNIQUE         唯一<br>PRIMARY KEY    主键 FOREIGN KEY    外键</p><p>AUTO_INCREMENT自增</p><p>CHECKED        检查(mysql不支持的)</p><h4 id="4-2-1-主键约束"><a href="#4-2-1-主键约束" class="headerlink" title="4.2.1 主键约束"></a>4.2.1 主键约束</h4><p>主键，又称主码，是表中一列或多列的组合。主键约束（Primary Key Constraint）要求主键列的数据唯一，并且不允许为空。主键能够唯一地标 识表中的一条记录，可以结合外键来定义不同数据表之间的关系，并且可以 加快数据库查询的速度。主键和记录之间的关系如同身份证和人之间的关 系，它们之间是一一对应的。主键分为两种类型：单字段主键和多字段联合主键。</p><h5 id="1-单子段主键"><a href="#1-单子段主键" class="headerlink" title="1.单子段主键"></a>1.单子段主键</h5><p>主键由一个字段组成，SQL语句格式分为以下两种情况。<br>1)定义列的同时指定主键，语法如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字段名 字段类型 <span class="keyword">primary</span> key</span><br></pre></td></tr></table></figure><p>如：创建部门表 dept，表结构如下</p><table><thead><tr><th><strong>字段名</strong></th><th><strong>数据类型</strong></th><th><strong>备注</strong></th></tr></thead><tbody><tr><td>deptid</td><td>int</td><td>部门编号 主键</td></tr><tr><td>dept_name</td><td>varchar(50)</td><td>部门名称</td></tr><tr><td>dept_desc</td><td>varchar(200)</td><td>部门描述</td></tr><tr><td>dept_num</td><td>int</td><td>部门人数</td></tr></tbody></table><p>sql语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> dept(</span><br><span class="line">deptid <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">dept_name <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">dept_desc <span class="type">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">dept_num <span class="type">INT</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><img src="/post/c24675b4/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220412093550305.png" alt="image-20220412093550305"></p><p>通过上图，我们还看到有个自增，自增是什么？<br>在数据库应用中，经常希望在每次插入新记录时，系统自动生成字段的 主键值。可以通过为表主键添加 AUTO_INCREMENT关键字来实现。默认 的，在MySQL中AUTO_INCREMENT的初始值是1，每新增一条<br>记录，字段 值自动加1。一个表只能有一个字段使用AUTO_INCREMENT约束，且该字 段必须为主键的一部分。AUTO_INCREMENT约束的字段可以是任何整数 类型（TINYINT、SMALLIN、INT、BIGINT 等）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> dept(</span><br><span class="line">deptid <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">dept_name <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">dept_desc <span class="type">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">dept_num <span class="type">INT</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><img src="/post/c24675b4/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220412093641022.png" alt="image-20220412093641022"></p><p>2)定义表之后指定主键 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span>主键名 <span class="keyword">PRIMARY</span> KEY(字段);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> employee <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> pk_empid <span class="keyword">PRIMARY</span> KEY(emp_id);</span><br></pre></td></tr></table></figure><p><img src="/post/c24675b4/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220412093722664.png" alt="image-20220412093722664"></p><h5 id="2-联合主键"><a href="#2-联合主键" class="headerlink" title="2.联合主键"></a>2.联合主键</h5><p>主键由多个字段联合组成，语法规则如下： </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">primary</span> key(字段<span class="number">1</span>,字段<span class="number">2</span>,...字段n)</span><br></pre></td></tr></table></figure><p>表关系详细讲解。<br>主键选取原则：</p><ol><li>   主键应当是对用户没有意义的。如果用户看到了一个表示多对多关系的连接表中的数据，并抱怨它没有什么用处，那就证明它的主键设计地很好。</li><li>   主键应该是单列的，以便提高连接和筛选操作的效率。</li><li>   永远也不要更新主键。实际上，因为主键除了惟一地标识一行之外，再没有其他的用途了，所以也就没有理由去对它更新。如果主键需要更新，则说明主键应对用户无意义的原则被违反了。</li><li>   主键不应包含动态变化的数据，如时间戳、创建时间列、修改时间列等。</li><li>   主键应当有计算机自动生成<br> 我们在建立数据库的时候，需要为每张表指定一个主键，所谓主键就是能够唯一标识表中某一行的属性或属性组，一个表只能有一个主键，但可以有多个候选索引。因为主键可以唯一标识某一行记录，所以可以确保执行数据更新、删除的时候不会出现张冠李戴的错误。当然，其它字段可以辅助我们在执行这些操作时消除共享冲突，不过就不在这里讨论了。主键除了上述作用外，常常与外键构成参照完整性约束，防止出现数据不一致。所以数据库在设计时，主键起到了很重要的作用。</li></ol><h4 id="4-2-2-非空约束"><a href="#4-2-2-非空约束" class="headerlink" title="4.2.2 非空约束"></a>4.2.2 非空约束</h4><p>非空约束（Not Null Constraint）指字段的值不能为空。对于使用了非空 约束的字段，如果用户在添加数据时没有指定值，数据库系统会报错。 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字段名 数据类型 <span class="keyword">not</span> <span class="keyword">null</span></span><br></pre></td></tr></table></figure><h4 id="4-2-3-唯一约束"><a href="#4-2-3-唯一约束" class="headerlink" title="4.2.3 唯一约束"></a>4.2.3 唯一约束</h4><p>唯一性约束（Unique Constraint）要求该列唯一，允许为空，但只能出 现一个空值。唯一约束可以确保一列或者几列不出现重复值。 唯一性约束的语法规则如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字段名 数据类型 <span class="keyword">UNIQUE</span></span><br></pre></td></tr></table></figure><p>如果定义完表后也可以给某个字段添加唯一约束，语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> 约束名 <span class="keyword">UNIQUE</span> (约束字段);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> employee <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> uk_phone <span class="keyword">UNIQUE</span> (emp_phone);</span><br></pre></td></tr></table></figure><p><img src="/post/c24675b4/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220412093937799.png" alt="image-20220412093937799"></p><p>删除唯一索引的语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">DROP</span> INDEX 约束名;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> employee <span class="keyword">DROP</span> INDEX uk_phone;</span><br></pre></td></tr></table></figure><h4 id="4-2-4-默认值约束"><a href="#4-2-4-默认值约束" class="headerlink" title="4.2.4 默认值约束"></a>4.2.4 默认值约束</h4><p>默认约束（Default Constraint）指定某列的默认值。如男性同学较多， 性别就可以默认为‘男’。如果插入一条新的记录时没有为这个字段赋值，那么系统会自动为这个字段赋值为‘男’。 默认约束的语法规则如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字段名 字段类型 <span class="keyword">default</span> 默认值</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employee(</span><br><span class="line">emp_id <span class="type">INT</span>,</span><br><span class="line">emp_name <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">emp_sex <span class="type">CHAR</span>(<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;男&#x27;</span>,</span><br><span class="line">emp_salary <span class="type">FLOAT</span>,</span><br><span class="line">emp_phone <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">UNIQUE</span> ,</span><br><span class="line">emp_birth <span class="type">DATE</span>,</span><br><span class="line">dept_id <span class="type">INT</span></span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/post/c24675b4/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220412094003699.png" alt="image-20220412094003699"></p><p><img src="/post/c24675b4/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220412094011095.png" alt="image-20220412094011095"></p><h4 id="4-2-5-外键约束"><a href="#4-2-5-外键约束" class="headerlink" title="4.2.5 外键约束"></a>4.2.5 外键约束</h4><p>外键用来在两个表的数据之间建立连接，可以是一列或者多列。一个表 可以有一个或多个外键。外键对应的是参照完整性，一个表的外键可以为空 值，若不为空值，则每一个外键值必须等于另一个表中主键的某个值。<br>外键：首先它是表中的一个字段，虽可以不是本表的主键，但要对应另 外一个表的主键。外键的主要作用是保证数据引用的完整性，定义外键后， 不允许删除在另一个表中具有关联关系的行。外键的作用是保持数据的一致 性、完整性。例如，部门表tb_dept的主键是id，在员工表tb_emp5中有一个键deptId与这个id关联。<br>主表（父表）：对于两个具有关联关系的表而言，相关联字段中主键所 在的那个表即是主表。</p><p>从表（子表）：对于两个具有关联关系的表而言，相关联字段中外键所 在的那个表即是从表。<br>语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 子表 <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> 约束名 <span class="keyword">FOREIGN</span> KEY (外键) <span class="keyword">REFERENCES</span> 主表(主键);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> employee <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> fk_emp_dept <span class="keyword">FOREIGN</span> KEY (dept_id)</span><br><span class="line"><span class="keyword">REFERENCES</span> dept(deptid);</span><br></pre></td></tr></table></figure><p><img src="/post/c24675b4/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220414112643882.png" alt="image-20220414112643882"></p><p>以上案例就是一个一对多的表关系。一个部门下有多个员工，一个员工从属一个部门。<br>常用的表关系【重点】有三种：一对一，一对多【自关联】，多对多</p><p>一对一：人与身份证</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">一对一</span></span><br><span class="line"><span class="comment">人 身份证</span></span><br><span class="line"><span class="comment">1    1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> person(</span><br><span class="line">pid <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">pname <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">pphone <span class="type">VARCHAR</span>(<span class="number">50</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> idcard(</span><br><span class="line">cid <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">cnum <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">cstart <span class="type">DATE</span>,</span><br><span class="line">cend <span class="type">DATE</span>,</span><br><span class="line">cpublish <span class="type">VARCHAR</span>(<span class="number">200</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> idcard <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> fk_card_person <span class="keyword">FOREIGN</span> KEY(cid) <span class="keyword">REFERENCES</span> person(pid);</span><br></pre></td></tr></table></figure><p>一对多：部门与员工</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.一对多</span></span><br><span class="line"><span class="comment">部门 员工</span></span><br><span class="line"><span class="comment">1 N</span></span><br><span class="line"><span class="comment">1 1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> department(</span><br><span class="line">departid <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">departname <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">departnum <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">departdesc <span class="type">VARCHAR</span>(<span class="number">200</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employee(</span><br><span class="line">empid <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">empname <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">empsex <span class="type">CHAR</span>(<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;男&#x27;</span>,</span><br><span class="line">empbirth <span class="type">DATE</span>,</span><br><span class="line">empphone <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">deptid <span class="type">INT</span> <span class="comment">-- FK</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">alter table tabname add constratin 约束名 foreign key(字段) references 主表</span></span><br><span class="line"><span class="comment">(主键);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> employee <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> fk_emp_dept <span class="keyword">FOREIGN</span> KEY(deptid) <span class="keyword">REFERENCES</span> department(departid);</span><br></pre></td></tr></table></figure><p>多对多：用户与角色【中间表多列主键】</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 多对多的关系</span></span><br><span class="line"><span class="comment">用户 角色</span></span><br><span class="line"><span class="comment">1 N</span></span><br><span class="line"><span class="comment">N 1</span></span><br><span class="line"><span class="comment">N N</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> users(</span><br><span class="line">uid <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">uname <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">UNIQUE</span>,</span><br><span class="line">upwd <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">ustatus <span class="type">INT</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> roles(</span><br><span class="line">rid <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">rname <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> userroles(</span><br><span class="line">uid <span class="type">INT</span> ,</span><br><span class="line">rid <span class="type">INT</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY(uid,rid)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> userroles <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> fk_ur_user <span class="keyword">FOREIGN</span> KEY(uid) <span class="keyword">REFERENCES</span> users(uid);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> userroles <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> fk_ur_role <span class="keyword">FOREIGN</span> KEY(rid) <span class="keyword">REFERENCES</span> roles(rid);</span><br></pre></td></tr></table></figure><p>自关联：省市</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> cities(</span><br><span class="line">cid <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">cname <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">pid <span class="type">INT</span> ,</span><br><span class="line"><span class="keyword">CONSTRAINT</span> fk_pro_ci <span class="keyword">FOREIGN</span> KEY(pid) <span class="keyword">REFERENCES</span> cities(cid)</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="4-2-6-查看表结构"><a href="#4-2-6-查看表结构" class="headerlink" title="4.2.6 查看表结构"></a>4.2.6 查看表结构</h4><p>DESCRIBE&#x2F;DESC语句可以查看表的字段信息，其中包括字段名、字段 数据类型、是否为主键、是否有默认值等。语法规则如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DESCRIBE</span> 表名;</span><br></pre></td></tr></table></figure><p>或者简写为</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DESC</span> 表名;</span><br></pre></td></tr></table></figure><p><img src="/post/c24675b4/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220414112718645.png" alt="image-20220414112718645"></p><p>其中，各个字段的含义分别解释如下<br>NULL：表示该列是否可以存储NULL值。<br>Key：表示该列是否已编制索引。PRI表示该列是表主键的一部分；<br>          UNI表示该列是UNIQUE索引的一部分；MUL表示在列中某个给定 值允许出现多次。<br>Default：表示该列是否有默认值，有的话指定值是多少。<br>Extra：表示可以获取的与给定列有关的附加信息，例如 AUTO_INCREMENT等。<br>查看表详细结构语句：<br>SHOW CREATE TABLE语句可以用来显示创建表时的CREATE TABLE 语句，语法格式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employee;</span><br></pre></td></tr></table></figure><p><img src="/post/c24675b4/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220414112729120.png" alt="image-20220414112729120"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `employee` (</span><br><span class="line">`emp_id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">`emp_name` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`emp_sex` <span class="type">char</span>(<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;男&#x27;</span>,</span><br><span class="line">`emp_salary` <span class="type">float</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`emp_phone` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`emp_birth` <span class="type">date</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`dept_id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`emp_id`),</span><br><span class="line"><span class="keyword">UNIQUE</span> KEY `emp_phone` (`emp_phone`),</span><br><span class="line">KEY `fk_emp_dept` (`dept_id`),</span><br><span class="line"><span class="keyword">CONSTRAINT</span> `fk_emp_dept` <span class="keyword">FOREIGN</span> KEY (`dept_id`) <span class="keyword">REFERENCES</span> `dept`</span><br><span class="line">    (`deptid`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8</span><br></pre></td></tr></table></figure><h4 id="4-2-7-修改表结构"><a href="#4-2-7-修改表结构" class="headerlink" title="4.2.7 修改表结构"></a>4.2.7 修改表结构</h4><p>修改表指的是修改数据库中已经存在的数据表的结构。MySQL使用 ALTER TABLE语句修改表。常用的修改表的操作有修改表名、修改字段数 据类型或字段名、增加和删除字段、修改字段的排列位置、更改表的存储引擎、删除表的外键约束等。本节将对和修改表有关的操作进行讲解。</p><ol><li><p>修改表名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="operator">&lt;</span>旧表名<span class="operator">&gt;</span> RENAME [<span class="keyword">TO</span>] <span class="operator">&lt;</span>新表名<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> employee RENAME <span class="keyword">TO</span> emp;</span><br></pre></td></tr></table></figure></li><li><p>修改字段的数据类型</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> MODIFY <span class="operator">&lt;</span>字段名<span class="operator">&gt;</span> <span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> emp MODIFY emp_name <span class="type">VARCHAR</span>(<span class="number">30</span>);</span><br></pre></td></tr></table></figure></li><li><p>修改字段名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> CHANGE <span class="operator">&lt;</span>旧字段名<span class="operator">&gt;</span> <span class="operator">&lt;</span>新字段名<span class="operator">&gt;</span> <span class="operator">&lt;</span>新数据类型<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> emp CHANGE dept_id deptid <span class="type">INT</span>;</span><br></pre></td></tr></table></figure></li><li><p>添加字段</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> <span class="keyword">ADD</span> <span class="operator">&lt;</span>新字段名<span class="operator">&gt;</span> <span class="operator">&lt;</span>新字段类型<span class="operator">&gt;</span> <span class="operator">&lt;</span>约束条件<span class="operator">&gt;</span> [<span class="keyword">FIRST</span><span class="operator">|</span>AFTER 已存在字段名];</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> emp <span class="keyword">ADD</span> empaddr <span class="type">VARCHAR</span>(<span class="number">20</span>);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> emp <span class="keyword">ADD</span> empaddr <span class="type">VARCHAR</span>(<span class="number">20</span>) AFTER empsex;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> emp <span class="keyword">ADD</span> empnum <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">FIRST</span>;</span><br></pre></td></tr></table></figure></li></ol><p>比如条件null</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tabname <span class="keyword">ADD</span> column1 <span class="type">VARCHAR</span>(<span class="number">12</span>) <span class="keyword">not</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><ol start="5"><li><p>删除字段</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> <span class="keyword">DROP</span> <span class="operator">&lt;</span>字段名<span class="operator">&gt;</span> ;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> emp <span class="keyword">DROP</span> empno;</span><br></pre></td></tr></table></figure></li><li><p>修改字段的排序位置</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> MODIFY <span class="operator">&lt;</span>字段<span class="number">1</span><span class="operator">&gt;</span> <span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span> <span class="keyword">FIRST</span><span class="operator">|</span>AFTER <span class="operator">&lt;</span>字段<span class="number">2</span><span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> emp MODIFY deptid <span class="type">INT</span> AFTER empphone;</span><br></pre></td></tr></table></figure></li><li><p>删除表的外键约束</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> <span class="keyword">DROP</span> <span class="keyword">FOREIGN</span> KEY <span class="operator">&lt;</span>外键约束名<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> emp <span class="keyword">DROP</span> <span class="keyword">FOREIGN</span> KEY fk_emp_dept;</span><br></pre></td></tr></table></figure></li><li><p>更改表的存储引擎</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> ENGINE<span class="operator">=</span><span class="operator">&lt;</span>更改后的存储引擎名<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tb_deptment3 ENGINE<span class="operator">=</span>MyISAM;</span><br></pre></td></tr></table></figure></li><li><p>删除数据表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> [IF <span class="keyword">EXISTS</span>]表<span class="number">1</span>, 表<span class="number">2</span>,…表n;</span><br></pre></td></tr></table></figure></li></ol><h3 id="练习：-1"><a href="#练习：-1" class="headerlink" title="练习："></a>练习：</h3><p><strong>练习一：</strong></p><ol><li><p>创建数据库company,在库中创建两个表offices和employees表 offices表结构：</p><p><img src="/post/c24675b4/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220414112940650.png" alt="image-20220414112940650"></p><p>employees表结构</p><p><img src="/post/c24675b4/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220414112949528.png" alt="image-20220414112949528"></p></li><li><p>查看该库下几个表以及查看两张表结构。</p></li><li><p>将表employees的mobile字段修改到officeCode字段后面。 </p></li><li><p>将表employees的birth字段改名为employee_birth。 </p></li><li><p>修改sex字段，数据类型为CHAR(1)，非空约束。 </p></li><li><p>删除字段note。 </p></li><li><p>增加字段名favoriate_activity，数据类型为VARCHAR(100)。 </p></li><li><p>删除表offices。</p></li><li><p>将表employees名称修改为employees_info。</p></li></ol><p><strong>练习二：</strong></p><p>创建数据库Market，在Market中创建数据表customers</p><p><img src="/post/c24675b4/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220414112959552.png" alt="image-20220414112959552"></p><ol><li><p>创建数据表customers，在c_num字段上添加主键约束和自增约 束，在c_birth字段上添加非空约束。</p></li><li><p>将c_contact字段插入c_birth字段后面。 </p></li><li><p>将c_name字段数据类型改为VARCHAR(70)。 </p></li><li><p>将c_contact字段改名为c_phone。</p></li><li><p>增加c_gender字段，数据类型为CHAR(1)。 </p></li><li><p>将表名修改为customers_info。</p></li><li><p>删除字段c_city。 </p></li><li><p>修改数据表的存储引擎为MyISAM。 </p></li><li><p>在Market中创建数据表orders。</p><p><img src="/post/c24675b4/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220414113033879.png" alt="image-20220414113033879"></p></li><li><p>创建数据表orders，在o_num字段上添加主键约束和自增约束，在 c_id字段上添加外键约束，关联customers表中的主键c_num。 </p></li><li><p>删除orders表的外键约束，然后删除表customers。</p></li></ol><p><strong>练习三：</strong></p><p>1.创建数据库MySchool </p><p>2.创建以下数据表<br>1&gt; 班级表：Grade表</p><p><img src="/post/c24675b4/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220414113044620.png" alt="image-20220414113044620"></p><p>2&gt; 学生表： Student表</p><p><img src="/post/c24675b4/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220414113051379.png" alt="image-20220414113051379"></p><p>3&gt; 科目表：Subjects表</p><p><img src="/post/c24675b4/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220414113056556.png" alt="image-20220414113056556"></p><p>4&gt; 成绩表：Result表</p><p><img src="/post/c24675b4/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220414113103096.png" alt="image-20220414113103096"></p><p>5&gt; 表关系：</p><p><img src="/post/c24675b4/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220414113112365.png" alt="image-20220414113112365"></p><p><strong>建表的时候，如果选择数据类型</strong></p><ol><li><p><strong>整数和浮点数</strong><br>如果不需要小数部分，就使用整数来保存数据；如果需要表示小数部分，就使用浮点数类型。对于浮点数据列，存入的数值会对该列定义的小数位进行四舍五入。例如，假设列的值的范围为1~99999，若使用整数，则 MEDIUMINT UNSIGNED是 好的类型；若需要存储小数，则使用FLOAT 类型<br>浮点类型包括FLOAT和DOUBLE类型。DOUBLE类型精度比FLOAT类型高，因此要求存储精度较高时应选择DOUBLE类型</p></li><li><p><strong>浮点数和定点数浮点数</strong></p><p>FLOAT、DOUBLE相对于定点数DECIMAL的优势是：在长度一定的情况下，浮点数能表示更大的数据范围。由于浮点数容易产生误差，因 此对精确度要求比较高时，建议使用DECIMAL来存储。DECIMAL在MySQL中是以字符串存储的，用于定义货币等对精确度要求较高的数据。 在数据迁移中，float(M,D)是非标准SQL定义，数据库迁移可能会出现问题， 好不要这样使用。另外，两个浮点数进行减法和比较运算时也容易出 问题，因此在进行计算的时候，一定要小心。进行数值比较时， 好使用DECIMAL类型</p></li><li><p><strong>日期与时间类型</strong><br>MySQL对于不同种类的日期和时间有很多数据类型，比如YEAR和TIME。如果只需要记录年份，则使用YEAR类型即可；如果只记录时间，则使用TIME类型。<br>如果同时需要记录日期和时间，则可以使用TIMESTAMP或者DATETIME类型。由于 TIMESTAMP列的取值范围小于DATETIME的取值范围，因此存储范围较大的日期 好使用DATETIME。<br>TIMESTAMP也有一个DATETIME不具备的属性。默认的情况下，当插入一条记录但并没有指定TIMESTAMP这个列值时，MySQL会把TIMESTAMP列设为当前的时间。因此当需要插入记录的同时插入当前时间时，使用TIMESTAMP是方便的。另外，TIMESTAMP在空间上比 DATETIME更有效。 </p></li><li><p><strong>CHAR</strong>与<strong>VARCHAR</strong>之间的特点与选择<br>CHAR和VARCHAR的区别如下<br>CHAR是固定长度字符，VARCHAR是可变长度字符。<br>CHAR会自动补空格，VARCHAR不自动补。<br>CHAR是固定长度，所以它的处理速度比VARCHAR的速度要快，但是它的缺点是浪费存储空间，所以对存储不大但在速度上有要求的可以使用CHAR类型，反之可以使用 VARCHAR类型来实现。</p></li></ol><h2 id="五、数据CRUD操作"><a href="#五、数据CRUD操作" class="headerlink" title="五、数据CRUD操作"></a>五、数据CRUD操作</h2><h3 id="1、插入数据"><a href="#1、插入数据" class="headerlink" title="1、插入数据"></a>1、插入数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名 <span class="keyword">VALUES</span>(val_list);</span><br><span class="line">或</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名(col_list) <span class="keyword">VALUES</span>(val_list);</span><br></pre></td></tr></table></figure><p>可以插入多条记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名(col_list) <span class="keyword">VALUES</span>(val_list1),(val_list2),(val_list3),(val_list4);</span><br></pre></td></tr></table></figure><p>备份数据表</p><p>如果表不存在，此时</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp_bak <span class="keyword">AS</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp;</span><br></pre></td></tr></table></figure><p>如果表存在，此时</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp_bak <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp;</span><br></pre></td></tr></table></figure><h3 id="2、更新数据"><a href="#2、更新数据" class="headerlink" title="2、更新数据"></a>2、更新数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> table_name <span class="keyword">SET</span> col<span class="operator">=</span>val,col<span class="operator">=</span>val [<span class="keyword">WHERE</span> <span class="operator">&lt;</span><span class="keyword">condition</span><span class="operator">&gt;</span>];</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> emp <span class="keyword">SET</span> empname<span class="operator">=</span><span class="string">&#x27;jerry&#x27;</span>,empaddr<span class="operator">=</span><span class="string">&#x27;延安&#x27;</span>,empphone<span class="operator">=</span><span class="string">&#x27;118&#x27;</span> <span class="keyword">WHERE</span> empid<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><h3 id="3、删除数据"><a href="#3、删除数据" class="headerlink" title="3、删除数据"></a>3、删除数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> table_name [<span class="keyword">WHERE</span> <span class="operator">&lt;</span><span class="keyword">condition</span><span class="operator">&gt;</span>];</span><br></pre></td></tr></table></figure><p>如果删除语句没where,此时会将数据表中的记录全部删除，类似TRUNCATE TABLE.</p><p> TRUNCATE将直接删除原来的表，并重新创建一个表，其语法结构为 TRUNCATE TABLE table_name。        </p><p>TRUNCATE直接删除表而不是删除记录，因此执行速度比DELETE快。而且不能用在有主外键关系的主表中。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql为什么不建议<span class="keyword">delete</span>数据?</span><br><span class="line"><span class="keyword">delete</span>对性能会有影响，一般不建议硬性<span class="keyword">delete</span>数据，而是标记deleted <span class="operator">=</span> <span class="number">1</span>这种软删除</span><br><span class="line">为啥呢？</span><br><span class="line">根据之前了解的mysql底层存储原理 小存储单元page页，无论是非叶子节点page存的是索引key和指针，还是叶子节点存的是行数据.</span><br><span class="line"><span class="number">1.</span>当删除大量数据时</span><br><span class="line">MySQL内部不会真正删除空间，而且做标记删除，即将delflag:N修改为delflag:Y，<span class="keyword">commit</span>之后会会被purge进入删除链表，如果下一次<span class="keyword">insert</span>更大的记录，<span class="keyword">delete</span>之后的空间不会被重用，如果插入的记录小于等于<span class="keyword">delete</span>的记录空会被重用</span><br><span class="line"><span class="number">2.</span>当少量删除中间数据时</span><br><span class="line">你在中间删了某些个值，实际上只是找到那个page页找到对应的数据做删除标记，并不会实际影响page 页已经占的大小，这块空间可能也永远不会被利用，产生了内存碎片导致索引频繁分裂，影响<span class="keyword">SQL</span>执行计划的稳定性</span><br><span class="line">正确姿势：</span><br><span class="line">使用deleted <span class="operator">=</span> <span class="number">1</span> 字段来软删除，保证索引连续性，</span><br><span class="line">必要时，可将deleted <span class="operator">=</span> <span class="number">0</span>的字段完整迁移到新表，解决碎片问题</span><br></pre></td></tr></table></figure><h3 id="4、查询数据"><a href="#4、查询数据" class="headerlink" title="4、查询数据"></a>4、查询数据</h3><p><img src="/post/c24675b4/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220414113358996.png" alt="image-20220414113358996"></p><p>MySQL从数据表中查询数据的基本语句为SELECT语句。SELECT语句的基本格式是：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="keyword">SELECT</span>  字段列表   <span class="keyword">FROM</span>  表<span class="number">1</span>,表<span class="number">2.</span>.. <span class="keyword">WHERE</span> 表达式   <span class="keyword">GROUP</span> <span class="keyword">BY</span>  字段   <span class="keyword">HAVING</span> 条件  </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> 字段 LIMIT   [<span class="operator">&lt;</span><span class="keyword">offset</span><span class="operator">&gt;</span>,] <span class="operator">&lt;</span><span class="type">row</span> count<span class="operator">&gt;</span>]</span><br></pre></td></tr></table></figure><p> {* | &lt;字段列表&gt;}包含星号通配符和字段列表，表示查询的字段。其中，字段列表至少包含一个字段名称，如果要查询多个字段，多个字段之间用逗号隔开， 后一个字段后不加逗号。<br> FROM &lt;表1&gt;,&lt;表2&gt;…，表1和表2表示查询数据的来源，可以是单个或者多个。<br>WHERE子句是可选项，如果选择该项，将限定查询行必须满足的查询条件。<br>GROUP BY &lt;字段&gt;，该子句告诉MySQL如何显示查询出来的数据，并按照指定的字段分组。<br>[ORDER BY &lt;字段&gt;]，该子句告诉MySQL按什么样的顺序显示查询出来的数据，可以进行的排序有升序<br>（ASC）、降序（DESC）。<br>[LIMIT [,] ]，该子句告诉MySQL每次显示查询 出来的数据条数。 </p><h4 id="单表查询："><a href="#单表查询：" class="headerlink" title="单表查询："></a>单表查询：</h4><p><strong>1&gt; 查询所有字段</strong> </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名;</span><br></pre></td></tr></table></figure><p><strong>2&gt; 查询指定字段</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 列名 <span class="keyword">FROM</span> 表名;</span><br></pre></td></tr></table></figure><p><strong>3&gt; 查询多个字段</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段名<span class="number">1</span>,字段名<span class="number">2</span>,…,字段名n <span class="keyword">FROM</span> 表名;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> empid,empname,empsex,empaddr,empbirth,empphone,deptid <span class="keyword">FROM</span> emp;</span><br></pre></td></tr></table></figure><p>查询的时候可以起别名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e.`empid` <span class="keyword">AS</span> 员工编号 ,e.`empname` <span class="keyword">AS</span> 员工名字 <span class="keyword">FROM</span> emp e;</span><br></pre></td></tr></table></figure><p><strong>4&gt; 查询指定记录</strong><br>数据库中包含大量的数据，根据特殊要求，可能只需要查询表中的指定数据，即对数据进行过滤。在<br>SELECT语句中，通过WHERE子句可以对数 据进行过滤，语法格式为： </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段名<span class="number">1</span>,字段名<span class="number">2</span>,…,字段名n <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 查询条件</span><br></pre></td></tr></table></figure><p>如：查询性别为女的员工信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> empsex<span class="operator">=</span><span class="string">&#x27;女&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>5&gt;带IN关键字的查询</strong><br>N操作符用来查询满足指定范围内的条件的记录，使用IN操作符，将所有检索条件用括号括起来，检索条件之间用逗号分隔开，只要满足条件范围内的一个值即为匹配项。<br>在IN关键字前面加上了NOT关键字，这使得查询的结果与前面一个的结果正好相反，</p><p>如：查询编号为 1 4 8 10 的员工信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> empid<span class="operator">=</span><span class="number">1</span> <span class="keyword">OR</span> empid<span class="operator">=</span><span class="number">4</span> <span class="keyword">OR</span> empid<span class="operator">=</span><span class="number">8</span> <span class="keyword">OR</span> empid<span class="operator">=</span><span class="number">10</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> empid <span class="keyword">IN</span> (<span class="number">1</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">10</span>);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> empid <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="number">1</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p><strong>6&gt;带BETWEEN AND的范围查询</strong><br>BETWEEN AND用来查询某个范围内的值，该操作符需要两个参数,即范围的开始值和结束值，如果字段值满足指定的范围查询条件，则这些记录被返回。<br>BETWEEN  AND操作符前可以加关键字NOT，表示指定范围之外的 值，如果字段值不满足指定的范围内的值，则这些记录被返回。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> empid<span class="operator">&gt;=</span><span class="number">6</span> <span class="keyword">AND</span> empid<span class="operator">&lt;=</span><span class="number">10</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> empid <span class="keyword">BETWEEN</span> <span class="number">6</span> <span class="keyword">AND</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><strong>7&gt;带LIKE的字符匹配查询</strong><br>通配符是一种在SQL的WHERE条件子句中拥有特殊意思的字符。SQL 语句中支持多种通配符，可以和<br>LIKE一起使用的通配符有‘%’和‘_’。 </p><ol><li><p>百分号通配符‘%’，匹配任意长度的字符，甚至包括零字符</p></li><li><p>下划线通配符‘_’，一次只能匹配任意一个字符 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> empname <span class="keyword">LIKE</span> <span class="string">&#x27;a%&#x27;</span>; <span class="comment">-- 以a开头</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> empname <span class="keyword">LIKE</span> <span class="string">&#x27;%a&#x27;</span>; <span class="comment">-- 以a结尾</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> empname <span class="keyword">LIKE</span> <span class="string">&#x27;%a%&#x27;</span>; <span class="comment">-- 包含a</span></span><br></pre></td></tr></table></figure><p>名字是两个字母的而且是a开头的</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> empname <span class="keyword">LIKE</span> <span class="string">&#x27;a_&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> empaddr <span class="keyword">IN</span> (<span class="string">&#x27;西安&#x27;</span>,<span class="string">&#x27;武当山&#x27;</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> empaddr <span class="operator">=</span><span class="string">&#x27;西安&#x27;</span> <span class="keyword">OR</span> empaddr <span class="operator">=</span> <span class="string">&#x27;武当山&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> empaddr <span class="keyword">LIKE</span> <span class="string">&#x27;西安%&#x27;</span>;</span><br></pre></td></tr></table></figure></li></ol><p><strong>8&gt;查询空值</strong><br>数据表创建的时候，设计者可以指定某列中是否包含空值（NULL）在SELECT语句中使用IS NULL子句，可以查询某字段内容为空记录。与IS NULL相反的是NOT NULL，该关键字查找字段不为空的记录。</p><p>空的查询 查询地址为空的员工信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> empaddr <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> empaddr <span class="operator">=</span><span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> empaddr <span class="keyword">IS</span> <span class="keyword">NULL</span> <span class="keyword">OR</span> empaddr<span class="operator">=</span><span class="string">&#x27;&#x27;</span>;</span><br></pre></td></tr></table></figure><p>非空查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> empaddr <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> empaddr <span class="operator">!=</span><span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> empaddr <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">AND</span> empaddr<span class="operator">!=</span><span class="string">&#x27;&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>9&gt;带AND的多条件查询</strong><br>MySQL在WHERE子句中使用AND操作符限定只有满足所有查询条件的记录才会被返回。可以使用AND 连接两个甚至多个查询条件，多个条件表达式之间用AND分开</p><p>如：查询性别为男同时地址是西安锦业路</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> empsex<span class="operator">=</span><span class="string">&#x27;男&#x27;</span> <span class="keyword">AND</span> empaddr<span class="operator">=</span><span class="string">&#x27;西安锦业路&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>10&gt;带OR的多条件查询</strong><br>与AND相反，在WHERE声明中使用OR操作符，表示只需要满足其中一个条件的记录即可返回。OR也可以连接两个甚至多个查询条件，多个条件表达式之间用OR分开</p><p><strong>11&gt;查询结果不重复</strong></p><p>在SELECT语句中，可以使用DISTINCT关键字指示MySQL消除重复的记录值。 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> empid,empname,empsex <span class="keyword">FROM</span> emp;</span><br></pre></td></tr></table></figure><p><strong>12&gt;对查询结果排序</strong><br>使用ORDER BY子句对指定的列数据进行排序。 desc:倒叙  asc:默认值，升序</p><ol><li><p>单列排序 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">ORDER</span> <span class="keyword">BY</span> empid <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure></li><li><p>多列排序</p></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">ORDER</span> <span class="keyword">BY</span> empid <span class="keyword">DESC</span> ,deptid <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><p><strong>13&gt;聚合函数</strong><br>有时候并不需要返回实际表中的数据，而只是对数据进行总结。 MySQL提供一些查询功能，可以对获取的数据进行分析和报告。这些函数 的功能有：计算数据表中记录行数的总数、计算某个字段列下数据的<br>总和， 以及计算表中某个字段下的 大值、 小值或者平均值。常用的聚合函数 MAX()、MIN()、<br>COUNT()、SUM()、AVG()。</p><table><thead><tr><th><strong>函数</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td>AVG()</td><td>返回某列的平均值</td></tr><tr><td>COUNT()</td><td>返回某列的行数</td></tr><tr><td>MAX()</td><td>返回某列的 大值</td></tr><tr><td>MIN()</td><td>返回某列的 小值</td></tr><tr><td>SUM()</td><td>返回某列值的和</td></tr></tbody></table><p>1）COUNT()函数统计数据表中包含的记录行的总数，或者根据查询结果 返回列中包含的数据行数。其使用方法有两种： </p><p>​       COUNT(*)计算表中总的行数，不管某列是否有数值或者为空值。</p><p>​       COUNT(字段名)计算指定列下总的行数，计算时将忽略空值的行。<br>2）SUM()是一个求总和的函数，返回指定列值的总和。 SUM()函数在计算时，忽略列值为NULL的行。<br>3）AVG()函数通过计算返回的行数和每一行数据的和，求得指定列数据的平均值。<br>4）MAX()函数返回指定列中的 大值。<br>MAX()函数除了用来找出 大的列值或日期值之外，还可以返回任意列 中的 大值，包括返回字符类型<br>的 大值。在对字符类型数据进行比较 时，按照字符的ASCII码值大小进行比较，从a~z，a的ASCII码小，z的 大。在比较时，先比较第一个字母，如果相等，继续比较下一个字符，一直到两个字符不相等或者字符结束为止。例如，‘b’与‘t’比较时，‘t’为 大值；“bcd”与“bca”比较时，“bcd”为 大值。<br>5）MIN()函数与MAX()函数类似，不仅适用于查找数值类型，也可应用于字符类型。<br><strong>14&gt;分组查询</strong><br>GROUP  BY关键字通常和集合函数一起使用</p><p>查询每个部门的人数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> deptid,<span class="built_in">COUNT</span>(<span class="number">1</span>) <span class="keyword">FROM</span> emp <span class="keyword">GROUP</span> <span class="keyword">BY</span> deptid;</span><br></pre></td></tr></table></figure><p>统计每个部门的男女人数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> deptid,empsex,<span class="built_in">COUNT</span>(<span class="number">1</span>) <span class="keyword">FROM</span> emp <span class="keyword">GROUP</span> <span class="keyword">BY</span> deptid,empsex;</span><br></pre></td></tr></table></figure><p>分组后再排序</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> deptid,empsex,<span class="built_in">COUNT</span>(<span class="number">1</span>) <span class="keyword">FROM</span> emp <span class="keyword">GROUP</span> <span class="keyword">BY</span> deptid,empsex <span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">deptid <span class="keyword">DESC</span>,<span class="built_in">COUNT</span>(<span class="number">1</span>) <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><p><strong>15&gt;使用HAVING过滤分组</strong><br>GROUP BY可以和HAVING一起限定显示记录所需满足的条件，只有满 足条件的分组才会被显示对于统计的每个部门的男女人数只要大于等于3的信息 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> deptid,empsex,<span class="built_in">COUNT</span>(<span class="number">1</span>) <span class="keyword">FROM</span> emp <span class="keyword">GROUP</span> <span class="keyword">BY</span> deptid,empsex <span class="keyword">HAVING</span></span><br><span class="line"><span class="built_in">COUNT</span>(<span class="number">1</span>)<span class="operator">&gt;=</span><span class="number">3</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="built_in">COUNT</span>(<span class="number">1</span>) <span class="keyword">DESC</span>,deptid <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><p><strong>16&gt;LIMIT</strong><br>SELECT返回所有匹配的行，有可能是表中所有的行，若仅仅需要返回 第一行或者前几行，可使用LIMIT 关键字。</p><h3 id="练习：数据修改与删除"><a href="#练习：数据修改与删除" class="headerlink" title="练习：数据修改与删除"></a>练习：数据修改与删除</h3><ol><li>   将地址是西安市的更新为 西安科技二路</li><li>   将S1001的email修改为空的字符串</li><li>   将第二门课的名字更新为 java基础，课时为60 ，班级是二年级</li><li>   将S1001 ，课程编号为 2 的成绩 提高 5分</li><li>   将 S1004 ,课程编号为3 的成绩更新为60，考试时间更新为 2015-10-10</li><li>   经核实 S1004 课程编号为2 的 缺考</li><li>   将计算机网络课程删除掉</li></ol><p>数据查询【部分函数后面章节介绍，学习完毕后继续完成】：<br>1、查询全部一年级的学生信息。<br>2、查询全部二年级的学生的姓名和电话。<br>3、查询全部一年级女同学的信息。<br>4、查询课时超过60的科目信息。<br>5、查询二年级的科目名称<br>6、查询二年级男同学的姓名和住址。<br>7、查询无电子邮件的学生姓名和年级信息。<br>8、查询出生日期在1992年之后的男学生姓名和年级信息。<br>9、参加了日期为2015年7月3日的“计算机基本原理”科目考试的成绩信息<br>10、按照出生日期查询一年级的学生信息。<br>11、按成绩由高到低的次序查询参加编号为1的科目考试信息。<br>12、查询2015年7月1日参加“MySQL深入”考试的前2名学员成绩信息。<br>13、查询课时 多的科目名称及课时。<br>14、查询年龄 小的学生所在的年级及姓名。<br>15、查询考试的 低分出现在哪个科目<br>16、查询学号为“s1001”的学生参加过的所有考试信息，并按照时间前后次序显示。<br>17、查询年龄超过25周岁的学生信息。<br>18、查询1月份过生日的学生信息<br>19、查询今天过生日的学生姓名及所在年级。<br>20、新生入学，为其分配一个Email地址，规则如下：S1+当前日期 <a href="mailto:&#x2b;&#64;&#x62;&#100;&#x2e;&#99;&#111;&#109;">&#x2b;&#64;&#x62;&#100;&#x2e;&#99;&#111;&#109;</a><br>21、查询住址为“雁塔区”的学生姓名、电话、住址<br>22、查询名称中含有“计算机”字样科目名称、学时及所属年级，并按年级由低到高显示。<br>23、查询电话中含有以“130”开头的学生姓名，住址和电话。<br>24、查询姓“赵”的学号、姓名和住址。<br>25、统计一年级女生的总人数。<br>26、查询李四总成绩<br>27、学号为s1003的学生所有课总成绩<br>28、学号为s1003的学生考试的平均分。<br>29、查询一年级的科目“Mysql”的 高分、 低分、平均分。<br>30、查询每个年级的总学时数，并按照升序排列。<br>31、查询每个参加考试的学员的平均分。（Group by 学号）<br>32、查询每门课程的平均分，并按照降序排列。（group by 课程）<br>33、查询每个学生参加的所有考试的总分，并按照降序排列。（group by 学号）<br>34、查询一年级的平均年龄。<br>35、查询每个年级西安地区的学生人数。<br>36、查询参加考试的学生中，平均分及格的学生记录，并按照平均成绩降序排列<br>37、查询参加考试至少一次考试不及格的学生学号、姓名、不及格次数。<br>38、查询学生姓名、所属年级名称及联系电话。<br>39、查询年级编号为1的科目名称、年级名称及学时。<br>40、查询参加科目编号为1的考试的学生姓名、分数、考试日期。<br>41、查询学号为s1001的学生参加的考试科目名称、分数、考试日期。<br>42、查询所有科目的参考信息（某些科目可能还没有被考试过）<br>43、查询没有被考过的科目信息。</p><h2 id="六、连接查询和子查询"><a href="#六、连接查询和子查询" class="headerlink" title="六、连接查询和子查询"></a>六、连接查询和子查询</h2><h3 id="6-1-链接查询"><a href="#6-1-链接查询" class="headerlink" title="6.1 链接查询"></a>6.1 链接查询</h3><p>连接是关系数据库模型的主要特点。连接查询是关系数据库中 主要的查询，主要包括内连接、外连接等。通过连接运算符可以实现多个表查询。 在关系数据库管理系统中，表建立时各数据之间的关系不必确定，常把一个实体的所有信息存放在一个表中。当查询数据时，通过连接操作查询出存放在多个表中的不同实体的信息。当两个或多个表中存在相同意义的字段时，便可以通过这些字段对不同的表进行连接查询。本节将介绍多表之间的内连接查询、外连接查询以及复合条件连接查询.</p><h4 id="1-内连接查询"><a href="#1-内连接查询" class="headerlink" title="1.内连接查询"></a>1.内连接查询</h4><p>内连接（INNER JOIN）使用比较运算符进行表间某（些）列数据的比较操作，并列出这些表中与连接条件相匹配的数据行，组合成新的记录，也就是说，在内连接查询中，只有满足条件的记录才能出现在结果关系中。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> dept d <span class="keyword">INNER</span> <span class="keyword">JOIN</span> emp e <span class="keyword">ON</span> d.`deptid`<span class="operator">=</span>e.`deptid`;</span><br></pre></td></tr></table></figure><h4 id="2-外连接查询"><a href="#2-外连接查询" class="headerlink" title="2.外连接查询"></a>2.外连接查询</h4><p><strong>左外连接</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> dept <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> emp <span class="keyword">ON</span> dept.`deptid`<span class="operator">=</span>emp.`deptid`</span><br></pre></td></tr></table></figure><p><strong>右外连接</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> dept.<span class="operator">*</span>,emp.<span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> dept <span class="keyword">ON</span> dept.`deptid`<span class="operator">=</span>emp.`deptid`</span><br></pre></td></tr></table></figure><h3 id="6-2-子查询"><a href="#6-2-子查询" class="headerlink" title="6.2 子查询"></a>6.2 子查询</h3><h4 id="1-子查询"><a href="#1-子查询" class="headerlink" title="1)子查询"></a>1)子查询</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询员工信息，并展示员工所在的部门名字</span></span><br><span class="line"><span class="keyword">SELECT</span> emp.<span class="operator">*</span>, (<span class="keyword">SELECT</span> deptname <span class="keyword">FROM</span> dept <span class="keyword">WHERE</span></span><br><span class="line">dept.`deptid`<span class="operator">=</span>emp.`deptid`)deptname</span><br><span class="line"><span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> emp.`deptid` <span class="keyword">IN</span> (<span class="keyword">SELECT</span> deptid <span class="keyword">FROM</span> dept)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询用户锁拥有的角色</span></span><br><span class="line"><span class="keyword">SELECT</span> ur.<span class="operator">*</span>,</span><br><span class="line">(<span class="keyword">SELECT</span> users.`uname` <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> users.`uid`<span class="operator">=</span>ur.`uid`) uname,</span><br><span class="line">(<span class="keyword">SELECT</span> roles.`rname` <span class="keyword">FROM</span> roles <span class="keyword">WHERE</span> roles.`rid`<span class="operator">=</span>ur.`rid`) rname</span><br><span class="line"><span class="keyword">FROM</span> userroles ur</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询成绩最高的学生信息</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> xueshenbiao <span class="keyword">WHERE</span> xuehao <span class="keyword">IN</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">SELECT</span> xuehao <span class="keyword">FROM</span> 成绩表 <span class="keyword">WHERE</span> 成绩</span><br><span class="line"><span class="operator">=</span>(<span class="keyword">SELECT</span> <span class="built_in">MAX</span>(chengji) <span class="keyword">FROM</span> 成绩表)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询考试没有及格的学生信息</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> xueshengbiao <span class="keyword">WHERE</span> xuehao <span class="keyword">IN</span> (</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> xuehao <span class="keyword">FROM</span> 成绩表 <span class="keyword">WHERE</span> chengji<span class="operator">&lt;</span><span class="number">60</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询两门课以上不及格的学生信息</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> xuesb <span class="keyword">WHERE</span> xuhao <span class="keyword">IN</span>(<span class="keyword">SELECT</span> xh <span class="keyword">FROM</span> chengjibao <span class="keyword">WHERE</span> cj<span class="operator">&lt;</span><span class="number">60</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> xh <span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="number">1</span>)<span class="operator">&gt;</span><span class="number">1</span>) ;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询平均分低于总平均的记录</span></span><br><span class="line"><span class="keyword">SELECT</span> studentno,<span class="built_in">AVG</span>(studentresult)</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">result</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> studentno <span class="keyword">HAVING</span></span><br><span class="line"><span class="built_in">AVG</span>(studentresult)<span class="operator">&lt;</span></span><br><span class="line">(<span class="keyword">SELECT</span> <span class="built_in">AVG</span>(studentresult) <span class="keyword">FROM</span> <span class="keyword">result</span>);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询所有科目中成绩最低的学生信息</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> studentno <span class="keyword">IN</span></span><br><span class="line">(<span class="keyword">SELECT</span> studentno <span class="keyword">FROM</span> <span class="keyword">result</span> <span class="keyword">WHERE</span> studentresult <span class="operator">=</span></span><br><span class="line">(<span class="keyword">SELECT</span> <span class="built_in">MIN</span>(studentresult) <span class="keyword">FROM</span> <span class="keyword">result</span>) );</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询成绩高于所有科目平均分的学生信息</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> studentno <span class="keyword">IN</span> (</span><br><span class="line"><span class="keyword">SELECT</span> studentno <span class="keyword">FROM</span> <span class="keyword">result</span> a,</span><br><span class="line">(<span class="keyword">SELECT</span> <span class="built_in">AVG</span>(studentresult) avgscore ,subjectid <span class="keyword">FROM</span> <span class="keyword">result</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">subjectid)b</span><br><span class="line"><span class="keyword">WHERE</span> a.`subjectid`<span class="operator">=</span>b.subjectid <span class="keyword">AND</span> a.`studentresult`<span class="operator">&gt;</span>b.avgscore);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询成绩比张三的语文成绩还低的学生信息</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> studentno <span class="keyword">IN</span>(</span><br><span class="line"><span class="keyword">SELECT</span> studentno <span class="keyword">FROM</span> <span class="keyword">result</span> <span class="keyword">WHERE</span> studentresult <span class="operator">&lt;</span>(</span><br><span class="line"><span class="keyword">SELECT</span> studentresult <span class="keyword">FROM</span> <span class="keyword">result</span> <span class="keyword">WHERE</span> studentno<span class="operator">=</span></span><br><span class="line">(<span class="keyword">SELECT</span> studentno <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> studentname<span class="operator">=</span><span class="string">&#x27;张三&#x27;</span>)</span><br><span class="line"><span class="keyword">AND</span> subjectid <span class="operator">=</span> (<span class="keyword">SELECT</span> subjectid <span class="keyword">FROM</span> subjects <span class="keyword">WHERE</span> subjectname<span class="operator">=</span><span class="string">&#x27;语文&#x27;</span>);</span><br><span class="line">)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="2-any-some"><a href="#2-any-some" class="headerlink" title="2)any,some"></a>2)any,some</h4><p>ANY和SOME关键字是同义词，表示满足其中任一条件，它们允许创建一个表达式对子查询的返回值列表进行比较，只要满足内层子查询中的任何一个比较条件，就返回一个结果作为外层查询的条件。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">table</span> tbl1 ( num1 <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>); <span class="keyword">CREATE</span> <span class="keyword">table</span> tbl2 ( num2 <span class="type">INT</span> <span class="keyword">NOT</span></span><br><span class="line"><span class="keyword">NULL</span>);</span><br></pre></td></tr></table></figure><p> 有两个表tb1与tb2,数据如下</p><p><img src="/post/c24675b4/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220414113631173.png" alt="image-20220414113631173"></p><p><img src="/post/c24675b4/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220414113638228.png" alt="image-20220414113638228"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> num1 <span class="keyword">FROM</span> tb1 <span class="keyword">WHERE</span> num1<span class="operator">&gt;</span> <span class="keyword">ANY</span>(<span class="keyword">SELECT</span> num2 <span class="keyword">FROM</span> tb2);</span><br><span class="line"><span class="comment">-- 或</span></span><br><span class="line"><span class="keyword">SELECT</span> num1 <span class="keyword">FROM</span> tb1 <span class="keyword">WHERE</span> num1<span class="operator">&gt;</span> <span class="keyword">SOME</span>(<span class="keyword">SELECT</span> num2 <span class="keyword">FROM</span> tb2);</span><br></pre></td></tr></table></figure><p><img src="/post/c24675b4/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220414113646094.png" alt="image-20220414113646094"></p><p>ANY关键字接在一个比较操作符的后面，表示若与子查询返回的任何值比较为TRUE，则返回 TRUE。<br>将tbl1中的num1列的值与之进行比较，只要大于num2列的任意一个数即为符合条件的结果。 </p><h4 id="3-All"><a href="#3-All" class="headerlink" title="3)All"></a>3)All</h4><p>ALL关键字接在一个比较操作符的后面，表示与子查询返回的所有值比较为TRUE，则返回TRUE。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> num1 <span class="keyword">FROM</span> tb1 <span class="keyword">WHERE</span> num1<span class="operator">&gt;</span> <span class="keyword">ALL</span>(<span class="keyword">SELECT</span> num2 <span class="keyword">FROM</span> tb2);</span><br></pre></td></tr></table></figure><p><img src="/post/c24675b4/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220414113703426.png" alt="image-20220414113703426"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 找到工资比人事部工资高的信息</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> sal <span class="operator">&gt;</span> <span class="keyword">ALL</span> (<span class="keyword">SELECT</span> sal <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> emp.deptid<span class="operator">=</span></span><br><span class="line">(<span class="keyword">SELECT</span> deptid <span class="keyword">FROM</span> dept <span class="keyword">WHERE</span> deptname<span class="operator">=</span><span class="string">&#x27;人事部&#x27;</span>)) ;</span><br></pre></td></tr></table></figure><h4 id="4-EXISTS"><a href="#4-EXISTS" class="headerlink" title="4)EXISTS"></a>4)EXISTS</h4><p>EXISTS关键字后面的参数是一个任意的子查询，系统对子查询进行运算以判断它是否返回行，如果至少返回一行，那么EXISTS的结果为true，此时外层查询语句将进行查询；如果子查询没有返回任何行，那么EXISTS返<br>回的结果是false，此时外层语句将不进行查询。 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tb1 <span class="keyword">WHERE</span> <span class="keyword">EXISTS</span></span><br><span class="line">(<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tb2 <span class="keyword">WHERE</span> num2<span class="operator">&gt;</span><span class="number">10</span>) <span class="keyword">AND</span> num1<span class="operator">&gt;</span><span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><img src="/post/c24675b4/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220414113721969.png" alt="image-20220414113721969"></p><p>如果 SELECT * FROM tb2 WHERE num2&gt;10 有返回结果，则执行外部查询，此时会查询tb1表，并且要过来num1的值大于10的。如果将num2大于100的没有结果，则外部查询不执行。</p><p><img src="/post/c24675b4/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220414113734372.png" alt="image-20220414113734372"></p><p>NOT EXISTS 与 EXISTS相反</p><p><img src="/post/c24675b4/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220414113742384.png" alt="image-20220414113742384"></p><h4 id="5-UNION"><a href="#5-UNION" class="headerlink" title="5)UNION"></a>5)UNION</h4><p>创建tb1与tb2，并插入数据</p><p> <img src="/post/c24675b4/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220414113749342.png" alt="image-20220414113749342"></p><p> <img src="/post/c24675b4/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220414113754679.png" alt="image-20220414113754679"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tb1</span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tb2;</span><br></pre></td></tr></table></figure><p><img src="/post/c24675b4/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220414113804318.png" alt="image-20220414113804318"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tb1</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tb2;</span><br></pre></td></tr></table></figure><p><img src="/post/c24675b4/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220414113811886.png" alt="image-20220414113811886"></p><h4 id="6-正则查询"><a href="#6-正则查询" class="headerlink" title="6)正则查询"></a>6)正则查询</h4><p>正则表达式通常被用来检索或替换那些符合某个模式的文本内容，根据 指定的匹配模式匹配文本中符合要求的特殊字符串。例如，从一个文本文件 中提取电话号码，查找一篇文章中重复的单词或者替换用户输入的某些敏感词语等，这些地方都可以使用正则表达式。正则表达式强大而且灵活，可以应用于非常复杂的查询。 <img src="/post/c24675b4/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220414113821605.png" alt="image-20220414113821605"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 以字母a开头</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> first_name REGEXP <span class="string">&#x27;^a&#x27;</span>;</span><br><span class="line"><span class="comment">-- $结尾</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> first_name REGEXP <span class="string">&#x27;a$&#x27;</span>;</span><br><span class="line"><span class="comment">-- b中间是任意字符c b与c之间得有一个任意字符，</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> first_name REGEXP <span class="string">&#x27;b.c&#x27;</span>;</span><br><span class="line"><span class="comment">-- +b必须得出现到n次</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> first_name REGEXP <span class="string">&#x27;b+c&#x27;</span>;</span><br><span class="line"><span class="comment">-- * 必须得0到n次</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> first_name REGEXP <span class="string">&#x27;b*c&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> first_name REGEXP <span class="string">&#x27;b&#123;2,&#125;c&#x27;</span>;</span><br><span class="line"><span class="comment">-- &#123;2,5&#125; 2到5次</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> first_name REGEXP <span class="string">&#x27;b&#123;2,4&#125;c&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="练习：-2"><a href="#练习：-2" class="headerlink" title="练习："></a>练习：</h3><p>创建数据表：employee表</p><p><img src="/post/c24675b4/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220414140203343.png" alt="image-20220414140203343"></p><p>创建部门表 dept</p><p><img src="/post/c24675b4/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220414140212757.png" alt="image-20220414140212757"></p><p>输入记录： employee表</p><p><img src="/post/c24675b4/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220414140222992.png" alt="image-20220414140222992"></p><p>部门表中的记录</p><p><img src="/post/c24675b4/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220414140249160.png" alt="image-20220414140249160"></p><p>  查询练习：</p><ol><li>查询所有记录的e_no、e_name和e_salary字段值</li><li>查询dept_no等于10和20的所有记录</li><li>查询工资范围在800~2500之间的员工信息</li><li>查询部门编号为20的部门中的员工信息</li><li>查询每个部门 高工资的员工信息</li><li>查询员工BLAKE所在部门和部门所在地</li><li>查询所有员工的部门和部门信息</li><li>计算每个部门各有多少名员工</li><li>计算不同类型职工的总工资数</li><li>计算不同部门的平均工资</li><li>查询工资低于1500的员工信息</li><li>将查询记录先按部门编号由高到低排列，再按员工工资由高到低排列</li><li>查询员工姓名以字母‘A’或‘S’开头的员工的信息</li><li>查询到目前为止工龄大于等于18年的员工信息</li><li>计算所有女员工（‘F’）的年龄</li><li>使用LIMIT查询从第3条记录开始到第6条记录的结果</li><li>查询销售人员（SALSEMAN）的 低工资</li><li>查询名字以字母N或者S结尾的记录</li><li>查询在BeiJing工作的员工的姓名和职务</li><li>使用左连接方式查询employee和dept表</li><li>查询所有2001~2005年入职的员工的信息，查询部门编号为20和30的员工信息并使用UNION合并两个查询结果</li><li>使用LIKE查询员工姓名中包含字母a的记录</li><li>使用REGEXP查询员工姓名中包含T、C或者M这3个字母中任意1个的记录</li></ol><h2 id="七、系统函数"><a href="#七、系统函数" class="headerlink" title="七、系统函数"></a>七、系统函数</h2><p>MySQL中的函数包括数学函数、字符串函数、日期和时间函数、条件判断函数、系统信息函数和加密函数等其他函数</p><h3 id="7-1-数学函数"><a href="#7-1-数学函数" class="headerlink" title="7.1 数学函数"></a>7.1 数学函数</h3><ol><li><p>绝对值函数<strong>ABS(x)<strong>和返回圆周率的函数</strong>PI()</strong> </p></li><li><p>平方根函数<strong>SQRT(x)<strong>和求余函数</strong>MOD(x,y)</strong> </p></li><li><p>获取整数的函数<strong>CEIL(x)<strong>、</strong>CEILING(x)<strong>和</strong>FLOOR(x)</strong> </p><p>CEIL(x)和CEILING(x)的意义相同，返回不小于x的 小整数值，返回 值转化为一个BIGINT。 </p><p>FLOOR(x)返回不大于x的 大整数值，返回值转化为一个BIGINT。 </p></li><li><p>获取随机数的函数<strong>RAND()<strong>和</strong>RAND(x)</strong> </p><p>RAND(x)返回一个随机浮点值v，范围在0到1之间（0 ≤ v ≤ 1.0）。若已指定一个整数参数x，则它被用作种子值，用来产生重复列。 </p></li><li><p>函数<strong>ROUND(x)<strong>、</strong>ROUND(x,y)<strong>和</strong>TRUNCATE(x,y)</strong></p></li></ol><p>   ROUND(x)返回 接近于参数x的整数，对x值进行四舍五入。 </p><p>   ROUND(x,y)返回 接近于参数x的数，其值保留到小数点后面y位，若y为负值，则将保留x值到小数点左边y位。 </p><p>   TRUNCATE(x,y)返回被舍去至小数点后y位的数字x。若y的值为0，则结果不带有小数点或不带有小数部分。若y设为负数，则截（归零）x小数点左起第y位开始后面所有低位的值。 </p><ol start="6"><li><p>符号函数<strong>SIGN(x)</strong> </p><p>SIGN(x)返回参数的符号，x的值为负、零或正时返回结果依次为-1、0或1。</p></li><li><p>幂运算函数<strong>POW(x,y)<strong>、</strong>POWER(x,y)<strong>和</strong>EXP(x)</strong> </p><p>POW(x,y)或者POWER(x,y)函数返回x的y次乘方的结果值。 EXP(x)返回e的x乘方后的值。</p></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ROUND(<span class="built_in">AVG</span>(empid),<span class="number">1</span>) <span class="keyword">FROM</span> emp;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">TRUNCATE</span>(<span class="built_in">AVG</span>(empid),<span class="number">1</span>) <span class="keyword">FROM</span> emp;</span><br></pre></td></tr></table></figure><h3 id="7-2-字符串函数"><a href="#7-2-字符串函数" class="headerlink" title="7.2 字符串函数"></a>7.2 字符串函数</h3><ol><li><p>计算字符串字符数的函数和字符串长度的函数 </p><p>CHAR_LENGTH(str)返回值为字符串str所包含的字符个数。一个多字节字符算作一个单字符。 </p></li><li><p>合并字符串函数**CONCAT(s1,s2,…)**、 CONCAT_WS(x,s1,s2,…)</p></li><li><p>替换字符串的函数<strong>INSERT(s1,x,len,s2)</strong> </p></li><li><p>字母大小写转换函数 LOWER (str)或者LCASE (str)可以将字符串str中的字母字符全部转换成 小写字母。 UPPER(str)或者UCASE(str可以将字符串str中的字母字符全部转换成大写字母。 </p></li><li><p>获取指定长度的字符串的函数<strong>LEFT(s,n)<strong>和</strong>RIGHT(s,n)</strong> </p></li><li><p>填充字符串的函数<strong>LPAD(s1,len,s2)<strong>和</strong>RP</strong> </p></li><li><p>删除空格的函数<strong>LTRIM(s)、RTRIM(s)<strong>和</strong>TRIM(s)</strong> </p></li><li><p>重复生成字符串的函数<strong>REPEAT(s,n)</strong> </p></li><li><p>空格函数**SPACE(n)<strong>和替换函数</strong>REPLACE(s,s1,s2)**SPACE(n)返回一个由n个空格组成的字符串。  </p></li><li><p>比较字符串大小的函数<strong>STRCMP(s1,s2)</strong> </p></li><li><p>获取子串的函数<strong>SUBSTRING(s,n,len)<strong>和</strong>MID(s,n,len)</strong> </p></li><li><p>匹配子串开始位置的函数 </p><p>LOCATE(str1,str)、POSITION(str1 IN str)和INSTR(str, str1)3个函数的作 </p></li><li><p>字符串逆序的函数<strong>REVERSE(s)</strong> </p><p>REVERSE(s)将字符串s反转，返回的字符串的顺序和s字符串顺序相 反。</p></li><li><p>返回指定字符串位置的函数<strong>FIELD(s,s1,s2,…,sn)</strong> </p><p>FIELD(s,s1,s2,…,sn)返回字符串s在列表s1,s2,…,sn中第一次出现的位置，在找不到s的情况下，返回值为0。如果s为NULL，则返回值为0，原因 是NULL不能同任何值进行同等比较。 </p></li><li><p>返回子串位置的函数<strong>FIND_IN_SET(s1,s2)</strong> </p><p>FIND_IN_SET(s1,s2)返回字符串s1在字符串列表s2中出现的位置，字符串列表是一个由多个逗号‘,’分开的字符串组成的列表。如果s1不在s2或s2为空字符串，则返回值为0。如果任意一个参数为 NULL，则返回值为NULL。 这个函数在第一个参数包含一个逗号‘,’时将无法正常运行。</p></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CHAR_LENGTH</span>(<span class="string">&#x27;helloworld&#x27;</span>);</span><br><span class="line"><span class="comment">-- 字符串拼接</span></span><br><span class="line"><span class="keyword">SELECT</span> CONCAT(<span class="string">&#x27;hello&#x27;</span>,<span class="string">&#x27;-&#x27;</span>,<span class="string">&#x27;world&#x27;</span>,<span class="string">&#x27;-&#x27;</span>,<span class="string">&#x27;你好&#x27;</span>);</span><br><span class="line"><span class="comment">-- 以*来拼接后面的字符串</span></span><br><span class="line"><span class="keyword">SELECT</span> CONCAT_WS(<span class="string">&#x27;*&#x27;</span>,<span class="string">&#x27;hello&#x27;</span>,<span class="string">&#x27;world&#x27;</span>,<span class="string">&#x27;你好&#x27;</span>);</span><br><span class="line"><span class="comment">-- 查找hello,再后面的字符串列表中的位置 从 1 开始</span></span><br><span class="line"><span class="keyword">SELECT</span> FIELD(<span class="string">&#x27;hello&#x27;</span>,<span class="string">&#x27;你好&#x27;</span>,<span class="string">&#x27;延安&#x27;</span>,<span class="string">&#x27;helloworld&#x27;</span>);</span><br><span class="line"><span class="keyword">SELECT</span> FIND_IN_SET(<span class="string">&#x27;hello&#x27;</span>,<span class="string">&#x27;你好,延安,hello,world&#x27;</span>);</span><br><span class="line"><span class="keyword">SELECT</span> empid,empname,empsex <span class="keyword">FROM</span> emp;</span><br><span class="line"><span class="keyword">SELECT</span> CONCAT_WS(<span class="string">&#x27;-&#x27;</span>,empid,empname,empsex) <span class="keyword">FROM</span> emp;</span><br><span class="line"><span class="keyword">SELECT</span> FORMAT(&quot;256998.855&quot;,<span class="number">1</span>);</span><br><span class="line"><span class="comment">-- 从第6个开始4个长度替换为ab</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">INSERT</span>(<span class="string">&#x27;helloworld&#x27;</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="string">&#x27;ab&#x27;</span>);</span><br><span class="line"><span class="comment">-- 检索world再helloworld中出现的位置</span></span><br><span class="line"><span class="keyword">SELECT</span> LOCATE(<span class="string">&#x27;world&#x27;</span>,<span class="string">&#x27;helloworld&#x27;</span>);</span><br><span class="line"><span class="comment">-- 从左边截取</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">LEFT</span>(<span class="string">&#x27;helloworld&#x27;</span>,<span class="number">8</span>);</span><br><span class="line"><span class="comment">-- 从右边截取</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">RIGHT</span>(<span class="string">&#x27;helloworld&#x27;</span>,<span class="number">8</span>);</span><br><span class="line"><span class="comment">-- 从第6个位置开始截取到最后</span></span><br><span class="line"><span class="keyword">SELECT</span> SUBSTR(<span class="string">&#x27;helloworld&#x27;</span>,<span class="number">6</span>);</span><br><span class="line"><span class="comment">-- 从第6个位置开始截取三个长度</span></span><br><span class="line"><span class="keyword">SELECT</span> SUBSTR(<span class="string">&#x27;helloworld&#x27;</span>,<span class="number">6</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure><h4 id="练习：-3"><a href="#练习：-3" class="headerlink" title="练习："></a>练习：</h4><p>已知表中保存一下记录 5-602   12-1203    5-1303  12-608 请按照单元和门牌号排序<br>1）创建表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> sales(</span><br><span class="line">sid <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">snum <span class="type">VARCHAR</span>(<span class="number">50</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>2）插入记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> sales <span class="keyword">VALUE</span>(<span class="keyword">NULL</span>,<span class="string">&#x27;5-602&#x27;</span>),(<span class="keyword">NULL</span>,<span class="string">&#x27;12-1203&#x27;</span>),(<span class="keyword">NULL</span>,<span class="string">&#x27;5-1303&#x27;</span>),</span><br><span class="line">(<span class="keyword">NULL</span>,<span class="string">&#x27;12-608&#x27;</span>),(<span class="keyword">NULL</span>,<span class="string">&#x27;15-1602&#x27;</span>),(<span class="keyword">NULL</span>,<span class="string">&#x27;5-802&#x27;</span>),(<span class="keyword">NULL</span>,<span class="string">&#x27;20-1602&#x27;</span>);</span><br></pre></td></tr></table></figure><p>3） 实现查询的sql</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> LOCATE(<span class="string">&#x27;-&#x27;</span>,snum) <span class="keyword">FROM</span> sales;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">LEFT</span>(snum,LOCATE(<span class="string">&#x27;-&#x27;</span>,snum)<span class="number">-1</span>) <span class="keyword">FROM</span> sales;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CHAR_LENGTH</span>(snum)<span class="operator">-</span>LOCATE(<span class="string">&#x27;-&#x27;</span>,snum) <span class="keyword">FROM</span> sales;</span><br><span class="line"><span class="keyword">SELECT</span> snum,</span><br><span class="line"><span class="keyword">LEFT</span>(snum,LOCATE(<span class="string">&#x27;-&#x27;</span>,snum)<span class="number">-1</span>),</span><br><span class="line"><span class="keyword">RIGHT</span>(snum,<span class="keyword">CHAR_LENGTH</span>(snum)<span class="operator">-</span>LOCATE(<span class="string">&#x27;-&#x27;</span>,snum)) <span class="keyword">FROM</span> sales;</span><br><span class="line"><span class="comment">-- 排序</span></span><br><span class="line"><span class="keyword">SELECT</span> snum <span class="keyword">FROM</span> sales <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">CONVERT</span>(<span class="keyword">LEFT</span>(snum,LOCATE(<span class="string">&#x27;-</span></span><br><span class="line"><span class="string">&#x27;</span>,snum)<span class="number">-1</span>),SIGNED),</span><br><span class="line"><span class="keyword">CONVERT</span>(<span class="keyword">RIGHT</span>(snum,<span class="keyword">CHAR_LENGTH</span>(snum)<span class="operator">-</span>LOCATE(<span class="string">&#x27;-&#x27;</span>,snum)) ,SIGNED);</span><br><span class="line"><span class="comment">-- 日期类型</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CONVERT</span>(<span class="string">&#x27;2000-8-9&#x27;</span>,<span class="type">DATE</span>);</span><br><span class="line"><span class="comment">-- 转为正数signed</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CONVERT</span>(<span class="string">&#x27;1000&#x27;</span>,SIGNED);</span><br></pre></td></tr></table></figure><h3 id="7-3-日期和时间函数"><a href="#7-3-日期和时间函数" class="headerlink" title="7.3 日期和时间函数"></a>7.3 日期和时间函数</h3><p>1.系统当前时间</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> NOW();</span><br><span class="line"><span class="keyword">SELECT</span> SYSDATE();</span><br><span class="line"><span class="keyword">SELECT</span> CURDATE(); <span class="comment">-- 年月日</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">CURRENT_DATE</span>(); <span class="comment">-- 年月日</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">CURRENT_TIME</span>; <span class="comment">-- 时分秒</span></span><br><span class="line"><span class="keyword">SELECT</span> CURTIME(); <span class="comment">-- 时分秒</span></span><br></pre></td></tr></table></figure><p>2.addXXX()加上</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- adddate()加上天数</span></span><br><span class="line"><span class="keyword">SELECT</span> ADDDATE(NOW(),<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> ADDDATE(<span class="string">&#x27;2020-10-19 12:32:45&#x27;</span>,<span class="type">INTERVAL</span> <span class="number">5</span> <span class="keyword">MINUTE</span>); <span class="comment">-- 5 分钟</span></span><br><span class="line"><span class="keyword">SELECT</span> ADDDATE(<span class="string">&#x27;2020-10-19 12:32:45&#x27;</span>,<span class="number">5</span>); <span class="comment">-- 5 天</span></span><br><span class="line"><span class="keyword">SELECT</span> ADDDATE(<span class="string">&#x27;2020-10-19 12:32:45&#x27;</span>,<span class="type">INTERVAL</span> <span class="number">5</span> <span class="keyword">YEAR</span>); <span class="comment">-- 5 年</span></span><br><span class="line"><span class="keyword">SELECT</span> ADDDATE(<span class="string">&#x27;2020-10-19 12:32:45&#x27;</span>,<span class="type">INTERVAL</span> <span class="number">5</span> <span class="keyword">MONTH</span>); <span class="comment">-- 5 个月</span></span><br><span class="line"><span class="comment">-- 加上秒,最大到59</span></span><br><span class="line"><span class="keyword">SELECT</span> ADDTIME(NOW(),<span class="number">59</span>),NOW();</span><br></pre></td></tr></table></figure><p>3.DATEDIFF() 两个时间相差天数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DATEDIFF(NOW(),<span class="string">&#x27;2020-5-8&#x27;</span>);</span><br></pre></td></tr></table></figure><p>4.DATE_FORMAT 日期格式化</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DATE_FORMAT(NOW(),<span class="string">&#x27;%Y年%m月%d日 %H点%i分%s秒&#x27;</span>)</span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>简写</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>%a</td><td>缩写星期名</td></tr><tr><td>%b</td><td>缩写月名</td></tr><tr><td>%c</td><td>月，数值</td></tr><tr><td>%D</td><td>带有英文前缀的月中的天</td></tr><tr><td>%d</td><td>月的天，数值(00-31)</td></tr><tr><td>%e</td><td>月的天，数值(0-31)</td></tr><tr><td>%f</td><td>微秒</td></tr><tr><td>%H</td><td>小时  (00-23)</td></tr><tr><td>%h</td><td>小时  (01-12)</td></tr><tr><td>%I</td><td>小时  (01-12)</td></tr><tr><td>%i</td><td>分钟，数值(00-59)</td></tr><tr><td>%j</td><td>年的天  (001-366)</td></tr><tr><td>%k</td><td>小时  (0-23)</td></tr><tr><td>%l</td><td>小时  (1-12)</td></tr><tr><td>%M</td><td>月名</td></tr><tr><td>%m</td><td>月，数值(00-12)</td></tr><tr><td>%p</td><td>AM  或 PM</td></tr><tr><td>%r</td><td>时间，12-小时（hh:mm:ss  AM 或 PM）</td></tr><tr><td>%S</td><td>秒(00-59)</td></tr><tr><td>%s</td><td>秒(00-59)</td></tr><tr><td>%T</td><td>时间,  24-小时 (hh:mm:ss)</td></tr><tr><td>%U</td><td>周  (00-53) 星期日是一周的第一天</td></tr><tr><td>%u</td><td>周  (00-53) 星期一是一周的第一天</td></tr><tr><td>%V</td><td>周  (01-53) 星期日是一周的第一天，与 %X 使用</td></tr><tr><td>%v</td><td>周  (01-53) 星期一是一周的第一天，与 %x 使用</td></tr><tr><td>%W</td><td>星期名</td></tr><tr><td>%w</td><td>周的天 （0&#x3D;星期日,  6&#x3D;星期六）</td></tr><tr><td>%X</td><td>年，其中的星期日是周的第一天，4 位，与  %V 使用</td></tr><tr><td>%x</td><td>年，其中的星期一是周的第一天，4 位，与  %v 使用</td></tr><tr><td>%Y</td><td>年，4 位</td></tr><tr><td>%y</td><td>年，2 位</td></tr></tbody></table><ol start="5"><li><p>DATE_SUB(date,INTERVAL expr type) 减去多少天</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DATE_SUB(NOW(),<span class="type">INTERVAL</span> <span class="number">45</span> <span class="keyword">DAY</span>);</span><br><span class="line"><span class="keyword">SELECT</span> DATE_SUB(NOW(),<span class="type">INTERVAL</span> <span class="number">3</span> <span class="keyword">YEAR</span>);</span><br><span class="line"><span class="keyword">SELECT</span> DATE_SUB(NOW(),<span class="type">INTERVAL</span> <span class="number">3</span> <span class="keyword">MONTH</span>);</span><br></pre></td></tr></table></figure></li><li><p>EXTRACT<br>EXTRACT(type FROM date)函数所使用的时间间隔类型说明符与DATE_ADD()或DATE_SUB()的相同，但它从日期中提取一部分，而不是执行日期运算</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">EXTRACT</span>(<span class="keyword">DAY</span> <span class="keyword">FROM</span> NOW()) ;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">EXTRACT</span>(<span class="keyword">YEAR</span> <span class="keyword">FROM</span> NOW()) ;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">EXTRACT</span>(<span class="keyword">MONTH</span> <span class="keyword">FROM</span> NOW()) ;</span><br></pre></td></tr></table></figure></li><li><p>MONTH(),MONTHNAME() 获取月份函数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MONTH</span>(NOW()); <span class="comment">-- 获取月份数字</span></span><br><span class="line"><span class="keyword">SELECT</span> MONTHNAME(NOW()); <span class="comment">-- 获取月份 英文</span></span><br></pre></td></tr></table></figure></li></ol><ol start="8"><li><p>   DAYNAME(d)、DAYOFWEEK(d)和WEEKDAY(d)<br>  DAYNAME(d)函数返回d对应的工作日的英文名称，例如Sunday、 Monday等<br>  DAYOFWEEK(d)函数返回d对应的一周中的索引（位置，1表示周日，2表示周一，…，7表示周六）。<br>  WEEKDAY(d)返回d对应的工作日索引：0表示周一，1表示周二，…，6表示周日。</p></li><li><p>   WEEK(d)和WEEKOFYEAR(d)<br>  WEEK(d)计算日期d是一年中的第几周WEEK()的双参数形式允许指定该星期是否起始于周日或周一，以及返回值的范围是否为0<del>53或1</del>53。 若Mode参数被省略，则使用default_week_format 系统自变量的值.</p><p>  WEEKOFYEAR(d)计算某天位于一年中的第几周，范围是1~53，相当于WEEK(d,3)。</p></li></ol><p><img src="/post/c24675b4/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220417155324333.png" alt="image-20220417155324333"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> WEEK(NOW()),WEEK(NOW(),<span class="number">0</span>),WEEK(NOW(),<span class="number">1</span>),WEEK(NOW(),<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>​10.DAYOFYEAR(d)和DAYOFMONTH(d)<br>​     DAYOFYEAR(d)函数返回d是一年中的第几天，范围是1<del>366。<br>​     DAYOFMONTH(d)函数返回d是一个月中的第几天，范围是1</del>31。<br>​11.YEAR(),QUARTER(),MINUTE(),SECOND()<br>​     YEAR(date)返回date对应的年份，范围是1970<del>2069.<br>        QUARTER(date)返回date对应的一年中的季度值，范围是1</del>4。<br>        MINUTE(time)返回time对应的分钟数，范围是0<del>59。<br>        SECOND(time)返回time对应的秒数，范围是0</del>59。</p><p>练习：<br>1&gt;  求今天过生日的学生信息<br>2&gt; 本周过生日的学生信息<br>3&gt; 统计本年每个季度的消费总金额</p><h3 id="7-4条件判断函数"><a href="#7-4条件判断函数" class="headerlink" title="7.4条件判断函数"></a>7.4条件判断函数</h3><ol><li><p>IF(expr,v1,v2)函数<br>IF(expr, v1, v2)：如果表达式expr是TRUE(expr &lt;&gt; 0 and expr &lt;&gt; NULL)，则返回值为v1；否则返回值为v2.IF()的返回值为数字值或字符串值，具体情况视其所在语境而定。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> salary, IF(salary<span class="operator">&gt;</span><span class="number">20000</span>,<span class="string">&#x27;高工资&#x27;</span>,<span class="string">&#x27;低工资&#x27;</span>) <span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure></li><li><p>IFNULL(v1,v2)函数<br>IFNULL(v1,v2)：假如v1不为NULL，则IFNULL()的返回值为v1；否则其返回值为v2。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> manager_id,IFNULL(manager_id,<span class="string">&#x27;无上级领导&#x27;</span>) <span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure></li><li><p>CASE函数<br>CASE expr WHEN v1 THEN r1 [WHEN v2 THEN r2]…[ELSE rn+1] END：如果expr值等于某个vn，则返回对应位置THEN后面的结果；如果与所有值都不相等，则返回ELSE后面的rn+1。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> salary,</span><br><span class="line"><span class="keyword">CASE</span> salary <span class="keyword">WHEN</span> <span class="number">24000</span> <span class="keyword">THEN</span> <span class="string">&#x27;高工资&#x27;</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="number">17000</span> <span class="keyword">THEN</span> <span class="string">&#x27;基本工资&#x27;</span></span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br><span class="line"><span class="keyword">SELECT</span> job_id,</span><br><span class="line"><span class="keyword">CASE</span> job_id <span class="keyword">WHEN</span> <span class="string">&#x27;AD_PRES&#x27;</span> <span class="keyword">THEN</span> <span class="string">&#x27;CEO&#x27;</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">&#x27;AD_VP&#x27;</span> <span class="keyword">THEN</span> <span class="string">&#x27;经理&#x27;</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">&#x27;IT_PROG&#x27;</span> <span class="keyword">THEN</span> <span class="string">&#x27;IT&#x27;</span></span><br><span class="line"><span class="keyword">ELSE</span> <span class="string">&#x27;基本工种&#x27;</span></span><br><span class="line"><span class="keyword">END</span> jobtype</span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure></li></ol><h3 id="7-5系统信息函数"><a href="#7-5系统信息函数" class="headerlink" title="7.5系统信息函数"></a>7.5系统信息函数</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> VERSION(); <span class="comment">-- 版本</span></span><br><span class="line"><span class="keyword">SELECT</span> CONNECTION_ID(); <span class="comment">-- 查看当前用户的链接数</span></span><br><span class="line"><span class="comment">-- 查看链接的详细信息</span></span><br><span class="line"><span class="keyword">SHOW</span> PROCESSLIST; <span class="comment">-- 前100条</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">FULL</span> PROCESSLIST; <span class="comment">-- 所有信息</span></span><br></pre></td></tr></table></figure><p><img src="/post/c24675b4/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220417155440581.png" alt="image-20220417155440581"></p><ol><li>   Id列，用户登录MySQL时，系统分配的是“connection id”。 </li><li>   User列，显示当前用户。如果不是root，这个命令就只显示用户权限范围内的SQL语句。</li><li>   Host列，显示这个语句是从哪个IP的哪个端口上发出的，可以用来追踪出现问题语句的用户。 </li><li>   db列，显示这个进程目前连接的是哪个数据库。 </li><li>   Command列，显示当前连接执行的命令，一般取值为休眠 （Sleep）、查询（Query）、连接（Connect）。 </li><li>   Time列，显示这个状态持续的时间，单位是秒。 </li><li>   State列，显示使用当前连接的SQL语句的状态，很重要的列。后续会有所有状态的描述， State只是语句执行中的某一个状态一个SQL语 句，以查询为例，可能需要经过Copying to tmp table、Sorting result、 Sending data等状态才可以完成。 </li><li>   Info列，显示这个SQL语句，是判断问题语句的一个重要依据。</li></ol><h3 id="7-6-获取用户名函数"><a href="#7-6-获取用户名函数" class="headerlink" title="7.6 获取用户名函数"></a>7.6 获取用户名函数</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">USER</span>(),<span class="built_in">CURRENT_USER</span>(),<span class="built_in">SYSTEM_USER</span>(),<span class="built_in">SESSION_USER</span>();</span><br></pre></td></tr></table></figure><p><img src="/post/c24675b4/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220414141044709.png" alt="image-20220414141044709"></p><h3 id="7-7-获取最后一个自动生成的ID的值函数"><a href="#7-7-获取最后一个自动生成的ID的值函数" class="headerlink" title="7.7 获取最后一个自动生成的ID的值函数"></a>7.7 获取最后一个自动生成的ID的值函数</h3><p>LAST_INSERT_ID()函数返回 后生成的AUTO_INCREMENT值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> LAST_INSERT_ID()</span><br></pre></td></tr></table></figure><p>在向数 据表中插入一条新记录时，LAST_INSERT_ID()返回带有 AUTO_INCREMENT约束的字段<br>新生成的值；使用一条INSERT语句插入多行时，LAST_INSERT_ID()只返回插的第一行数据时产生的值之所以这样，是因为这 使依靠其他服务器复制同样的INSERT语句变得简单。 </p><h3 id="7-8其他函数"><a href="#7-8其他函数" class="headerlink" title="7.8其他函数"></a>7.8其他函数</h3><p>格式化函数FORMAT(x,n) </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> FORMAT(<span class="number">14722.25862</span>, <span class="number">4</span>),FORMAT(<span class="number">14722.25868</span>, <span class="number">4</span>),FORMAT(<span class="number">14722.25862</span>,<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p><img src="/post/c24675b4/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220414141112655.png" alt="image-20220414141112655"></p><p>  类型转换函数：CAST(x, AS type)和CONVERT(x, type)函数将一个类型的值转换为另一个类型的值，可转换的type有BINARY、CHAR(n)、DATE、TIME、 DATETIME、DECIMAL、SIGNED、UNSIGNED。</p><h2 id="八、存储过程与自定义函数"><a href="#八、存储过程与自定义函数" class="headerlink" title="八、存储过程与自定义函数"></a>八、存储过程与自定义函数</h2><p>存储程序可以分为存储过程和函数。在MySQL中，创建存储过程和函数使用的语句分别是CREATE<br>PROCEDURE和CREATE FUNCTION。使用CALL语句来调用存储过程，只能用输出变量返回值。函数可以从语句外调用（引用函数名），也能返回标量值。存储过程也可以调用其他存储过程。</p><h3 id="1-gt-存储过程："><a href="#1-gt-存储过程：" class="headerlink" title="1&gt;存储过程："></a>1&gt;存储过程：</h3><p>创建存储过程，需要使用CREATE PROCEDURE命令。语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> name(param)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">body;</span><br><span class="line"><span class="keyword">END</span>$$</span><br></pre></td></tr></table></figure><p>name：代表参数的名字，param:参数。参数有 in|out|inout类型。in:输入参数，out:输出参数， inout:输入输出参数。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查找所有的部门数量</span></span><br><span class="line">DELIMITER $$</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> demo()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="number">1</span>) <span class="keyword">FROM</span> depts;</span><br><span class="line"><span class="keyword">END</span>$$</span><br><span class="line">DELIMITER ;</span><br><span class="line"><span class="comment">-- 调用过程</span></span><br><span class="line"><span class="keyword">CALL</span> demo();</span><br><span class="line"><span class="comment">-- 删除过程</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> demo;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 输出类型的参数 参数不能以@开头</span></span><br><span class="line">DELIMITER $$</span><br><span class="line">    <span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> demo2(<span class="keyword">OUT</span> num <span class="type">INT</span>)</span><br><span class="line">    <span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="number">1</span>) <span class="keyword">INTO</span> num <span class="keyword">FROM</span> depts;</span><br><span class="line">    <span class="keyword">END</span>$$</span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 声明变量 @</span></span><br><span class="line"><span class="keyword">CALL</span> demo2(<span class="variable">@num</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="variable">@num</span>;</span><br></pre></td></tr></table></figure><h3 id="小练习："><a href="#小练习：" class="headerlink" title="小练习："></a>小练习：</h3><ol><li>根据编号查询名字【传入编号，获取名字】</li><li>根据编号查询vip的名字(传入编号，获取名字和性别)</li><li>创建过程，根据输入的成绩编号【pk】，获取该学号，科目号以及成绩</li><li>根据考试号查找学生的名字，科目名字，以及成绩</li></ol><h3 id="2-gt-函数："><a href="#2-gt-函数：" class="headerlink" title="2&gt;函数："></a>2&gt;函数：</h3><p>创建存储函数，需要使用CREATE FUNCTION语句，基本语法格式如 下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> funname(parama) <span class="keyword">RETURNS</span> type</span><br></pre></td></tr></table></figure><p>注意，如果是8.0，需要设置可以</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> log_bin_trust_function_creators<span class="operator">=</span><span class="literal">TRUE</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line">    <span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> fun_01() <span class="keyword">RETURNS</span> <span class="type">INT</span></span><br><span class="line">    <span class="keyword">BEGIN</span></span><br><span class="line">        <span class="keyword">DECLARE</span> _num <span class="type">INT</span>;</span><br><span class="line">        <span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">INTO</span> _num <span class="keyword">FROM</span> grade;</span><br><span class="line">        <span class="keyword">RETURN</span> _num;</span><br><span class="line">    <span class="keyword">END</span>$$</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line">    <span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> fun_02(_sid <span class="type">INT</span>) <span class="keyword">RETURNS</span> <span class="type">VARCHAR</span>(<span class="number">50</span>)</span><br><span class="line">    <span class="keyword">BEGIN</span></span><br><span class="line">        <span class="keyword">DECLARE</span> _sno <span class="type">VARCHAR</span>(<span class="number">50</span>);</span><br><span class="line">        <span class="keyword">DECLARE</span> _subid <span class="type">INT</span>;</span><br><span class="line">        <span class="keyword">DECLARE</span> _sco <span class="type">INT</span>;</span><br><span class="line">        <span class="keyword">SELECT</span> s_no,sub_id,student_sco <span class="keyword">INTO</span> _sno,_subid,_sco <span class="keyword">FROM</span> score <span class="keyword">WHERE</span> sco_id<span class="operator">=</span>_sid;</span><br><span class="line">        <span class="keyword">RETURN</span> CONCAT(_sno,<span class="string">&#x27;--&#x27;</span>,_subid,<span class="string">&#x27;--&#x27;</span>,_sco);</span><br><span class="line">    <span class="keyword">END</span>$$</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line">    <span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> fun_03(_sid <span class="type">INT</span>, _sno <span class="type">VARCHAR</span>(<span class="number">50</span>), _subid <span class="type">VARCHAR</span>(<span class="number">50</span>)) <span class="keyword">RETURNS</span> <span class="type">VARCHAR</span>(<span class="number">100</span>)</span><br><span class="line">    <span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> _sco <span class="type">INT</span>;</span><br><span class="line">    <span class="keyword">SELECT</span> s_no,sub_id,IFNULL(student_sco,<span class="number">0</span>) <span class="keyword">INTO</span> _sno,_subid,_sco <span class="keyword">FROM</span> score <span class="keyword">WHERE</span> sco_id<span class="operator">=</span>_sid;</span><br><span class="line">    <span class="keyword">RETURN</span> CONCAT(_sno,<span class="string">&#x27;--&#x27;</span>,_subid,<span class="string">&#x27;--&#x27;</span>,_sco);</span><br><span class="line">    <span class="keyword">END</span>$$</span><br><span class="line"> DELIMITER ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> score;</span><br><span class="line"><span class="keyword">SELECT</span> fun_03(<span class="number">8</span>,<span class="variable">@sno</span>,<span class="variable">@subid</span>);</span><br><span class="line"><span class="keyword">SELECT</span> CONCAT(<span class="variable">@sno</span>,<span class="variable">@subid</span>);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 传入条件 如果1 查询</span></span><br><span class="line">DELIMITER $$</span><br><span class="line">    <span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> fun_05(_cond <span class="type">INT</span>,_id <span class="type">VARCHAR</span>(<span class="number">20</span>) ) <span class="keyword">RETURNS</span> <span class="type">VARCHAR</span>(<span class="number">100</span>)</span><br><span class="line">    <span class="keyword">BEGIN</span></span><br><span class="line">        <span class="keyword">DECLARE</span> _sco <span class="type">VARCHAR</span>(<span class="number">50</span>);</span><br><span class="line">        IF _cond<span class="operator">=</span><span class="number">1</span> <span class="keyword">THEN</span></span><br><span class="line">        <span class="keyword">SELECT</span> g_name <span class="keyword">INTO</span> _sco <span class="keyword">FROM</span> grade <span class="keyword">WHERE</span> g_id<span class="operator">=</span>_id ;</span><br><span class="line">        ELSEIF _cond<span class="operator">=</span><span class="number">2</span> <span class="keyword">THEN</span></span><br><span class="line">       <span class="keyword">SELECT</span> s_name <span class="keyword">INTO</span> _sco <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> s_no<span class="operator">=</span>_id;</span><br><span class="line">        <span class="keyword">ELSE</span></span><br><span class="line">        <span class="keyword">SELECT</span> sub_name <span class="keyword">INTO</span> _sco <span class="keyword">FROM</span> subjects <span class="keyword">WHERE</span> sub_id<span class="operator">=</span>_id;</span><br><span class="line">        <span class="keyword">END</span> IF;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">RETURN</span> CONCAT(_cond,<span class="string">&#x27;--&#x27;</span>,_id,<span class="string">&#x27;--&#x27;</span>,_sco);</span><br><span class="line">    <span class="keyword">END</span>$$</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><h3 id="小练笔："><a href="#小练笔：" class="headerlink" title="小练笔："></a>小练笔：</h3><ol><li><p>使用存储函数|过程  传入学号，获取学生的姓名，总分，平均分</p></li><li><p>输入，科目名字，学时，以及gradeid ，将该数据插入到数据库</p></li><li><p>根据传入的科目编号删除科目信息，如果该科目以及被考过试，则不能删除</p></li></ol><h2 id="九、触发器、游标与视图"><a href="#九、触发器、游标与视图" class="headerlink" title="九、触发器、游标与视图"></a>九、触发器、游标与视图</h2><h3 id="1、触发器"><a href="#1、触发器" class="headerlink" title="1、触发器"></a>1、触发器</h3><p>MySQL的触发器和存储过程一样，都是嵌入到MySQL的一段程序。触发器是由事件来触发某个操作，这些事件包括INSERT、UPDATAE和 DELETE语句。如果定义了触发程序，当数据库执行这些语句的时候就会激发触发器执行相应的操作，触发程序是与表有关的命名数据库对象，当表上出现特定事件时，将激活该对象。<br>触发器（trigger）是一个特殊的存储过程，不同的是，执行存储过程要 使用CALL语句来调用，而触发器的执行不需要使用CALL语句来调用，也 不需要手工启动，只要当一个预定义的事件发生的时候，就会被MySQL自 动调用。比如当对fruits表进行操作（INSERT、DELETE或UPDATE）时就会激活它执行。 触发器可以查询其他表，而且可以包含复杂的SQL语句。它们主要用于满足复杂的业务规则或要求。</p><p>例如，可以根据客户当前的账户状态控制是否允许插入新订单<br> 触发器：在哪个表触发</p><p>行级触发器：影响几条记录就会触发几次</p><p>语句级触发器:一条sql语句执行了，就会触发一次 </p><p>​before   after </p><p>​新值：新添加的值教新值</p><p>​旧值：<br>​update grade set gradename&#x3D;’新班级’ where gradeid&#x3D;1;此时“新班级”为新值，数据库中原有的值为旧值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一个表不要添加过多的触发器</span><br><span class="line">oracle支持行级触发器以及语句级触发器</span><br><span class="line">mysql:不支持语句级触发器</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 行级触发</span></span><br><span class="line">DELIMITER $$</span><br><span class="line">    <span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> tri_01 AFTER <span class="keyword">INSERT</span> <span class="keyword">ON</span> dept <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line">    <span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> depts <span class="keyword">VALUES</span>(<span class="keyword">NULL</span>,new.deptid,<span class="string">&#x27;新增&#x27;</span>);</span><br><span class="line">    <span class="keyword">END</span>$$</span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line">DELIMITER $$</span><br><span class="line">    <span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> tri_02 AFTER <span class="keyword">DELETE</span> <span class="keyword">ON</span> dept <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line">    <span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> depts <span class="keyword">VALUES</span>(<span class="keyword">NULL</span>,old.deptid,<span class="string">&#x27;删除&#x27;</span>);</span><br><span class="line">    <span class="keyword">END</span>$$</span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>会员等级  总的消费金额到底一定的额度，对应的等级信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line">    <span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> tri_03 AFTER <span class="keyword">INSERT</span> <span class="keyword">ON</span> sale <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line">    <span class="keyword">BEGIN</span></span><br><span class="line">        <span class="keyword">DECLARE</span> _allmoney <span class="type">INT</span>;</span><br><span class="line">        <span class="keyword">SELECT</span> <span class="built_in">SUM</span>(money) <span class="keyword">INTO</span> _allmoney <span class="keyword">FROM</span> sale <span class="keyword">WHERE</span> vipId<span class="operator">=</span>new.vipId;</span><br><span class="line">        IF _allmoney<span class="operator">&gt;</span><span class="number">5000</span> <span class="keyword">THEN</span></span><br><span class="line">        <span class="keyword">UPDATE</span> vip <span class="keyword">SET</span> vipLeve<span class="operator">=</span><span class="number">4</span> <span class="keyword">WHERE</span> vipId<span class="operator">=</span>new.vipId;</span><br><span class="line">        ELSEIF _allmoney<span class="operator">&gt;</span><span class="number">1000</span> <span class="keyword">THEN</span></span><br><span class="line">       <span class="keyword">UPDATE</span> vip <span class="keyword">SET</span> vipLeve<span class="operator">=</span><span class="number">3</span> <span class="keyword">WHERE</span> vipId<span class="operator">=</span>new.vipId;</span><br><span class="line">        ELSEIF _allmoney<span class="operator">&gt;</span><span class="number">100</span> <span class="keyword">THEN</span></span><br><span class="line">        <span class="keyword">UPDATE</span> vip <span class="keyword">SET</span> vipLeve<span class="operator">=</span><span class="number">2</span> <span class="keyword">WHERE</span> vipId<span class="operator">=</span>new.vipId;</span><br><span class="line">        <span class="keyword">END</span> IF;</span><br><span class="line">    <span class="keyword">END</span>$$</span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>小练习：</p><p>部门表中有个部门人数，如何自动维护部门人数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line">    <span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> tri_demo2 AFTER <span class="keyword">DELETE</span> <span class="keyword">ON</span> emp <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line">    <span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">UPDATE</span> dept <span class="keyword">SET</span> deptnum<span class="operator">=</span>deptnum<span class="number">-1</span> <span class="keyword">WHERE</span> deptid<span class="operator">=</span>old.deptid;</span><br><span class="line">    <span class="keyword">END</span>$$</span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line">DELIMITER $$</span><br><span class="line">    <span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> tri_demo3 AFTER <span class="keyword">UPDATE</span> <span class="keyword">ON</span> emp <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line">    <span class="keyword">BEGIN</span></span><br><span class="line">        IF old.deptid <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">AND</span> new.deptid <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">THEN</span></span><br><span class="line">        <span class="keyword">UPDATE</span> dept <span class="keyword">SET</span> deptnum<span class="operator">=</span>deptnum<span class="number">-1</span> <span class="keyword">WHERE</span> deptid<span class="operator">=</span>old.deptid;</span><br><span class="line">        <span class="keyword">UPDATE</span> dept <span class="keyword">SET</span> deptnum<span class="operator">=</span>deptnum<span class="operator">+</span><span class="number">1</span> <span class="keyword">WHERE</span> deptid<span class="operator">=</span>new.deptid;</span><br><span class="line">        ELSEIF new.deptid <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">THEN</span></span><br><span class="line">        <span class="keyword">UPDATE</span> dept <span class="keyword">SET</span> deptnum<span class="operator">=</span>deptnum<span class="operator">+</span><span class="number">1</span> <span class="keyword">WHERE</span> deptid<span class="operator">=</span>new.deptid;</span><br><span class="line">        <span class="keyword">END</span> IF;</span><br><span class="line">    <span class="keyword">END</span>$$</span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line">DELIMITER $$</span><br><span class="line">    <span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> tri_demo AFTER <span class="keyword">INSERT</span> <span class="keyword">ON</span> emp <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line">    <span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">UPDATE</span> dept <span class="keyword">SET</span> deptnum<span class="operator">=</span>deptnum<span class="operator">+</span><span class="number">1</span> <span class="keyword">WHERE</span> deptid<span class="operator">=</span>new.deptid;</span><br><span class="line">    <span class="keyword">END</span>$$</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><h3 id="2、流程语句"><a href="#2、流程语句" class="headerlink" title="2、流程语句"></a>2、流程语句</h3><ol><li>IF语句</li></ol>   <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line">    <span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> tri_04 AFTER <span class="keyword">INSERT</span> <span class="keyword">ON</span> sale <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line">    <span class="keyword">BEGIN</span></span><br><span class="line">        <span class="keyword">DECLARE</span> _num <span class="type">INT</span>;</span><br><span class="line">        <span class="keyword">SELECT</span> goodsNum <span class="keyword">INTO</span> _num <span class="keyword">FROM</span> goods <span class="keyword">WHERE</span> goodsId<span class="operator">=</span>new.goodsId;</span><br><span class="line"></span><br><span class="line">        IF _num<span class="operator">&gt;</span>new.num <span class="keyword">THEN</span></span><br><span class="line">       <span class="keyword">UPDATE</span> goods <span class="keyword">SET</span> goodsnum<span class="operator">=</span>goodsnum<span class="operator">-</span>new.num <span class="keyword">WHERE</span> goodsid<span class="operator">=</span>new.goodsId;</span><br><span class="line">        <span class="keyword">END</span> IF;</span><br><span class="line">    <span class="keyword">END</span>$$</span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li><p>循环结构</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line">    <span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> pro_01(num <span class="type">INT</span>)</span><br><span class="line">    <span class="keyword">BEGIN</span></span><br><span class="line">        <span class="keyword">DECLARE</span> _sum <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">DECLARE</span> _i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">1</span>;</span><br><span class="line">        WHILE _i<span class="operator">&lt;=</span>num DO</span><br><span class="line">            <span class="keyword">SET</span> _sum<span class="operator">=</span>_sum<span class="operator">+</span>_i;</span><br><span class="line">            <span class="keyword">SET</span> _i<span class="operator">=</span>_i<span class="operator">+</span><span class="number">1</span>;</span><br><span class="line">        <span class="keyword">END</span> WHILE;</span><br><span class="line">        <span class="keyword">SELECT</span> _sum;</span><br><span class="line">    <span class="keyword">END</span>$$</span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line">DELIMITER $$</span><br><span class="line">    <span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> pro_02(num <span class="type">INT</span>)</span><br><span class="line">    <span class="keyword">BEGIN</span></span><br><span class="line">        <span class="keyword">DECLARE</span> _sum <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">DECLARE</span> _i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">1</span>;</span><br><span class="line">        a:LOOP</span><br><span class="line">        IF _i<span class="operator">&gt;</span>num <span class="keyword">THEN</span></span><br><span class="line">        LEAVE a;</span><br><span class="line">        <span class="keyword">END</span> IF;</span><br><span class="line">        <span class="keyword">SET</span> _sum<span class="operator">=</span>_sum<span class="operator">+</span>_i;</span><br><span class="line">        <span class="keyword">SET</span> _i<span class="operator">=</span>_i<span class="operator">+</span><span class="number">1</span>;</span><br><span class="line">        <span class="keyword">END</span> LOOP;</span><br><span class="line">        <span class="keyword">SELECT</span> _sum;</span><br><span class="line">    <span class="keyword">END</span>$$</span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line">DELIMITER $$</span><br><span class="line">    <span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> pro_03(num <span class="type">INT</span>)</span><br><span class="line">    <span class="keyword">BEGIN</span></span><br><span class="line">        <span class="keyword">DECLARE</span> _sum <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">DECLARE</span> _i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">1</span>;</span><br><span class="line">        REPEAT</span><br><span class="line">            <span class="keyword">SET</span> _sum<span class="operator">=</span>_sum<span class="operator">+</span>_i;</span><br><span class="line">            <span class="keyword">SET</span> _i<span class="operator">=</span>_i<span class="operator">+</span><span class="number">1</span>;</span><br><span class="line">        UNTIL _i<span class="operator">&gt;</span>num <span class="keyword">END</span> REPEAT;</span><br><span class="line">        <span class="keyword">SELECT</span> _sum;</span><br><span class="line">    <span class="keyword">END</span>$$</span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h3 id="3、游标"><a href="#3、游标" class="headerlink" title="3、游标"></a>3、游标</h3><p>​      游标是处理多行数据的，游标需要开启，抓取，关闭的</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line">    <span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> pro_04()</span><br><span class="line">    <span class="keyword">BEGIN</span></span><br><span class="line">        <span class="keyword">DECLARE</span> done <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">DECLARE</span> _typeid <span class="type">VARCHAR</span>(<span class="number">50</span>);</span><br><span class="line">        <span class="keyword">DECLARE</span> _typename <span class="type">VARCHAR</span>(<span class="number">50</span>);</span><br><span class="line">        <span class="keyword">DECLARE</span> _typedes <span class="type">VARCHAR</span>(<span class="number">50</span>);</span><br><span class="line">        <span class="keyword">DECLARE</span> cur_type <span class="keyword">CURSOR</span> <span class="keyword">FOR</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> producttype;</span><br><span class="line">        <span class="keyword">DECLARE</span> CONTINUE HANDLER <span class="keyword">FOR</span> <span class="keyword">NOT</span> FOUND <span class="keyword">SET</span> done<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line">        <span class="keyword">OPEN</span> cur_type;</span><br><span class="line">            loopname:LOOP</span><br><span class="line">                <span class="keyword">FETCH</span> cur_type <span class="keyword">INTO</span> _typeid,_typename,_typedes;</span><br><span class="line">                IF done<span class="operator">=</span><span class="number">1</span> <span class="keyword">THEN</span></span><br><span class="line">                LEAVE loopname;</span><br><span class="line">                <span class="keyword">END</span> IF;</span><br><span class="line">                <span class="keyword">INSERT</span> type_bak <span class="keyword">VALUES</span>(_typeid,_typename,_typedes);</span><br><span class="line">            <span class="keyword">END</span> LOOP;</span><br><span class="line">        <span class="keyword">CLOSE</span> cur_type;</span><br><span class="line">    <span class="keyword">END</span>$$</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><h3 id="4、视图"><a href="#4、视图" class="headerlink" title="4、视图"></a>4、视图</h3><p>​        数据库中的视图是一个虚拟表。同真实的表一样，视图包含一系列带有名称的行和列数据。行和列数据来自由定义视图查询所引用的表，并且在引用视图时动态生成。视图是从一个或者多个表中导出的，视图的行为与表非常相似，但视图是一个虚拟表。在视图中用户可以使用SELECT语句查询数据。</p><p>​       视图是一个虚拟表，是从数据库中一个或多个表中导出来的表。视图还可以从已经存在的视图的基础上定义。</p><p><strong>视图特点:</strong> </p><ol><li>简单化：看到的就是需要的。视图不仅可以简化用户对数据的理解，也可以简化它们的操作。那些被经常使用的查询可以被定义为视图，从而使得用户不必为以后的操作每次指定全部的条件                        </li><li>安全性：通过视图用户只能查询和修改他们所能见到的数据。数据库中的其他数据则既看不见也取不到。</li><li>逻辑数据独立性:视图可帮助用户屏蔽真实表结构变化带来的影响。</li></ol><p> 视图主要做查看，不做insert,update,delete。虽然单表创建的视图，可以执行，但不推荐。多表创建视图无法执行以上操作。</p><p>​        创建视图的语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> viewname <span class="keyword">AS</span> <span class="keyword">SELECT</span> ......</span><br></pre></td></tr></table></figure><h2 id="十、索引"><a href="#十、索引" class="headerlink" title="十、索引"></a>十、索引</h2><p>索引用于快速找出在某个列中有一特定值的行。不使用索引，MySQL 必须从第1条记录开始读完整个表，直到找出相关的行。表越大，查询数据 所花费的时间越多。如果表中查询的列有一个索引，MySQL 能快速到达某 个位置去搜寻数据文件，而不必查看所有数据。索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可 提高数据库中特定数据的查询速度</p><p>索引的含义和特点：索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可 提高数据库中特定数据的查询速度。使用索引可以快速找出在某个或多个列中有一特定值的 行，所有MySQL列类型都可以被索引，对相关列使用索引是提高查询操作速度的 佳途径。<br>索引是在存储引擎中实现的，因此，每种存储引擎的索引都不一定完全 相同，并且每种存储引擎也不一定支持所有索引类型。<br>MySQL中 索引的存储类型有两种，即BTREE和HASH，具体和表的存储引擎相关； MyISAM和InnoDB 存储引擎只支持BTREE索引；MEMORY&#x2F;HEAP存储引擎 可以支持HASH和BTREE索引</p><p><strong>索引的优点：</strong></p><p>（1）通过创建唯一索引，可以保证数据库表中每一行数据的唯一性。 </p><p>（ 2）可以大大加快数据的查询速度，这也是创建索引的主要原因。 </p><p>（ 3）在实现数据的参考完整性方面，可以加速表和表之间的连接。 </p><p>（ 4）在使用分组和排序子句进行数据查询时，也可以显著减少查询中 分组和排序的时间。</p><p><strong>索引的缺点：</strong></p><p>（1）创建索引和维护索引要耗费时间，并且随着数据量的增加所耗费 的时间也会增加。 </p><p>（ 2）索引需要占磁盘空间，除了数据表占数据空间之外，每一个索引 还要占一定的物理空间，如果有大量的索引，索引文件可能比数据文件更快 达到 大文件尺寸。 </p><p>（ 3）当对表中的数据进行增加、删除和修改的时候，索引也要动态地 维护，这样就降低了数据的维护速度。</p><p>索引的设计原则：索引设计不合理或者缺少索引都会对数据库和应用程序的性能造成障 碍。高效的索引对于获得良好的性能非常重要。</p><p><strong>设计索引时，应该考虑以下 准则：</strong></p><p>（1）索引并非越多越好，一个表中如有大量的索引，不仅占用磁盘空 间，还会影响INSERT、DELETE、UPDATE等语句的性能，因为在表中的 数据更改时，索引也会进行调整和更新。 </p><p>（ 2）避免对经常更新的表进行过多的索引，并且索引中的列要尽可能 少。应该经常用于查询的字段创建索引，但要避免添加不必要的字段。 </p><p>（ 3）数据量小的表 好不要使用索引，由于数据较少，查询花费的时 间可能比遍历索引的时间还要短，索引可能不会产生优化效果。 </p><p>（ 4）在条件表达式中经常用到的不同值较多的列上建立索引，在不同 值很少的列上不要建立索引。比如在学生表的“性别”字段上只 有“男”与“女”两个不同值，因此就无须建立索引，如果建立索引不但不会提 高查询效率，反而会严重降低数据更新速度。 </p><p>（ 5）当唯一性是某种数据本身的特征时，指定唯一索引。使用唯一索 引需能确保定义的列的数据完整性，以提高查询速度。 </p><p>（ 6）在频繁进行排序或分组（即进行group by或order by操作）的列上 建立索引，如果待排序的列有多个，可以在这些列上建立组合索引。</p><p><strong>索引分类：</strong></p><p>​1．普通索引和唯一索引 普通索引是MySQL中的基本索引类型，允许在定义索引的列中插入重 复值和空值。 唯一索引要求索引列的值必须唯一，但允许有空值。如果是组合索引， 则列值的组合必须唯一。主键索引是一种特殊的唯一索引，不允许有空值。<br>​2．单列索引和组合索引 单列索引即一个索引只包含单个列，一个表可以有多个单列索引。组合索引是指在表的多个字段组合上创建的索引，只有在查询条件中使 用了这些字段的左边字段时，索引才会被使用。使用组合索引时遵循 左前 缀集合。<br>​ 3．全文索引 全文索引类型为FULLTEXT，在定义索引的列上支持值的全文查找， 允许在这些索引列中插入重复值和空值。全文索引可以在CHAR、 VARCHAR或者TEXT类型的列上创建。MySQL中只有MyISAM存储引擎支 持全文索引。<br>​ 4．空间索引 空间索引是对空间数据类型的字段建立的索引，MySQL中的空间数据 类型有4 种，分别是GEOMETRY、POINT、LINESTRING和POLYGON。 MySQL使用SPATIAL关键字进行扩展，使得能够用创建正规索引类似的语 法创建空间索引。创建空间索引的列，必须将其声明为NOT NULL，空间索 引只能在存储引擎为MyISAM的表中创建。</p><p><strong>索引创建：</strong></p><p>创建普通索引， 基本的索引类型，没有唯一性之类的限制，其作用只是加快对数据的访问速度。</p><p><img src="/post/c24675b4/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220414141522677.png" alt="image-20220414141522677"></p><p>如果表已经存在，创建索引的语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Alter</span> <span class="keyword">table</span> tabname <span class="keyword">add</span> [<span class="keyword">unique</span><span class="operator">|</span>fulltext<span class="operator">|</span>spatial] index indexname</span><br><span class="line">(colname[length])</span><br></pre></td></tr></table></figure><p>删除索引的语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Alter</span> <span class="keyword">table</span> tabname <span class="keyword">drop</span> index indexname</span><br></pre></td></tr></table></figure><p>创建组合索引：组合索引是在多个字段上创建一个索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test_db(</span><br><span class="line">    vid <span class="type">INT</span> ,</span><br><span class="line">    vname <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    vage <span class="type">INT</span>,</span><br><span class="line">    vinfo <span class="type">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">    INDEX mul (vid,vname,vage)</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由结果可以看到，vid、vname和vage字段上已经成功建立了一个名为 mul的组合索引。组合索引可起几个索引的作用，但是使用时并不是随便查询哪个字段都可以使用索引，而是遵从“左前缀”：利用索引中 左边的列集来匹配行,这样的列集称为 左前缀。</p><p>删除索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tabname <span class="keyword">drop</span> index indexname</span><br></pre></td></tr></table></figure><h2 id="十一、事务"><a href="#十一、事务" class="headerlink" title="十一、事务"></a>十一、事务</h2><p>数据库事务( transaction)是访问并可能操作各种数据项的一个数据库操作序列，这些操作要么全部执行, 要么全部不执行，是一个不可分割的工作单位。事务由事务开始与事务结束之间执行的全部数据库操作组成<br>事务是由一组SQL语句 组成的逻辑处理单元，它的ACID特性如下：<br>（1）原子性（Atomicity）：事务具有原子不可分割的特性，要么一起执行，要么都不执行。<br>（2）一致性（Consistency）：在事务开始和事务结束时，数据都保持一致状态。<br>（3）隔离性（Isolation）：在事务开始和结束过程中，事务保持着一定的隔离特性，保证事务不受外部并发数据操作的影响。<br>（4）持久性（Durability）：事务完成后，数据将会被持久化到数据库中。</p><p> <img src="/post/c24675b4/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220414141545779.png" alt="image-20220414141545779"></p><p>事务有两状态一个是提交【commit】，一个是回滚【rollback】。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span> ; <span class="comment">-- 开启事务 提交 commit或 回滚rollback</span></span><br><span class="line"><span class="keyword">UPDATE</span> account <span class="keyword">SET</span> abalance<span class="operator">=</span>abalance<span class="number">-2000</span> <span class="keyword">WHERE</span> aid<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> account <span class="keyword">SET</span> abalance<span class="operator">=</span>abalance<span class="operator">+</span><span class="number">2000</span> <span class="keyword">WHERE</span> aid<span class="operator">=</span><span class="number">2</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line">或</span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br></pre></td></tr></table></figure><p>还可以设置打点事务，即再保存点之前的会提交，保存点之后的会回滚</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION ;</span><br><span class="line"><span class="keyword">UPDATE</span> account <span class="keyword">SET</span> abalance<span class="operator">=</span>abalance<span class="number">-10</span> <span class="keyword">WHERE</span> aid<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">SAVEPOINT</span> A;</span><br><span class="line"><span class="keyword">UPDATE</span> account <span class="keyword">SET</span> abalance<span class="operator">=</span>abalance<span class="number">-1000</span> <span class="keyword">WHERE</span> aid<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> account <span class="keyword">SET</span> abalance<span class="operator">=</span>abalance<span class="operator">+</span><span class="number">1000</span> <span class="keyword">WHERE</span> aid<span class="operator">=</span><span class="number">2</span>;</span><br><span class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> A;</span><br></pre></td></tr></table></figure><p>事务隔离级别：一个事务对数据库修改与并行的另一个事务的隔离程度。<br>两个并发事务同时访问数据库表相同的行时，可能存在以下三个问题：<br>1、幻想读，2、不可重复读取 ，3、脏读<br>为了处理这些问题，SQL标准定义了以下几种事务隔离级别</p><table><thead><tr><th></th><th><strong>脏读</strong></th><th><strong>不可重复读</strong></th><th><strong>幻读</strong></th></tr></thead><tbody><tr><td>Read  uncommitted</td><td>√</td><td>√</td><td>√</td></tr><tr><td>Read  committed</td><td>×</td><td>√</td><td>√</td></tr><tr><td>Repeatable  read</td><td>×</td><td>×</td><td>√</td></tr><tr><td>Serializable</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><p><strong>脏读</strong>：事务A读取到事务B未提交的数据。<br>           比如账号1的账号金额是5000，此时事务B，将1账号的金额更改为8000，但是还未提交事务，此时事务A,查看1账号的金额，看到8000，然后事务B对操作做了回滚。事务A就读取到脏数据。<br>           如果将事务的隔离级别提高到Read uncommitted，便不会产生以上情况。</p><p><strong>不可重复读</strong>：事务A查看1账号的金额是2000，此时想再账号上减2000.但是还没操作的时候，事务B,将数据更改了，并再事务A之前提交了事务。此时事务A再次读取该数据的时候，已经改变了。<br>           事务的隔离级别提高到Read committed时，避免了脏读，但是会造成不可重复度。大多数数据库的默认级别就是ReadCommited.可以将事务的隔离级别提高到Repeatable read。也就是事务A读取了数据，再未提交事务的时候，事务B不能对数据进行修改。</p><p><strong>幻读</strong>：事务A查看第一次查看记录的时候为80。此时，事务B对该记录做了更改，事务A再看的时候，发现不是80，事务A就像出现环境一样。将隔离级别提高到Serializable就可以避免幻读。<br>查看mysql的事务隔离级别</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@transaction</span>_isolation; [<span class="keyword">select</span> @<span class="variable">@tx</span>_isolation;]</span><br></pre></td></tr></table></figure><p>设置mysql的事务隔离级别</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;</span><br></pre></td></tr></table></figure><p><img src="/post/c24675b4/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220414141620429.png" alt="image-20220414141620429"></p><p>脏读：事务A读取到事务B未提交的数据。脏数据所指的就是未提交的数据           设置事务A与事务B的隔离级别为Read uncommitted；</p><table><thead><tr><th><strong>事务</strong>A[事务A读取到的8000就是脏数据]</th><th><strong>事务</strong>B</th></tr></thead><tbody><tr><td>READ  UNCOMMITTED;</td><td>READ  UNCOMMITTED;</td></tr><tr><td>select * from  account ;– 5000</td><td>select  * from account;–5000</td></tr><tr><td></td><td>begin;</td></tr><tr><td></td><td>update  account set balance&#x3D;8000 where accid&#x3D;1;</td></tr><tr><td>select * from  account ;– 8000</td><td></td></tr><tr><td></td><td>rollback</td></tr></tbody></table><p>操作：事务A和事务B都设置事务的隔离级别为READ UNCOMMITTED;</p><p><img src="/post/c24675b4/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220414141652308.png" alt="image-20220414141652308"></p><p>事务B开启事务，并更新记录为8000，此时并未提交</p><p><img src="/post/c24675b4/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220414141700526.png" alt="image-20220414141700526"></p><p>事务A查看数据，看到了8000的结果。</p><p><img src="/post/c24675b4/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220414141707840.png" alt="image-20220414141707840"></p><p>事务B又做了回滚，此时事务A读取到的8000，就属于<br><strong>不可重复读</strong>：一个事务先后读取同一条记录，而事务在两次读取之间该数据被其它事务所修改，则两次读取的数据不同，我们称之为不可重复读。<br>       设置事务A与事务B的隔离级别为Read committed；</p><table><thead><tr><th><strong>事务</strong>A</th><th><strong>事务</strong>B</th></tr></thead><tbody><tr><td>READ  COMMITTED;</td><td>READ  COMMITTED;</td></tr><tr><td>select * from  account ;– 5000</td><td>select  * from account;–5000</td></tr><tr><td></td><td>begin;</td></tr><tr><td></td><td>update  account set balance&#x3D;balance+3000 where accid&#x3D;1;</td></tr><tr><td></td><td>COMMIT;</td></tr><tr><td>begin;</td><td></td></tr><tr><td>update  account set balance&#x3D;balance+3000 where accid&#x3D;1;</td><td></td></tr><tr><td></td><td></td></tr><tr><td>COMMIT;</td><td></td></tr><tr><td>select * from  account;– 11000??</td><td>select  * from account;– 8000</td></tr></tbody></table><p><strong>幻读</strong>:一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为幻读。</p><p> 设置事务A与事务B的隔离级别为REPEATABLE READ；</p><h2 id="十二、数据库三范式"><a href="#十二、数据库三范式" class="headerlink" title="十二、数据库三范式"></a>十二、数据库三范式</h2><p>为了建立冗余较小、结构合理的数据库，设计数据库时必须遵循一定的规则。在关系型数据库中这种规则就称为范式。范式是符合某一种设计要求的总结。要想设计一个结构合理的关系型数据库，必须满足一定的范式。<br>在实际开发中 为常见的设计范式有三个：</p><h3 id="1．第一范式-确保每列保持原子性"><a href="#1．第一范式-确保每列保持原子性" class="headerlink" title="1．第一范式(确保每列保持原子性)"></a>1．第一范式(确保每列保持原子性)</h3><p>第一范式是 基本的范式。如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式。<br>第一范式的合理遵循需要根据系统的实际需求来定。比如某些数据库系统中需要用到“地址”这个属性，本来直接将“地址”属性设计成一个数据库表的字段就行。但是如果系统经常会访问“地址”属性中的“城市” 部分，那么就非要将“地址”这个属性重新拆分为省份、城市、详细地址等多个部分进行存储，这样在对地址中某一部分操作的时候将非常方便。这样设计才算满足了数据库的第一范式，如下表所示。</p><p><img src="/post/c24675b4/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220414141753638.png" alt="image-20220414141753638"></p><h3 id="2-第二范式-确保表中的每列都和主键相关"><a href="#2-第二范式-确保表中的每列都和主键相关" class="headerlink" title="2.第二范式(确保表中的每列都和主键相关)"></a>2.第二范式(确保表中的每列都和主键相关)</h3><p>第二范式在第一范式的基础之上更进一层。第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。</p><p>比如要设计一个订单信息表，因为订单中可能会有多种商品，所以要将订单编号和商品编号作为数据库表的联合主键，如下表所示。</p><p><img src="/post/c24675b4/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220414141802188.png" alt="image-20220414141802188"></p><p><em>订单信息表</em><br>这样就产生一个问题：这个表中是以订单编号和商品编号作为联合主键。这样在该表中商品名称、单位、商品价格等信息不与该表的主键相关，而仅仅是与商品编号相关。所以在这里违反了第二范式的设计原则。<br>而如果把这个订单信息表进行拆分，把商品信息分离到另一个表中，把订单项目表也分离到另一个表中，就非常完美了。如下所示。</p><p><img src="/post/c24675b4/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220414141815238.png" alt="image-20220414141815238"></p><p>这样设计，在很大程度上减小了数据库的冗余。如果要获取订单的商品信息，使用商品编号到商品信息表中查询即可。</p><h3 id="3．第三范式-确保每列都和主键列直接相关-而不是间接相关"><a href="#3．第三范式-确保每列都和主键列直接相关-而不是间接相关" class="headerlink" title="3．第三范式(确保每列都和主键列直接相关,而不是间接相关)"></a>3．第三范式(确保每列都和主键列直接相关,而不是间接相关)</h3><p>第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。<br>比如在设计一个订单数据表的时候，可以将客户编号作为一个外键和订单表建立相应的关系。而不可以在订单表中添加关于客户其它信息（比如姓名、所属公司等）的字段。如下面这两个表所示的设计就是一个满足第三范式的数据库表。</p><p><img src="/post/c24675b4/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220414141827548.png" alt="image-20220414141827548"></p><p>这样在查询订单信息的时候，就可以使用客户编号来引用客户信息表中的记录，也不必在订单信息表中多次输入客户信息的内容，减小了数据冗余。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RHCSA</title>
      <link href="/post/38c0576c.html"/>
      <url>/post/38c0576c.html</url>
      
        <content type="html"><![CDATA[<h1 id="day01"><a href="#day01" class="headerlink" title="day01"></a>day01</h1><p>1.不要安装安全类的软件</p><p>2.确保window   64位   不是教育版</p><p>文件系统（磁盘上组织文件的一种方法和数据结构）   ntfs       —-支持的单个文件最大是4TB    fat32 —-支持的最大单个文件是4G</p><p>3.开启虚拟机提示VT-X未开启(物理机没有开启虚拟化)</p><p>环境部署系统安装：</p><p>虚拟平台（vmware-workstation）+创建一台虚拟机+RHEL-server-8.5-x86_64.iso</p><p>(网络模式选择-仅主机  nat*   桥接；磁盘类型ide  sata  scsi   nvme*)</p><p>​面试：</p><p>​       linux必须创建分区：   &#x2F;      swap(虚拟内存)</p><p>​一般llinux 需要创建哪些分区： &#x2F;    &#x2F;boot   swap</p><p>登陆主通过用户名密码验证</p><p>linux系统管理员 默认root用户—–后期登录主机通过管理员登录</p><p>​                 普通用户     redhat</p><p>判断命令是否成功，第一种执行后没有任何提示返回到下一个命令提示符 第二种有对应命令结果提示</p><p>1.查看主机ip地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#ip   a ==ip addr</span><br><span class="line">2: ens160: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000</span><br><span class="line">    link/ether 00:0c:29:c3:cf:a9 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.220.162/24 brd 192.168.220.255 scope global dynamic ens160</span><br><span class="line">       valid_lft 1710sec preferred_lft 1710sec</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#ifconfig</span><br></pre></td></tr></table></figure><p>2.终端（标准的输入输出设备键盘鼠标显示器）</p><p>虚拟终端：ctrl+alt+F3 ~ F6         ctrl +alt+F2       &#x2F;dev&#x2F;tty3   &#x2F;dev&#x2F;tty4   命令行的终端</p><p>​        模拟终端： 图形化模拟的终端窗口</p><p>​    远程终端： 伪终端   通过远程软件基于远程连接的终端窗口      &#x2F;dev&#x2F;pts&#x2F;0    &#x2F;dev&#x2F;pts&#x2F;1 …</p><p>物理终端</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#tty   查看当前终端的设备文件</span><br></pre></td></tr></table></figure><p>3.终端的命令提示符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# </span><br><span class="line">用户名@主机名   当前路径~标记的是当用户的家目录/root   #标记管理员</span><br><span class="line">注：目录----window 文件夹</span><br><span class="line">[redhat@localhost ~]$ pwd     --print   workdoing  directory   打印当前目录路径    </span><br><span class="line">/home/redhat</span><br><span class="line">redhat  ~标记是  /home/redhat     $标记普通用户</span><br></pre></td></tr></table></figure><p>4.命令的标准格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.#命令      #ifconfig</span><br><span class="line">2.#命令    参数   #ip   a</span><br><span class="line">3.#命令   -选项...   #ls  -l   #ls -a</span><br><span class="line">4.#命令   -选项...   参数    #ls -l   /root</span><br><span class="line">          -l   短选项</span><br><span class="line">          --long 长选项</span><br></pre></td></tr></table></figure><p>5.基础命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#ip a   查看ip地址</span><br><span class="line">#ifconfig 查看ip地址</span><br><span class="line">#tty   查看当前终端的设备文件名</span><br><span class="line">#cat /etc/redhat-realse  查看操作系统发行版信息</span><br><span class="line">#uname -r    查看内核版本</span><br><span class="line">#pwd 显示当前目录路径</span><br><span class="line">#hostname 查看当前的完整主机名</span><br><span class="line">#hostname   HOSTNAME   在当前主机运行状态下临时更改主机名。改完后终端提示符设备主机名需要退出重新登录识别</span><br><span class="line">#hostnamectl set-hostname  HOSTNAME  永久更改主机名          vim  /etc/hostname   </span><br><span class="line">#passwd  [USERNAME]   修改或者设置用户的密码</span><br><span class="line">#passwd -d  [USERNAME]  删除用户密码</span><br><span class="line"></span><br><span class="line">注：</span><br><span class="line">管理执行passwd：   可以指定用户名；不要输入之前的密码；可以更改和删除所有用户的密码；密码等级没有严格要求</span><br><span class="line">普通用户执行passwd： 不能至指定用户名只能修改自己的密码；需要输入之前的密码； 密码登记有严格要求</span><br></pre></td></tr></table></figure><p>6.系统密码重置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">重启客户机----在启动界面快速将鼠标点进去上下键切换一下（停留在启动界面）+e----找到linux开头的行在行尾添加------rd.break-------   mount   -o   remount,rw    /sysroot   ----chroot   /sysroot     -----passwd root   </span><br><span class="line"></span><br><span class="line">----touch /.autorelabel ---exit   ---exit</span><br></pre></td></tr></table></figure><p>1.安装linux操作系统</p><p>2.第一天基础命令整理总结</p><p>3.破解密码</p><h1 id="day02"><a href="#day02" class="headerlink" title="day02"></a>day02</h1><h2 id="cd-切换目录"><a href="#cd-切换目录" class="headerlink" title="cd   切换目录"></a>cd   切换目录</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#cd   chang  directory</span><br><span class="line">相对路径： 相对于当前所在的路径开始查找       cd   home</span><br><span class="line"></span><br><span class="line">/     根目录            cd   /</span><br><span class="line">~    当前用户的家目录</span><br><span class="line">.    当前目录    </span><br><span class="line">..   上层目录        cd  ../../..</span><br><span class="line">-     上一次所切换的路径</span><br></pre></td></tr></table></figure><h2 id="su-用户切换"><a href="#su-用户切换" class="headerlink" title="su   用户切换"></a>su   用户切换</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">su    USERNAME     切换到指定用户，当前路径没有更改</span><br><span class="line">su     切换到root用户</span><br><span class="line">su  -l   USERNAME   ==   su   -   redhat</span><br><span class="line">切换到指定用户，更改当前路径返回到当前用户的家目录</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>快捷键</p><p>ctrl+c   终止当前名令执行</p><p>ctrl+l   清屏      &#x3D;&#x3D; clear</p><h2 id="ls-列出命令（查看目录下的所有文件）"><a href="#ls-列出命令（查看目录下的所有文件）" class="headerlink" title="ls     列出命令（查看目录下的所有文件）"></a>ls     列出命令（查看目录下的所有文件）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-l    长格式显示文件以及文件的属性   ls  -l     ==  ll  </span><br><span class="line">-d  查看指定目录的属性     ll -d /root  列出的是/root目录的属性信息    ll -d  显示当前目录属性     </span><br><span class="line">-a   显示指定目录下所有文件包含隐藏文件和.  .. 当前目录和上一级目录  ls -l  -a   == ls -la == ll -a</span><br><span class="line">-A  显示指定目录下所有文件包含隐藏文件</span><br><span class="line">-h   文件大小转化</span><br><span class="line">-i    显示文件inode节点号</span><br><span class="line">-R  递归显示当前目录以及嵌套目录中所有的文件</span><br></pre></td></tr></table></figure><h2 id="linux基本思想一切皆文件—–7种文件类型"><a href="#linux基本思想一切皆文件—–7种文件类型" class="headerlink" title="linux基本思想一切皆文件—–7种文件类型"></a>linux基本思想一切皆文件—–7种文件类型</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">-普通文本文件   </span><br><span class="line"></span><br><span class="line">d 目录文件  </span><br><span class="line"></span><br><span class="line">l 软链接文件（快捷方式）</span><br><span class="line"></span><br><span class="line"> b 块设备文件 </span><br><span class="line"></span><br><span class="line"> c字符设备文件</span><br><span class="line"></span><br><span class="line"> p管道文件</span><br><span class="line"></span><br><span class="line"> s socket套接字文件 </span><br><span class="line"></span><br><span class="line">2-11字符   标记的是权限标识符</span><br><span class="line">第二列： 硬链接次数</span><br><span class="line">第三列： 所属用户</span><br><span class="line">第四列： 所属组</span><br><span class="line">第五列： 文件大小</span><br><span class="line">第六列：文件创建时间或修改时间</span><br><span class="line">第七列：文件名</span><br></pre></td></tr></table></figure><table><thead><tr><th>&#x2F;</th><th>Linux文件系统的最上层根目录,其他所有目录均是该目录的子目录</th></tr></thead><tbody><tr><td>&#x2F;bin</td><td>Binary的缩写,存放普通用户可执行的程序或命令</td></tr><tr><td>&#x2F;boot</td><td>存放系统启动时所需的文件,这些文件若损坏常会导致系统无法启动,一般不要改动</td></tr><tr><td>&#x2F;dev</td><td>dev 是设备（device）的英文缩写。包含所有的设备文件</td></tr><tr><td>&#x2F;etc</td><td>存放了系统管理时要用到的各种配置文件和子目录</td></tr><tr><td>&#x2F;home</td><td>存放一般用户的个人目录</td></tr><tr><td>&#x2F;lib</td><td>是库（library）英文缩写，存放系统的各种库文件</td></tr><tr><td>&#x2F;lib64</td><td>存放系统本身需要用到64位程序的共享函数库(library)</td></tr><tr><td>&#x2F;mnt   &#x2F;media</td><td>可以临时将别的文件系统挂在这个目录下，即为其他的文件系统提供安装点</td></tr><tr><td>&#x2F;opt</td><td>该目录通常提供给较大型的第三方应用程序使用,例如Sun Staroffice、Corel WordPerfect,这可避免将文件分散至整个文件系统</td></tr><tr><td>&#x2F;proc</td><td>可以在这个目录下获取系统信息。这些信息是在内存中由系统自己产生的（内核）</td></tr><tr><td>&#x2F;root</td><td>超级用户的个人目录，普通用户没有权限访问</td></tr><tr><td>&#x2F;run</td><td>保存自系统启动以来描述系统信息的文件（应用层的进程信息）</td></tr><tr><td>&#x2F;sbin</td><td>和&#x2F;bin类似，这些文件往往用来进行系统管理,只有root可使用</td></tr><tr><td>&#x2F;srv</td><td>srv 是服务(server)的简写,服务启动之后需要访问的数据目录</td></tr><tr><td>&#x2F;sys</td><td>本目录是将内核的一些信息映射文件,以供应用程序所用    系统文件</td></tr><tr><td>&#x2F;tmp</td><td>用来存放不同程序执行时产生的临时文件。</td></tr><tr><td>&#x2F;home</td><td>存放一般用户的个人目录</td></tr><tr><td>&#x2F;usr</td><td>一般用户程序安装所在的目录,用于安装各种应用程序</td></tr><tr><td>&#x2F;var</td><td>通常各种系统日志文件放在这里   动态变化的数据文件</td></tr></tbody></table><h2 id="面试—–软链接和硬链接区别"><a href="#面试—–软链接和硬链接区别" class="headerlink" title="面试—–软链接和硬链接区别"></a>面试—–软链接和硬链接区别</h2><p>在linux的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号inode。</p><p>（1）符号链接又叫软链接，和原文件不是一个文件。例如Windows的快捷方式，</p><p>作用特点：在指定路径查找某个文件访问快速便捷，删除源文件快捷方式不能访问</p><p>创建对象：文本文件目录文件都可以创建,并且可以跨文件系统</p><p>创建链接文件：ln -s 原文件 链接文件</p><p>如何判断是否是链接文件： l</p><p>（2）硬链接，</p><p>概念：多个文件名指向同一个Inode</p><p>作用特点：防止用户误删除，备份（仅对文件名备份）</p><p>创建对象：对目录文件不能创建,并且不可以跨文件系统</p><p>创建硬链接： ln 原文件  新文件  </p><p>多个文件名是否指向同一个节点号，以及硬链接次数是否改变</p><p>touch   FILENAME   创建文件</p><p>mkdir    DIRNAME   创建目录</p><p>rm   FILENAME    删除文件</p><p>rm -r  DIRNAME  删除目录文件</p><p>cat   FILENAME   查看文件</p><p>nano   FILENAME   编辑文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]#touch   aaa  在当前路径创建了aaa文件</span><br><span class="line">[root@www ~]#ln  -s  aaa   a.lnk  对aaa文件创建快捷文件叫a.lnk</span><br><span class="line">[root@www ~]#nano   aaa   编辑文件内容   ctrl-x -- y - enter</span><br><span class="line">[root@www ~]#cat   aaa      查看aaa文件的内容</span><br><span class="line">[root@www ~]#cat   a.lnk</span><br><span class="line">[root@www ~]#rm  aaa      删除aaa文件</span><br><span class="line">[root@www ~]#rm a.lnk</span><br><span class="line">[root@www ~]#mkdir   dir1   创建目录</span><br><span class="line">[root@www ~]#ln -s dir1  dir1.lnk</span><br><span class="line">[root@www ~]#rm -r dir1</span><br><span class="line">L</span><br><span class="line">注:</span><br><span class="line">[root@www ~]#ln -s  /root/dir   /dir1.lnk     将/root下的dir目录创建快捷文件在/目录下</span><br><span class="line"></span><br><span class="line">[root@www ~]#ln -s    dir    /dir2.lnk     有问题（将/dir目录创建快捷文件在/目录下）</span><br><span class="line">[root@www ~]# ll /</span><br><span class="line">lrwxrwxrwx.   1 root root    3 Feb 11 01:08 dir2.lnk -&gt; dir</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">创建硬链接只对文本件可以</span><br><span class="line">[root@www ~]# touch   b</span><br><span class="line">[root@www ~]# ln b  bbb</span><br><span class="line">[root@www ~]# ll -i</span><br><span class="line">33951783 -rw-r--r--. 2 root root    0 Feb 11 01:14 b</span><br><span class="line">33951783 -rw-r--r--. 2 root root    0 Feb 11 01:14 bbb</span><br></pre></td></tr></table></figure><p>***文件系统层级结构FHS</p><h2 id="date"><a href="#date" class="headerlink" title="date"></a>date</h2><p>date命令用于显示或设置系统的时间与日期，语法格式为：“ date [+指定的格式]”。</p><p>用户只需在强大的date命令后输入以“+”号开头的参数，即可按照指定格式来输出系统的时间或日期，这样在日常工作时便可以把备份数据的命令与指定格式输出的时间信息结合到一起。例如，把打包后的文件自动按照“年-月-日”的格式打包成“backup-2020-9-1.tar.gz”，用户只需要看一眼文件名称就能大概了解到每个文件的备份时间了。date命令中常见的参数格式及作用如表2-4所示。</p><p>表2-4                       date命令中的参数以及作用</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>%S</td><td>秒（00～59）</td></tr><tr><td>%M</td><td>分钟（00～59）</td></tr><tr><td>%H</td><td>小时（00～23）</td></tr><tr><td>%I</td><td>小时（00～12）</td></tr><tr><td>%m</td><td>月份（1~12）</td></tr><tr><td>%p</td><td>显示出AM或PM</td></tr><tr><td>%a</td><td>缩写的工作日名称（例如：Sun）</td></tr><tr><td>%A</td><td>完整的工作日名称（例如：Sunday）</td></tr><tr><td>%b</td><td>缩写的月份名称（例如：Jan）</td></tr><tr><td>%B</td><td>完整的月份名称（例如：January）</td></tr><tr><td>%q</td><td>季度（1~4）</td></tr><tr><td>%y</td><td>简写年份（例如：20）</td></tr><tr><td>%Y</td><td>完整年份（例如：2020）</td></tr><tr><td>%d</td><td>本月中的第几天</td></tr><tr><td>%j</td><td>今年中的第几天</td></tr><tr><td>%n</td><td>换行符（相当于按下回车键）</td></tr><tr><td>%t</td><td>跳格（相当于按下Tab键）</td></tr></tbody></table><p>按照默认格式查看当前系统时间的date命令如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@kongd ~]# date</span><br><span class="line">Sat Sep 5 09:13:45 CST 2020</span><br></pre></td></tr></table></figure><p>按照“年-月-日 小时:分钟:秒”的格式查看当前系统时间的date命令如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@kongd ~]# date &quot;+%Y-%m-%d %H:%M:%S&quot;</span><br><span class="line">2020-09-05 09:14:35</span><br></pre></td></tr></table></figure><p>将系统的当前时间设置为2020年11月1日8点30分的date命令如下所示：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@A /]# #date    月日时分年点秒</span><br><span class="line">[root@A /]# date   121210102021.10</span><br><span class="line">[root@kongd ~]# date -s &quot;20201101 8:30:00&quot;</span><br><span class="line">Sun Nov 1 08:30:00 CST 2020</span><br></pre></td></tr></table></figure><p>再次使用date命令并按照默认的格式查看当前的系统时间，如下所示：（月日时分年点秒）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@kongd ~]# date</span><br><span class="line">Sun Nov 1 08:30:08 CST 2020</span><br></pre></td></tr></table></figure><p>date命令中的参数%j可用来查看今天是当年中的第几天。这个参数能够很好地区分备份时间的新旧，即数字越大，越靠近当前时间。该参数的使用方式以及显示结果如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@kongd ~]# date &quot;+%j&quot;</span><br><span class="line">306</span><br></pre></td></tr></table></figure><h2 id="clock"><a href="#clock" class="headerlink" title="clock"></a>clock</h2><p>显示计算机的时间和日期 </p><h2 id="hwclock-s-系统时间向硬件时间同步"><a href="#hwclock-s-系统时间向硬件时间同步" class="headerlink" title="hwclock   -s   系统时间向硬件时间同步"></a>hwclock   -s   系统时间向硬件时间同步</h2><p>hwclock -w  硬件时间向系统时间同步</p><h2 id="timedatectl-status"><a href="#timedatectl-status" class="headerlink" title="timedatectl        status"></a>timedatectl        status</h2><p>timedatectl命令用于设置系统的时间，英文全称为：“time date control”，语法格式为：“ timedatectl [参数]”。</p><p>发现电脑时间跟实际不符？如果只差几分钟的话，我们可以直接调整，但如果差几个小时，那么除了调整当前的时间，还有必要检查下时区了，timedatectl命令中的参数以及作用：</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>status</td><td>显示状态信息</td></tr><tr><td>list-timezones</td><td>列出已知时区</td></tr><tr><td>set-time</td><td>设置系统时间</td></tr><tr><td>set-timezone</td><td>设置生效时区</td></tr></tbody></table><p>查看系统时间与时区：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@kongd ~]# timedatectl status</span><br><span class="line">               Local time: Sun 2020-09-06 19:51:22 CST</span><br><span class="line">           Universal time: Sun 2020-09-06 11:51:22 UTC</span><br><span class="line">                 RTC time: Sun 2020-09-06 19:51:21</span><br><span class="line">                Time zone: Asia/Shanghai (CST, +0800)</span><br><span class="line">System clock synchronized: no</span><br><span class="line">              NTP service: inactive</span><br><span class="line">          RTC in local TZ: no</span><br></pre></td></tr></table></figure><p>如果您查到的时区不是上海（Asia&#x2F;Shanghai），可以手动进行设置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@kongd ~]# timedatectl set-timezone Asia/Shanghai</span><br><span class="line">[root@kongd ~]# timedatectl get-timezone </span><br></pre></td></tr></table></figure><p>如果时间还是不正确，我们可以手动的修改系统日期：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@kongd ~]# timedatectl set-time 2021-05-18</span><br></pre></td></tr></table></figure><p>而如果想修改时间的话，也很简单：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@kongd ~]# timedatectl set-time 9:30</span><br><span class="line">[root@kongd ~]# date </span><br><span class="line">Tue May 18 09:30:01 CST 2021</span><br></pre></td></tr></table></figure><p>[root@localhost ~]# localectl set-locale LANG&#x3D;en_US</p><h2 id="文件管理命令"><a href="#文件管理命令" class="headerlink" title="文件管理命令"></a>文件管理命令</h2><h3 id="touch-创建文本文件"><a href="#touch-创建文本文件" class="headerlink" title="touch    创建文本文件"></a>touch    创建文本文件</h3><p>stat   FILENAME  查看文件详细属性</p><p>touch   [-option…]   FILENAME…</p><p>touch FILE1  FILE2   FILE3</p><p>touch &#x2F;{FILE1,FILE2,FILE3}</p><p>touch {a..c}{1..3}     a1 a2 a3  b1 b2 b3 c1 c2 c3</p><h3 id="mkdir-创建目录"><a href="#mkdir-创建目录" class="headerlink" title="mkdir    创建目录"></a>mkdir    创建目录</h3><p>mkdir [-options..]   DIRNAME </p><p>​            -p    parents   指定父目录创建（从左向右依次创建多级目录）</p><p>​            -v   verbose   详细信息   显示创建的详细结果</p><p>创建多级目录   mkdir   -pv     &#x2F;1&#x2F;2&#x2F;3&#x2F;4&#x2F;5</p><p>tree   树状显示目录结构</p><h3 id="rm-删除文件"><a href="#rm-删除文件" class="headerlink" title="rm 删除文件"></a>rm 删除文件</h3><p>rm    [-options]   FILENMAE&#x2F;DIRNAME…</p><p>​        -f    force  强制</p><p>​         -r   递归，递归删除目录文件</p><p>rm   FILE1   FILE2      </p><p>rm  f*    删除以f开头的所有文件</p><p>rm   *.txt</p><p>rm   *     删除当前目录下所有文本文件</p><p>rm -f</p><p>rm -r  d1</p><p>rm -rf   dd1</p><h3 id="du-查看系统文件占用磁盘大小-KB"><a href="#du-查看系统文件占用磁盘大小-KB" class="headerlink" title="du  查看系统文件占用磁盘大小   KB"></a>du  查看系统文件占用磁盘大小   KB</h3><p>-a    查看指定目录下所有文件占用的总大小，以及该目录下每个文件占用磁盘空间的大小</p><p>-s   只显示指定目录下所有文件占用磁盘的大小，不显示子目录</p><p>-h   显示大小可以进行单位转换</p><h3 id="mv-移动文件"><a href="#mv-移动文件" class="headerlink" title="mv   移动文件"></a>mv   移动文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mv  [-options]   源文件名...     目标路径</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# touch a</span><br><span class="line">[root@localhost ~]# ll</span><br><span class="line">-rw-r--r--. 1 root root    0 Feb 11 03:33 a</span><br><span class="line">[root@localhost ~]# mv a  /</span><br><span class="line">[root@localhost ~]# ll /</span><br><span class="line">total 28</span><br><span class="line">-rw-r--r--.   1 root root    0 Feb 11 03:33 a</span><br><span class="line">移动并改名</span><br><span class="line">[root@localhost ~]# mv f  /file   将f文件移动到/目录并改名为file （file文件在/目录下是不存在）</span><br><span class="line">文件重命名</span><br><span class="line">[root@localhost test]# mv a aaa</span><br></pre></td></tr></table></figure><h3 id="cp-复制文件"><a href="#cp-复制文件" class="headerlink" title="cp   复制文件"></a>cp   复制文件</h3><p>cp   [-options]   源文件名…     目标路径</p><p>​       -r    递归复制目录文件</p><p>​       -p   复制文件保持文件原属性</p><p>​      -a&#x3D;&#x3D;  -rp   复制目录保持目录文件的原属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost test]# cp -p  /test/a  /pub    复制/test/a文件到 /pub目录，复制保持文件原属性</span><br><span class="line">[root@localhost test]# ll /pub</span><br><span class="line">total 4</span><br><span class="line">-rw-r--r--. 1 root root 10 Feb 11 03:25 a</span><br><span class="line">[root@localhost test]# cp -rp /test/d1  /pub   </span><br><span class="line"></span><br><span class="line">[root@localhost test]# cp /test/a   /pub/a.txt      复制/test/a文件到 /pub目录并改名为a.txt</span><br><span class="line">[root@localhost test]# cp -r /test/d1  /pub/dir1</span><br></pre></td></tr></table></figure><h3 id="wget-下载文件"><a href="#wget-下载文件" class="headerlink" title="wget  下载文件"></a>wget  下载文件</h3><p>wget [-option…]    URL </p><p>​          -P   指定下载文件到指定路径    </p><p>​          -b   将下载进程放在后台运行</p><p>​  -c  断点续传</p><p>​          -t   指定下载尝试次数</p><p>​          -r   下载目录文件</p><p>​          -o</p><p>​          -O</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@localhost test]# wget http://mirrors.163.com/centos/8/infra/x86_64/infra-common/Packages/a/awscli-1.18.156-1.el8.noarch.rpm     ---把awscli-1.18.156-1.el8.noarch.rpm 下载到当前路径</span><br><span class="line"></span><br><span class="line">root@localhost test]# wget http://mirrors.163.com/centos/8/infra/x86_64/infra-common/Packages/a/awscli-1.18.156-1.el8.noarch.rpm    -P   /pub 把awscli-1.18.156-1.el8.noarch.rpm 下载到/pub目录</span><br></pre></td></tr></table></figure><h1 id="day03"><a href="#day03" class="headerlink" title="day03"></a>day03</h1><h2 id="查看目录文件：-ls"><a href="#查看目录文件：-ls" class="headerlink" title="查看目录文件： ls"></a>查看目录文件： ls</h2><h2 id="查看文本文件内容"><a href="#查看文本文件内容" class="headerlink" title="查看文本文件内容"></a>查看文本文件内容</h2><p>cat   将文件内容输出到终端，查看文件内容（正序）</p><p>​       -n   查看文件内容显示标号</p><p>tac  将文件内容输出到终端，查看文件内容（逆序显示）</p><p>more   一般对于大文件查看通过终端窗口可以分页显示，最后所有内容输出到终端查看显示</p><p>less   打开阅读，分页显示，退出需要通过q </p><p>​         ？关键字   或者  &#x2F;关键字</p><p>​            n 向上匹配关键字</p><p>​        N 向下匹配关键字</p><p>head    查看文件的前十行信息</p><p>​      -n 指定显示的行数   </p><p>​       -n   3</p><p>tail   查看文件的后十行信息</p><p>​     -n   3</p><p>​     -f  follow  追加显示文件内容   ctrl+c</p><p>tail -f   &#x2F;var&#x2F;log&#x2F;messages   </p><h2 id="文本编辑"><a href="#文本编辑" class="headerlink" title="文本编辑"></a>文本编辑</h2><h3 id="1-nano"><a href="#1-nano" class="headerlink" title="1.nano"></a>1.nano</h3><h3 id="2-vi-x2F-vim-文本编辑器"><a href="#2-vi-x2F-vim-文本编辑器" class="headerlink" title="2.vi &#x2F; vim  *** 文本编辑器"></a>2.vi &#x2F; vim  *** 文本编辑器</h3><p>终端最后一行</p><p>  显示新文件或者文件名几行几个字符或者没有任何信息   （执行便捷命令）</p><p>   –insert—   (编辑文件内容)</p><p> ：末行模式</p><p><img src="https://img-blog.csdnimg.cn/89c5b52568b541499f839af49c85bb50.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5ZCD5Lq66ZmIIw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p> 命令模式：</p><p>dd  删除光标所在行</p><p>d+enter 删除光标所在行和光标的下一行</p><p>dG   删除光标所在行以及文档尾的所有行</p><p>dgg   删除光标所在行以及文档首的所有行</p><p>d^    删除光标到行首的内容，不包含光标字符</p><p>d$   删除光标到行尾，包含的光标所在字符</p><p>x 删除光标所在字符</p><p>G 跳转到文档尾</p><p>gg  跳转到文档首</p><p>4G  跳转到第四行  </p><p>^    行首</p><p>$   行尾</p><p>yy  复制</p><p>4yy  复制从光标开始一共四行内容</p><p>cc 剪切</p><p>4cc   剪切从光标开始一共四行内容</p><p>p    粘贴（粘贴在光标所在的下一行）</p><p>u      向左撤销（返回上一次的编辑状态） </p><p>ctrl+r   重做（向右撤销，返回到近期编辑的状态）</p><p>插入模式：</p><p>a      在光标后插入内容</p><p>A     光标所在行的行尾</p><p>i       在光标前插入内容</p><p>I      光标所在行的行首</p><p>o      进入插入模式，在光标的下一行添加内容</p><p>O      进入插入模式，在光标的上一行添加内容</p><p>s     删除光标所在字符，进入插入模式</p><p>S   删除光标所在行，进入插入模式 </p><p>末行模式：</p><p>:q       退出</p><p>:q!     强制退出</p><p>:w      保存</p><p>:wq    保存退出 &#x3D;&#x3D; ZZ 命令模式</p><p>:wq!    强制保存退出</p><p>:10   跳转到第十行</p><p>:r    FILENMAE   将指定文件的内容读取到光标所在下一行</p><p>:%s   %匹配符，表示匹配所有行 s 替换命令   &#x2F;要替换的字符&#x2F;替换后的字符&#x2F;     替换的是每一行第一次匹配到的关键字     g 替换匹配到的所有关键字     %s &#x2F;0&#x2F;1&#x2F;g</p><p>:set nu    显示行号</p><p>:set nonu   取消行号</p><p>&#x2F;关键字   快速匹配关键字所在行的内容</p><p>:noh        取消高亮标记</p><p>vim  -o    &#x2F;etc&#x2F;passwd &#x2F;etc&#x2F;shadow    多个文件水平分割显示内容</p><p>​        -O   &#x2F;etc&#x2F;passwd   &#x2F;etc&#x2F;shadow    左右分屏显示文件内容</p><p>​              ctrl+w+w</p><p>vim +  &#x2F;etc&#x2F;passwd   打开该文件进入文档尾</p><h3 id="3-”-gt-”或“-gt-gt-”实现文件编辑"><a href="#3-”-gt-”或“-gt-gt-”实现文件编辑" class="headerlink" title="3.”&gt;”或“&gt;&gt;”实现文件编辑"></a>3.”&gt;”或“&gt;&gt;”实现文件编辑</h3><h4 id="echo-打印命令"><a href="#echo-打印命令" class="headerlink" title="echo   打印命令"></a>echo   打印命令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#echo  this is test    (标准输入输出命令)</span><br><span class="line">this is test   </span><br></pre></td></tr></table></figure><h5 id="引用变量"><a href="#引用变量" class="headerlink" title="$引用变量"></a>$引用变量</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#name=zhangsan</span><br><span class="line">#echo $name</span><br><span class="line">zhangsan</span><br><span class="line">$&#123;&#125;</span><br><span class="line">#echo  $&#123;name&#125;</span><br><span class="line">zhangsan</span><br></pre></td></tr></table></figure><h5 id="显示上一条命令的退出码-0成功-1-255错误状态"><a href="#显示上一条命令的退出码-0成功-1-255错误状态" class="headerlink" title="$?显示上一条命令的退出码   0成功  1-255错误状态"></a>$?显示上一条命令的退出码   0成功  1-255错误状态</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# echo $&#123;name&#125;</span><br><span class="line">zhangsan</span><br><span class="line">[root@localhost ~]# echo $?</span><br><span class="line">0</span><br><span class="line">[root@localhost ~]# haha</span><br><span class="line">bash: haha: command not found...</span><br><span class="line">Failed to search for file: Cannot update read-only repo</span><br><span class="line">[root@localhost ~]# echo $?</span><br><span class="line">127</span><br></pre></td></tr></table></figure><h5 id="管道符（将前面命令的标准输出作为后面命令的标准输入）—无名管道"><a href="#管道符（将前面命令的标准输出作为后面命令的标准输入）—无名管道" class="headerlink" title="|  管道符（将前面命令的标准输出作为后面命令的标准输入）—无名管道"></a>|  管道符（将前面命令的标准输出作为后面命令的标准输入）—无名管道</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">显示一个文件的第十行</span><br><span class="line">#head /etc/passwd | tail -1   </span><br><span class="line">eg:显示/etc/passwd文件20-25行的内容</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>**p 标识的管道文件（命名管道）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">开启两个终端</span><br><span class="line">1终端：</span><br><span class="line">#mkfifo /p1</span><br><span class="line">#echo 123 &gt; /p1</span><br><span class="line">2终端：</span><br><span class="line">#cat /p1</span><br><span class="line">123</span><br></pre></td></tr></table></figure><h4 id="三种引号区别"><a href="#三种引号区别" class="headerlink" title="三种引号区别"></a>三种引号区别</h4><p>‘ 单引号’    强引用，不识别引号中特殊字符的特殊含义   echo ‘$PS1’   </p><p>“ 双引号”   弱引用，识别特殊含义的字符， echo “$PS1”   —如果是变量单引和双引有区别</p><p>`反引号&#96;  命令替换符 &#x3D;&#x3D; $()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost /]# echo &quot;根目录下所有的文件\`ls`&quot;</span><br></pre></td></tr></table></figure><h3 id="“-gt-”-输出重定向符-将前面命令的输出结果写入指定文件"><a href="#“-gt-”-输出重定向符-将前面命令的输出结果写入指定文件" class="headerlink" title="“&gt;”   输出重定向符 (将前面命令的输出结果写入指定文件)"></a>“&gt;”   输出重定向符 (将前面命令的输出结果写入指定文件)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo   helloworld &gt; FILE      将helloworld输出结果通过输出重定向符写入指定文件，当文件不存在会创建该文件</span><br></pre></td></tr></table></figure><h4 id="“-gt-gt-”-追加重定向符"><a href="#“-gt-gt-”-追加重定向符" class="headerlink" title="“&gt;&gt;” 追加重定向符"></a>“&gt;&gt;” 追加重定向符</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo this is test &gt;&gt; FILENAME </span><br></pre></td></tr></table></figure><h4 id="lt-输入重定向符"><a href="#lt-输入重定向符" class="headerlink" title="&lt;    输入重定向符"></a>&lt;    输入重定向符</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat   &lt;  /etc/passwd</span><br><span class="line">head  &lt; /etc/passwd</span><br></pre></td></tr></table></figure><h3 id="4-文件编辑-lt-lt-终止结束符"><a href="#4-文件编辑-lt-lt-终止结束符" class="headerlink" title="4.文件编辑&lt;&lt;   终止结束符"></a>4.文件编辑&lt;&lt;   终止结束符</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost /]# cat &lt;&lt; EOF       查看内容，匹配终止结束符结束输入</span><br><span class="line">&gt; this is test                       --标准输入</span><br><span class="line">&gt; EOF                                --匹配到终止结束符，结束标准输入</span><br><span class="line">this is test                         --将前面标准输入的内容标准输出</span><br><span class="line"></span><br><span class="line">---------------------------</span><br><span class="line">[root@localhost /]# cat &lt;&lt; EOF &gt;  file2</span><br><span class="line">&gt; this is 1</span><br><span class="line">&gt; this is 2</span><br><span class="line">&gt; this is 3</span><br><span class="line">&gt; EOF</span><br><span class="line">[root@localhost /]# cat file2</span><br><span class="line">this is 1</span><br><span class="line">this is 2</span><br><span class="line">this is 3</span><br></pre></td></tr></table></figure><h4 id="文件描述符：0-文件标准输入符1标准（正确）输出描述符-2错误输出描述符"><a href="#文件描述符：0-文件标准输入符1标准（正确）输出描述符-2错误输出描述符" class="headerlink" title="文件描述符：0 文件标准输入符1标准（正确）输出描述符  2错误输出描述符"></a>文件描述符：0 文件标准输入符1标准（正确）输出描述符  2错误输出描述符</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat 0&lt; /etc/passwd</span><br><span class="line">cat fff  1&gt; file      ==  cat fff &gt; file</span><br><span class="line">cat fff   2&gt; file</span><br><span class="line">cat fff &amp;&gt; file == cat fff  1&gt; file 2&gt; file  == cat fff 1&gt; file 2&gt;&amp;1</span><br><span class="line">cat fff 1&gt; file 2&gt; /dev/null</span><br></pre></td></tr></table></figure><h2 id="文件内容处理相关命令—-行"><a href="#文件内容处理相关命令—-行" class="headerlink" title="文件内容处理相关命令—(行)"></a>文件内容处理相关命令—(行)</h2><h3 id="grep-文本过滤显示命令"><a href="#grep-文本过滤显示命令" class="headerlink" title="grep 文本过滤显示命令"></a>grep 文本过滤显示命令</h3><p>命令格式：   grep   [-options…]  关键字   文件名…</p><p>#grep    root   &#x2F;etc&#x2F;passwd     将&#x2F;etc&#x2F;passwd 文件中有root关键字的行打印显示</p><p>​             -v  反过滤，把没有关键字的行打印显示</p><p>​             -o   只显示匹配到的关键字</p><p>​            -c   显示匹配关键字的行数</p><p>​            -i   忽略大小写</p><p>​            -n  过滤显示行号</p><p>​            -w  按照单词过滤</p><p>​            -A 2   显示关键字以及下两行信息</p><p>​           -B 2   显示关键字以及上两行信息</p><p>​           -C 3   显示关键字以及上下三行信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">过滤指定文件/etc/passwd将文件中有nologin关键字的行写入login文件，并按照原文件的顺序写入。           </span><br><span class="line">[root@localhost /]# grep nologin /etc/passwd  &gt; login</span><br><span class="line">只显示一个配合文件的关键信息</span><br><span class="line">[root@localhost /]# grep -v ^# /etc/login.defs  | grep -v ^$</span><br><span class="line">判断/usr/bin是否存在passwd可执行文件</span><br><span class="line">[root@localhost /]# ll /usr/bin | grep -w passwd</span><br><span class="line">-rwsr-xr-x. 1 root root       34512 Aug 12  2018 passwd</span><br></pre></td></tr></table></figure><p>^   以什么开头    ^q     ^#</p><p>$  以什么结尾     a$   </p><p>^$   空白行</p><p>[]  定义取值范围，该范围内的任意单个字符   [1-9]   grep ^[0-9]   FILENAME  开头是0-9任意一个数字的行显示</p><p>[^]  ^取反    ^[^0-9]     ^[!0-9]</p><h3 id="cut-文本内容剪切命令"><a href="#cut-文本内容剪切命令" class="headerlink" title="cut 文本内容剪切命令"></a>cut 文本内容剪切命令</h3><p>​      -d   指定文件内容的分割符</p><p>​     -f    指定截取的字段      </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#cut -d : -f 1  /etc/passwd</span><br><span class="line">[root@localhost /]# date |cut -d &quot; &quot; -f 6</span><br><span class="line">2022</span><br></pre></td></tr></table></figure><p>​     -c   指定字符截取    cut -c 1-3  &#x2F;etc&#x2F;passwd</p><h3 id="wc-文本统计命令-行-单词书-字节数-文件名"><a href="#wc-文本统计命令-行-单词书-字节数-文件名" class="headerlink" title="wc   文本统计命令  行 单词书   字节数  文件名"></a>wc   文本统计命令  行 单词书   字节数  文件名</h3><p>-l   只统计行数</p><p>-w 只统计单词数</p><p>-c  统计字节数</p><p>-m  统计字符数</p><p>  当前系统共有多少用户</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost /]# echo 当前系统共有用户\`wc -l /etc/passwd | cut -d &quot; &quot;  -f 1`个 &gt; file</span><br><span class="line"> 当前系统共有用户44个</span><br></pre></td></tr></table></figure><h3 id="sort-文本排序-默认按照字符排序"><a href="#sort-文本排序-默认按照字符排序" class="headerlink" title="sort  文本排序  默认按照字符排序"></a>sort  文本排序  默认按照字符排序</h3><p>​    -n  按照数值大小升序显示</p><p>​    -r逆序显示</p><p>​    -t 指定分隔符</p><p>   -k 指定字段</p><p>   -u  unique  去重   &#x3D;&#x3D;sort a.txt | uniq</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost /]# sort -t : -k 3  -n /etc/passwd</span><br><span class="line">将/etc/passwd 文件内容通过：分割将第三个字段进行排序升序显示每一行内容</span><br></pre></td></tr></table></figure><h3 id="uniq-去重命令-重复行相邻"><a href="#uniq-去重命令-重复行相邻" class="headerlink" title="uniq   去重命令(重复行相邻)"></a>uniq   去重命令(重复行相邻)</h3><p>​-c   显示每一行重复的次数</p><p>   -d   只显示重复出现的行  </p><p>   -D 显示重复出现的所有行</p><h3 id="tr-字符替换"><a href="#tr-字符替换" class="headerlink" title="tr    字符替换"></a>tr    字符替换</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">echo abcde | tr  -t   a   1</span><br><span class="line">-c  反选定</span><br><span class="line">echo abcde | tr -c abc  0   把处理abc之外的字符替换为0字符</span><br><span class="line">   abc00</span><br><span class="line">-s    将连续重复的字符替换为单个字符</span><br><span class="line">echo   aaaaabcd | tr -s a 1   将连续的多个a字符替换为一个1字符</span><br><span class="line">-d  删除选定字符</span><br><span class="line">echo abcdef | tr -d abc</span><br></pre></td></tr></table></figure><h1 id="day04"><a href="#day04" class="headerlink" title="day04"></a>day04</h1><h2 id="文件查找4种方式"><a href="#文件查找4种方式" class="headerlink" title="文件查找4种方式"></a>文件查找4种方式</h2><p>whereis   查询范围通过系统环境变量路径搜索文件$PATH,所有的文件</p><p>which     查询范围通过系统环境变量路径搜索文件$PATH,找的是可执行文件（查找命令文件）</p><p>locate     全局搜索，但是需要在搜素前将系统文件导入数据库updatedb;查找速度快</p><p>*find       全局搜索文件。</p><p>注意事项：<br> 1）-prune 必须和 -path，-o 一起使用<br> 2）-prune -o 的顺序不 能调换<br> 3）-name等必须放在-prune -o后面才能使用</p><p>！  -a  -o</p><p> eg: <code>find . -path ./tmp -prune -o -name &quot;*.txt&quot;</code></p><p>[root@localhost test]# find . ! -name “out*” -a -name “*.txt”</p><p>find &#x2F; -name FILENAME  -type f</p><p>find   -name FILENAME</p><p>find ..&#x2F;..  -name FILENAME</p><p>-exec    -ok</p><p>#-exec   -ok   find 查找文件的结果通过 可以将前面命令的结果默认通过换 行识别为多个文件参数通过后面命令进行处理</p><p>find  &#x2F; -type  f -exec cp -p {}  &#x2F;test  ;</p><p>find  &#x2F; -type  f -ok cp -p {}  &#x2F;test  ;</p><p>[root@localhost test]# find . -type f  |xargs -I {}  cp {} &#x2F;test      </p><p>-I  将xargs的每项名称，一般是一行一行赋值给 {}，可以用 {} 代替。</p><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><h4 id="find命令格式："><a href="#find命令格式：" class="headerlink" title="find命令格式："></a>find命令格式：</h4><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find   path  -option  【 -print 】  【 -exec   -ok   |xargs  |grep  】 【  command  &#123;&#125; \;  】</span><br></pre></td></tr></table></figure></blockquote><h4 id="find命令的参数："><a href="#find命令的参数：" class="headerlink" title="find命令的参数："></a>find命令的参数：</h4><p>1）path：要查找的目录路径。 </p><pre><code>  ~ 表示$HOME目录   . 表示当前目录   / 表示根目录 </code></pre><p>2）print：表示将结果输出到标准输出。 </p><p>3）exec：对匹配的文件执行该参数所给出的shell命令。<br>      形式为command {} ;，注意{}与;之间有空格 </p><p>4）ok：与exec作用相同，<br>      区别在于，在执行命令之前，都会给出提示，让用户确认是否执行 </p><p>5）|xargs  与exec作用相同 ，起承接作用</p><p>区别在于 |xargs 主要用于承接删除操作 ，而 -exec 都可用 如复制、移动、重命名等</p><p>6）options ：表示查找方式</p><p>options常用的有下选项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-name   filename               #查找名为filename的文件</span><br><span class="line">-perm                                #按执行权限来查找</span><br><span class="line">-user    username             #按文件属主来查找</span><br><span class="line">-group groupname            #按组来查找</span><br><span class="line">-mtime   -n +n                   #按文件更改时间来查找文件，-n指n天以内，+n指n天以前</span><br><span class="line">-atime    -n +n                   #按文件访问时间来查找文件，-n指n天以内，+n指n天以前</span><br><span class="line">-ctime    -n +n                  #按文件创建时间来查找文件，-n指n天以内，+n指n天以前</span><br><span class="line">-nogroup                          #查无有效属组的文件，即文件的属组在/etc/groups中不存在</span><br><span class="line">-nouser                            #查无有效属主的文件，即文件的属主在/etc/passwd中不存</span><br><span class="line">-type    b/d/c/p/l/f             #查是块设备、目录、字符设备、管道、符号链接、普通文件</span><br><span class="line">-size      n[c]                    #查长度为n块[或n字节]的文件</span><br><span class="line">-mount                            #查文件时不跨越文件系统mount点</span><br><span class="line">-follow                            #如果遇到符号链接文件，就跟踪链接所指的文件</span><br><span class="line">-prune                            #忽略某个目录</span><br></pre></td></tr></table></figure><h4 id="下面通过一些简单的例子来介绍下find的常规用法："><a href="#下面通过一些简单的例子来介绍下find的常规用法：" class="headerlink" title="下面通过一些简单的例子来介绍下find的常规用法："></a>下面通过一些简单的例子来介绍下find的常规用法：</h4><p>1、按名字查找 </p><pre><code>  在当前目录及子目录中，查找大写字母开头的txt文件    $ find . -name &#39;[A-Z]*.txt&#39; -print 　　  在/etc及其子目录中，查找host开头的文件   $ find /etc -name &#39;host*&#39; -print 　　  在$HOME目录及其子目录中，查找所有文件 　　  $ find ~ -name &#39;*&#39; -print   在当前目录及子目录中，查找不是out开头的txt文件 　　  $ find . -name &quot;out*&quot; -prune -o -name &quot;*.txt&quot; -print </code></pre><p>2、按目录查找 　　</p><pre><code>  在当前目录除aa之外的子目录内搜索 txt文件 　　  $ find . -path &quot;./aa&quot; -prune -o -name &quot;*.txt&quot; -print 　　  在当前目录及除aa和bb之外的子目录中查找txt文件 　　  $ find . −path′./dir0′−o−path′./dir1′−path′./dir0′−o−path′./dir1′ -a -prune -o -name &#39;*.txt&#39; -print</code></pre><p>注意：在1、2处都需要加空格，否则会出现如图所示的报错</p><pre><code>       在3处加不加 -a都可以  在当前目录，不再子目录中，查找txt文件   $ find . ! -name &quot;.&quot; -type d -prune -o -type f -name &quot;*.txt&quot; -print  或者   find . -name *.txt -type f -print</code></pre><p>3、按权限查找 　　</p><pre><code>  在当前目录及子目录中，查找属主具有读写执行，其他具有读执行权限的文件 　　  $ find . -perm 755 -print   查找用户有写权限或者组用户有写权限的文件或目录  find ./ -perm /220  find ./ -perm /u+w,g+w  find ./ -perm /u=w,g=w</code></pre><p>4、按类型查找 　（b&#x2F;d&#x2F;c&#x2F;p&#x2F;l&#x2F;f ）　</p><pre><code>  在当前目录及子目录下，查找符号链接文件 　　  $ find . -type l -print </code></pre><p>5、按属主及属组 　　</p><pre><code>  查找属主是www的文件 　　  $ find / -user www -type f -print 　　  查找属主被删除的文件   $ find / -nouser -type f -print 　　  查找属组 mysql 的文件   $ find / -group mysql -type f -print 　　  查找用户组被删掉的文件   $ find / -nogroup -type f -print </code></pre><p>6、按时间查找 　　</p><pre><code>  查找2天内被更改过的文件    $ find . -mtime -2 -type f -print 　　  查找2天前被更改过的文件   $ find . -mtime +2 -type f -print 　　  查找一天内被访问的文件   $ find . -atime -1 -type f -print 　　  查找一天前被访问的文件   $ find . -atime +1 -type f -print 　　  查找一天内状态被改变的文件   $ find . -ctime -1 -type f -print 　　  查找一天前状态被改变的文件   $ find . -ctime +1 -type f -print 　　  查找10分钟以前状态被改变的文件   $ find . -cmin +10 -type f -print </code></pre><p>7、按文件新旧 　　</p><pre><code>  查找比 aa.txt 新的文件   $ find . -newer &quot;aa.txt&quot; -type f -print 　　  查找比 aa.txt 旧的文件   $ find . ! -newer &quot;aa.txt&quot; -type f -print 　　  查找比aa.txt新，比bb.txt旧的文件   $ find . -newer &#39;aa.txt&#39; ! -newer &#39;bb.txt&#39; -type f -print </code></pre><p>8、按大小查找 　　</p><pre><code>  查找超过1M的文件   $ find / -size +1M -type f -print 　　  查找等于6字节的文件   $ find . -size 6c -print 　　  查找小于32k的文件   $ find . -size -32k -print </code></pre><p>9、执行命令 　　</p><pre><code>  1）查找 del.txt 并删除，删除前提示确认   $ find . -name &#39;del.txt&#39; -ok rm &#123;&#125; \; 　　 2） 查找 aa.txt 并备份为aa.txt.bak   $ find . -name &#39;aa.txt&#39; -exec cp &#123;&#125; &#123;&#125;.bak \; 3）查当前目录下的所有普通文件# find . -type f -exec ls -l &#123;&#125; \; </code></pre><p>   -rw-r–r–    1 root      root         34928 2003-02-25   .&#x2F;conf&#x2F;httpd.conf<br>   -rw-r–r–    1 root      root         12959 2003-02-25   .&#x2F;conf&#x2F;magic<br>   -rw-r–r–    1 root      root          180 2003-02-25   .&#x2F;conf.d&#x2F;README </p><p>   查当前目录下的所有普通文件，并在 - exec 选项中使用 ls -l 命令将它们列出</p><p>   4）在 &#x2F;logs 目录中查找更改时间在5日以前的文件并删除它们<br>   $ find logs -type f -mtime +5 -exec   -ok   rm {} ;</p><p>   5）查询当天修改过的文件</p><p>  # find  .&#x2F;  -mtime  -1  -type f  -exec  ls -l  {} ;</p><p>   6）查询文件并询问是否要显示</p><pre><code># find   ./   -mtime   -1   -type f   -ok   ls -l   &#123;&#125; \;  &lt; ls … ./classDB.inc.php &gt; ? y-rw-r–r–    1 cnscn    cnscn       13709   1月 12 12:22 ./classDB.inc.php# find   ./   -mtime   -1   -type f   -ok   ls -l   &#123;&#125; \;  &lt; ls … ./classDB.inc.php &gt; ? n</code></pre><h2 id="文件压缩解压缩"><a href="#文件压缩解压缩" class="headerlink" title="文件压缩解压缩"></a>文件压缩解压缩</h2><p>tar</p><p>-c</p><p>-x</p><p>-t</p><p>-v</p><p>-f</p><p>-j</p><p>-J</p><p>-z</p><p>-C</p><p>文件传输：</p><p>window –linux     xftp实现文件传送   </p><p>​                      rz FILENAME 接收      sz   传送       —lrzsz包</p><p>linux–linux </p><p>文件发送：  scp  mima  <a href="mailto:&#114;&#x6f;&#111;&#x74;&#64;&#x31;&#57;&#x32;&#x2e;&#x31;&#54;&#56;&#46;&#50;&#50;&#x30;&#x2e;&#x31;&#x35;&#52;">&#114;&#x6f;&#111;&#x74;&#64;&#x31;&#57;&#x32;&#x2e;&#x31;&#54;&#56;&#46;&#50;&#50;&#x30;&#x2e;&#x31;&#x35;&#52;</a>:&#x2F;root</p><p>文件接收：  scp    <a href="mailto:&#x72;&#111;&#111;&#116;&#64;&#x31;&#57;&#x32;&#x2e;&#49;&#54;&#56;&#x2e;&#50;&#50;&#48;&#x2e;&#49;&#x35;&#x34;">&#x72;&#111;&#111;&#116;&#64;&#x31;&#57;&#x32;&#x2e;&#49;&#54;&#56;&#x2e;&#50;&#50;&#48;&#x2e;&#49;&#x35;&#x34;</a>:&#x2F;root&#x2F;mima   &#x2F;passwd</p><p>​                     scp  -r</p><p>​                 [root@162 ~]#    sftp  192.168.220.154  发起sftp的远程连接</p><p>​                             sftp&gt;        put file</p><p>​                              sftp&gt;        get  filename</p><p>​             </p><p>文件管理名</p><p>touch  &gt;  &gt;&gt;   vi&#x2F;vim   nano</p><p>mkdir </p><p>rm -rf</p><p>cp </p><p>mv</p><p>wget </p><p>cat   tac  more  less  head tail   (vim nano) grep </p><p>vim****   nano  &gt; &gt;&gt;   </p><p>echo this is test &gt; a.txt</p><p>cat &lt;<EOF> file</EOF></p><p>grep    wc   cut   sort  uniq  tr</p><p>whereis   </p><p>which</p><p>locate</p><p>find****</p><p>tar </p><p>bash 特性</p><h3 id="1-bzip-and-bzip2"><a href="#1-bzip-and-bzip2" class="headerlink" title="1.bzip and bzip2"></a>1.bzip and bzip2</h3><p><img src="/post/38c0576c/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220215174723597.png" alt="image-20220215174723597"></p><p><strong>用途：</strong><br>制作压缩文件、解开压缩文件</p><p><strong>命令格式：</strong></p><p><strong>gzip [-9] 文件名…<br>bzip2 [-9] 文件名…<br>gzip -d .gz格式的压缩文件<br>bzip2 -d *.bz2格式的压缩文件</strong></p><p><img src="/post/38c0576c/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220215174739146.png" alt="image-20220215174739146"></p><p><strong>常用命令选项：</strong><br>-9：表示高压缩比，多在创建压缩包时用<br>-d：用于解开已经压缩过的文件</p><h3 id="2-tar"><a href="#2-tar" class="headerlink" title="2.tar"></a>2.tar</h3><p><strong>用途：</strong><br>制作归档文件、释放归档文件<br><strong>格式：</strong></p><p><strong>tar [选项]… 归档文件名 源文件或目录<br>tar [选项]… 归档文件名 [-C 目标目录]</strong></p><p><img src="/post/38c0576c/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220215174831834.png" alt="image-20220215174831834"></p><h2 id="alias-定义命令别名"><a href="#alias-定义命令别名" class="headerlink" title="alias  定义命令别名"></a>alias  定义命令别名</h2><p>alias 别名&#x3D;”命令本身”</p><p> l临时别名，仅在当前终端运行状态下生效</p><p>vim &#x2F;etc&#x2F;bashrc          1–exit    2–bash  3–source   &#x2F;etc&#x2F;bashrc</p><p>永久别名对系统所有用户都生效</p><p>vim ~&#x2F;.bashrc</p><p>永久别名仅对当前用生效</p><p><strong>定义别名</strong><br>定义别名的方法很简单，格式如下所示：</p><p>alias [name[&#x3D;value]]</p><p>这里需要注意的是：</p><p>等号（&#x3D;）前后不能有空格，否则就会出现语法错误了。<br>如果value中有空格或tab，则value一定要使用引号（单、双引号都行）括起来。</p><p>了解了别名的基础知识之后，我们来看一个定义别名的例子：</p><p>[roc@roclinux ~]$ alias vi&#x3D;’vim’<br>这个例子定义了一个 vim 命令的别名，以后，当我们执行 vi 命令时，其实真正执行的是 vim 命令。</p><p><strong>如何查看别名</strong><br>如果太热衷于设置别名，那么你就会面临着要记住很多别名的困扰，因此，学会查看所有已设置的别名，就显得尤为重要了。</p><p>查看别名的方法也很简单，直接输入 alias 命令，不加任何选项和参数即可：<br><img src="/post/38c0576c/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220215174945311.png" alt="image-20220215174945311"></p><h2 id="命令缓存"><a href="#命令缓存" class="headerlink" title="命令缓存"></a>命令缓存</h2><p>1.建立命令缓存</p><p>执行命令自动在缓存建立</p><p>hash -p  &#x2F;usr&#x2F;bin&#x2F;touch    touch </p><p>hash -p  &#x2F;usr&#x2F;bin&#x2F;touch    chuangjian</p><p>2.删除缓存</p><p>hash  -d    chuangjian</p><p>hash -r   清空所有缓存</p><p>exit终端</p><p>缓存特点：    命令缓存—alias–名令文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">[root@162 ~]# hash</span><br><span class="line">hitscommand</span><br><span class="line">   3/usr/bin/vim</span><br><span class="line">   1/usr/bin/cat</span><br><span class="line">   1/usr/sbin/pidof</span><br><span class="line">   2/usr/bin/su</span><br><span class="line">[root@162 ~]# echo $PATH</span><br><span class="line">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin</span><br><span class="line">[root@162 ~]# which touch</span><br><span class="line">/usr/bin/touch</span><br><span class="line">[root@162 ~]# touch a</span><br><span class="line">[root@162 ~]# hash</span><br><span class="line">hitscommand</span><br><span class="line">   3/usr/bin/vim</span><br><span class="line">   1/usr/bin/cat</span><br><span class="line">   1/usr/bin/touch</span><br><span class="line">   1/usr/sbin/pidof</span><br><span class="line">   2/usr/bin/su</span><br><span class="line">[root@162 ~]# touch /usr/bin/touch     ---=优先通过缓存匹配</span><br><span class="line">[root@162 ~]# hash</span><br><span class="line">hitscommand</span><br><span class="line">   3/usr/bin/vim</span><br><span class="line">   1/usr/bin/cat</span><br><span class="line">   2/usr/bin/touch</span><br><span class="line">   1/usr/sbin/pidof</span><br><span class="line">   2/usr/bin/su</span><br><span class="line"></span><br><span class="line">[root@162 ~]# mv /usr/bin/touch /usr/local/bin</span><br><span class="line">[root@162 ~]# touch b</span><br><span class="line">bash: /usr/bin/touch: No such file or directory</span><br><span class="line">[root@162 ~]# hash -d touch </span><br><span class="line">[root@162 ~]# hash</span><br><span class="line">hitscommand</span><br><span class="line">   3/usr/bin/vim</span><br><span class="line">   1/usr/bin/cat</span><br><span class="line">   1/usr/sbin/pidof</span><br><span class="line">   3/usr/bin/mv</span><br><span class="line">   2/usr/bin/su</span><br><span class="line">[root@162 ~]# touch b     ----不存在缓存以及别名执行环境变量路径下的命令文件</span><br><span class="line">[root@162 ~]# hash -p /usr/bin/tac chakan    --别名</span><br></pre></td></tr></table></figure><h2 id="history"><a href="#history" class="headerlink" title="history"></a>history</h2><p>展示数行之前的历史命令。命令编号前面前缀上感叹号可以再次执行这个命令。如果我们需要编辑历史列表中的命令，我们可以按下 Ctrl + r 并输入与命令相关的第一个字符。我们可以看到的命令会自动补全，可以根据我们目前的需要来编辑它：</p><p>命令列表会保存在一个叫 .bash_history 的文件里。history 命令是一个非常有用的用于减少输入次数的工具，特别是进行命令行编辑的时候。默认情况下，bash 保留最后输入的500个命令，不过可以通过修改 HISTSIZE 环境变量来增加:<br><img src="/post/38c0576c/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220215174529724.png" alt="image-20220215174529724"></p><p>Linux history 命令</p><p>但上述变化，在我们的下一次启动不会保留。为了保持 HISTSIZE 变量的变化，我们需要通过手工修改文件编辑：</p><ol><li>#要设置 history 长度，请看bash(1)文档中的 HISTSIZE 和 HISTFILESIZE</li><li>HISTSIZE&#x3D;1000</li></ol><p>重要： 我们的更改不会立刻生效，除非我们重启了 shell 。</p><h1 id="day05"><a href="#day05" class="headerlink" title="day05"></a>day05</h1><h2 id="用户组"><a href="#用户组" class="headerlink" title="用户组"></a>用户组</h2><p>AAA</p><h3 id="用户类别"><a href="#用户类别" class="headerlink" title="用户类别"></a>用户类别</h3><p>管理员    只有一个UID&#x3D;0</p><p>普通用户    1-65535   </p><p>​      系统用户   1-999</p><p>​             系统管理账号：1-200</p><p>​              系统普通账号 ：  201-999</p><p>​       一般用户   1000-</p><p>公有模式      users        ** 私有模式  用户在自己的组当中（创建用户会创建一个和用户同名的组）</p><h5 id="1-用户创建"><a href="#1-用户创建" class="headerlink" title="1.用户创建"></a>1.用户创建</h5><p>useradd &#x3D;&#x3D; adduser   添加用户或者更新添加用户的基本信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#useradd    USERNAME</span><br><span class="line">#useradd -u 1111 -g 1000 -d  /test/user2 -s /sbin/nologin   user2  </span><br><span class="line"> 创建用户命令          （选项）                                要创建的用户名</span><br><span class="line">-c     更改描述名称</span><br><span class="line">-u    指定UID</span><br><span class="line">-g   指定用户的基本组（主组）</span><br><span class="line">-G   指定用户的附加组</span><br><span class="line">-d   指定家目录</span><br><span class="line">-s  指定shell字段</span><br><span class="line">-r    指定系统用户</span><br></pre></td></tr></table></figure><h5 id="2-查看系统中用户信息"><a href="#2-查看系统中用户信息" class="headerlink" title="2.查看系统中用户信息"></a>2.查看系统中用户信息</h5><p>1)用户的配置文件（&#x2F;etc&#x2F;passwd）</p><p>用户名:密码占位符： 用户唯一id值：基本组的组id：描述字段（注释）：家目录：shell</p><p>2)id 判断系统某一个用户是否存在</p><p>3)grep ^USERNAME   &#x2F;etc&#x2F;passwd</p><h5 id="3-用户修改"><a href="#3-用户修改" class="headerlink" title="3.用户修改"></a>3.用户修改</h5><p>usermod  [options]  LOGIN</p><p>-c   修改描述名称</p><p>-d 指定家目录</p><p>-g  修改基本组</p><p>-G  修改附属组    会将用户以指定的附属组进行修改</p><p>-l  修改登录名称</p><p>-L  锁定用户</p><p>-s  修改shell</p><p>-u  修改UID</p><p>-U 解锁</p><h5 id="4-删除用户"><a href="#4-删除用户" class="headerlink" title="4.删除用户"></a>4.删除用户</h5><p>userdel -r  USERNAME  完整删除一个用户相关的所有信息</p><p>注： 也会删除用户的基本组，但是如果基本组当中存在的其他的用户通过userdel -r 不能删除该基本组</p><p>userdel USERNAME 只删除用户配置文件相关信息，如果要完整删除用户需要手动删除用户的家目录&#x2F;home&#x2F;USERNAME和邮件文件&#x2F;var&#x2F;spool&#x2F;mail&#x2F;USERNAME</p><h4 id="组类别"><a href="#组类别" class="headerlink" title="组类别"></a>组类别</h4><p>管理组     只有一个</p><p>普通组       1-65535</p><p>​         基本组（默认组、主组）   一个用户只有一个基本组</p><p>​          附属组     一个用户可以有多</p><h5 id="1-创建组"><a href="#1-创建组" class="headerlink" title="1.创建组"></a>1.创建组</h5><p>groupadd  GROUPNAME</p><p>​       -g   指定gid</p><p>​      -r    指定为系统组（1-999）</p><p>groupadd  -g 456   -r  GROUPNAME</p><h5 id="2-查看组信息"><a href="#2-查看组信息" class="headerlink" title="2.查看组信息"></a>2.查看组信息</h5><p>1）查看组配置文件&#x2F;etc&#x2F;group</p><p> 组名:组密码占位符:组id:组中的用户名（把当前组作为附属组的用户名）</p><p>2）grep ^USERNAME  &#x2F;etc&#x2F;group</p><h5 id="3）组修改"><a href="#3）组修改" class="headerlink" title="3）组修改"></a>3）组修改</h5><p>groupmod   修改组信息</p><p>-g  修改组id</p><p>-n 修改组名</p><p>groupmod -n grp1  g1       将g1组名改为grp1</p><h5 id="4）删除组"><a href="#4）删除组" class="headerlink" title="4）删除组"></a>4）删除组</h5><p>groupdel  GROUPNAME</p><p>只能删除附属组组当中有用户也可以删除，不能删除基本组</p><h4 id="用户密码管理"><a href="#用户密码管理" class="headerlink" title="用户密码管理"></a>用户密码管理</h4><h5 id="1-设置密码"><a href="#1-设置密码" class="headerlink" title="1.设置密码"></a>1.设置密码</h5><p>passwd    USERNAME   用户密码修改，设置用户密码</p><p>passwd   &#x2F; chage更改密码参数</p><p>​     -l   锁定用户密码</p><p>​     -u  解锁用户</p><p>​    -x</p><p>​    -n</p><p>​    -w</p><p>​    -d</p><p>[root@162 ~]# echo mima | passwd –stdin root<br>Changing password for user root.<br>passwd: all authentication tokens updated successfully.</p><p>chpasswd   批量更改</p><p>echo root:mima | chpasswd</p><p>vim file</p><p>root：mima1</p><p>zhangsan:mima2</p><p>cat file | chpasswd </p><p>chpasswd &lt;  file</p><h5 id="2-查看密码信息-x2F-etc-x2F-shadow"><a href="#2-查看密码信息-x2F-etc-x2F-shadow" class="headerlink" title="2.查看密码信息   &#x2F;etc&#x2F;shadow"></a>2.查看密码信息   &#x2F;etc&#x2F;shadow</h5><p>用户名：密码：最后一次设置密码的时间（1970.1.1开始统计到设置密码的天数）：密码最短时间：最长：警告时间：宽限时间：过期精确时间（1970.1.1开始统计到密码失效的天数）</p><h4 id="组密码管理"><a href="#组密码管理" class="headerlink" title="组密码管理"></a>组密码管理</h4><h5 id="1）设置组密码"><a href="#1）设置组密码" class="headerlink" title="1）设置组密码"></a>1）设置组密码</h5><p>gpasswd  GROUPNAME</p><p>-a  将指定用户拉到某一个组</p><p>-d  从组中移除用户</p><p>-M  设置组成员列表</p><p>-r  删除组密码</p><p>-R 锁定组密码（解锁–重置组密码）</p><p>-A  设置组长（可以将添加，删除组中用户）</p><p>newgrp  切换新组</p><p>注：作为管理员切换组不需要组密码，如果是组成员也不需要验证组密码</p><h5 id="2）查看组密码-x2F-etc-x2F-gshadow"><a href="#2）查看组密码-x2F-etc-x2F-gshadow" class="headerlink" title="2）查看组密码&#x2F;etc&#x2F;gshadow"></a>2）查看组密码&#x2F;etc&#x2F;gshadow</h5><p>组名：组密码：组长：组成员</p><h5 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h5><p>useradd  haha   &#x2F;etc&#x2F;passwd   &#x2F;etc&#x2F;shadow &#x2F;etc&#x2F;group  &#x2F;etc&#x2F;gshadow  </p><p>​                             &#x2F;home&#x2F;USERNAME  家目录</p><p>​                            &#x2F;var&#x2F;spool&#x2F;mail&#x2F;USERNAME  邮件文件</p><p>默认定义用户添加的相关参数值：&#x2F;etc&#x2F;login.defs   &#x2F;etc&#x2F;default&#x2F;useradd</p><p>实验：创建学习组1，学习组2 ；他们的组gid分别为1111,2222，添加成员并将uid为1088，</p><p>和uid为1066的成员为两组的组长，其中一组组长有一个‘外号’laoda。</p><p>不同学习组进入需要密码才能进入（设置密码）；即使密码泄露也不希望组之外的成员进入。</p><p>groupadd -g 1111 g1</p><p>groupadd g2</p><p>groupmod -g 2222 g2</p><p>useradd u1</p><p>usermod -u 1088 u1</p><p>useradd u2</p><p>usermod -u 1066 u2</p><p>gpasswd -a u1 g1</p><p>gpasswd -a u2 g2</p><p>gpasswd -A u1 g1</p><p>gpasswd -A u2 g2</p><p>usermod -c laoda u1</p><p>gpasswd g1</p><p>gpasswd g2</p><p>gpasswd -R g1</p><p>gpasswd -R g2</p><p>kali</p><h4 id="sudo用户授权"><a href="#sudo用户授权" class="headerlink" title="sudo用户授权"></a>sudo用户授权</h4><p>通过管理员给普通用户下发执行命令的特权</p><p>vim  &#x2F;etc&#x2F;sudoers</p><p>redhat  ALL&#x3D;(ALL)  NOPASSWD: &#x2F;usr&#x2F;sbin&#x2F;useradd</p><p>提权用户     提权用户所在的主机名&#x3D;（授权用户）  提权不需要密码验证:  提取可执行的命令</p><p>$sudo  useradd u1</p><p><strong>su</strong></p><p>su  redhat   </p><p>su - redhat </p><p><strong>w | who | users查看系统通过哪些用户基于终端登录</strong></p><p><strong>last 查看当前主机近期时间里通过哪些用户验证登录当前主机</strong></p><p><strong>whoami  查看当前终端通过哪一个用户身份登录</strong></p><h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><p>[root@162 ~]# ll<br>total 40<br>-rw-r–r–. 1 root root    0 Feb 13 21:15 111</p><h3 id="系统权限在文件中标识"><a href="#系统权限在文件中标识" class="headerlink" title="系统权限在文件中标识"></a>系统权限在文件中标识</h3><p>2-11</p><p>2-10   9个字符标识一般权限r  w  x</p><p>​9个字符每三个字符一组标记权限      所属用户    所属组     其他用户</p><p>​用户如何匹配对应文件的权限</p><p>​    111该文件所属用户是root用户，对于root用户对111文件现在拥有rw-</p><p>11 扩展权限标识符    .没有扩展权限   +有扩展权限</p><h3 id="系统当中权限的描述方式："><a href="#系统当中权限的描述方式：" class="headerlink" title="系统当中权限的描述方式："></a>系统当中权限的描述方式：</h3><p>字符形式：  rwx  （系统权限的标识）</p><p>数值形式：  4&#x3D;r 2&#x3D;w  1&#x3D;x       对于111文件所属用户root他的权限6    所属组的权限4   其他用户的权限4</p><p>（用户方便描述权限）</p><h3 id="系统中文件默认的权限值"><a href="#系统中文件默认的权限值" class="headerlink" title="系统中文件默认的权限值"></a>系统中文件默认的权限值</h3><p>**权限掩码：（权限过滤符）  umask   &#x3D; 022       033</p><p>目录最高权限：777                              755          744</p><p>文本文件的权限： 666                          644          644</p><p>666</p><p>rw-   rw-   rw-</p><p>033                  0    4   4           0 5 5</p><p>—    -wx   -wx                                               r-x    r-x</p><p>rw-   r–     r– </p><p>6   44</p><h3 id="权限修改：chmod"><a href="#权限修改：chmod" class="headerlink" title="权限修改：chmod"></a>权限修改：chmod</h3><p>chmod    权限     FILENAME（管理员可以更改所有用户创建文件的权限；但是普通用户只能更改自己创建的文件（文件的所属用户是当前用户））</p><p>字符形式: chmod   u&#x3D;rwx,g+wx,o-x  a       chmod ugo&#x3D;rw  FILENAME    &#x3D;&#x3D; chmod a&#x3D;rw FILENAME</p><p>数值形式:   chmod 644 FILENAME              chmod 66   FILENAME    066</p><p>chown  更改文件所属用户    chown   所属用户名   FILENAME      chown  u1  a     chown u2:u2  a   chown :u4  a</p><p>chgrp    更改文件的所属组   chgrp   所属组（组名）   FIELNAME</p><h3 id="权限匹配规则：（没有扩展权限时）"><a href="#权限匹配规则：（没有扩展权限时）" class="headerlink" title="权限匹配规则：（没有扩展权限时）"></a>权限匹配规则：（没有扩展权限时）</h3><p>标准定义： 安全上下文</p><p>通过发起者用户执行一个可执行文件（命令），匹配一个目标文件时，判断执行文件的发起者身份是否是目标文件的的所属用户，如果是直接匹配所属用户权限，如果不是开始匹配是否是文件所组的用户如果是直接匹配所属组权限，不是则直接匹配其他用户的权限。</p><p>（首先判断发起用户，是否是文件的所属用户，如果是直接匹配所属用户权限，如果不是开始匹配是否是文件所组的用户如果是直接匹配所属组权限，不是则直接匹配其他用户的权限。）</p><p>文件权限字符含义</p><p>d目录:    r    查看（列出）目录下的文件信息      ls</p><p>​              w    能够在指定目录中创建文件   touch   &gt; &gt;&gt; vim nano    mkdir   mv  cp    （对于普通用户如果没有写权限，则不能删除该目录下的文件）</p><p>​  x     打开该目录     cd</p><p>-文本文件:  r    查看该文件的内容</p><p>​w    编辑文件内容</p><p>​x     运行文本内容（命令文件）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[redhat@162 ~]$ cd /root</span><br><span class="line">-bash: cd: /root: Permission denied</span><br><span class="line">作为redhat对于/root目录没有执行权限</span><br><span class="line"></span><br><span class="line">[root@162 /]# ll /root  -d        redhat用户对于/root是其他用户，需要其他用户位加上执行权限</span><br><span class="line">dr-xr-x---. 18 root root 4096 Feb 16 21:35 /root</span><br><span class="line">[root@162 /]# chmod o+x /root</span><br><span class="line">[root@162 /]# su - redhat</span><br><span class="line"></span><br><span class="line">[redhat@162 ~]$ cd /root</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@162 /]# touch file</span><br><span class="line">[root@162 /]# ll</span><br><span class="line">-rw-r--r--.   1 root root    0 Feb 16 22:03 file</span><br><span class="line">[redhat@162 /]$ cat file</span><br><span class="line"></span><br><span class="line">[redhat@162 /]$ echo this is red1  &gt;file</span><br><span class="line">-bash: file: Permission denied</span><br><span class="line">[root@162 /]# chmod o+w file</span><br><span class="line">[redhat@162 /]$ echo this is red1 &gt; file</span><br><span class="line">[redhat@162 /]$ cat file</span><br><span class="line">this is red1</span><br><span class="line"></span><br><span class="line">[redhat@162 /]$ ./file</span><br><span class="line">-bash: ./file: Permission denied</span><br><span class="line">[root@162 /]# chmod o+x file</span><br><span class="line">[redhat@162 /]$ ./file</span><br><span class="line">./file: line 1: this: command not found</span><br></pre></td></tr></table></figure><h3 id="特殊权限"><a href="#特殊权限" class="headerlink" title="特殊权限"></a>特殊权限</h3><p>chmod  u+s,o+s,o+t   FILENAME   是在文件对应的执行位显示，如果文件默认没有执行权限特殊权限大写标识，如果有特殊权限特殊权限字符小写标识。</p><p>chmod    7644  FILENAME   特殊权限是7(u+s&#x3D;4,g+s&#x3D;2.o+t&#x3D;1) 644标准权限</p><p>u+s    &#x3D;4     所属用户的强制位（对于可执行文件的所属用户禁锢）  —1.对可执行文件设置有意义</p><p>g+s    &#x3D;2     所属组的强制位（对于可执行文件的所属组禁锢）（对目录文件设置–目录文件的所属组禁锢；表示任何用户创建文件的所属组都是当前目录的所属组）</p><p>o+t     &#x3D;1     sticky冒险位（对一个目录文件存在冒险位，用户只能删除自己文件不能删除别人的文件）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@162 /]# ll /usr/bin/touch </span><br><span class="line">-rwxr-xr-x. 1 root root 109776 Feb 14 03:07 /urs/bin/touch</span><br><span class="line"></span><br><span class="line">[redhat@162 ~]$ touch red1    // 通过当前用户redhat，执行可执行文件touch,所以touch进程文件的所属用户就是当前用户，根据当前进程创建目标文件，所以目标文件的所属用户以及所属组和进程文件的所属用户和所属组一样。</span><br><span class="line">[redhat@162 ~]$ ll red1</span><br><span class="line">-rw-rw-r--. 1 redhat redhat 0 Feb 16 22:40 red1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">root@162 /]# chmod u+s /usr/bin/touch </span><br><span class="line">[root@162 /]# ll /usr/bin/touch                    对可执行文件设置u+s</span><br><span class="line">-rwsr-xr-x. 1 root root 109776 Feb 14 03:07 /usr/bin/touch</span><br><span class="line"></span><br><span class="line">[redhat@162 ~]$ touch red2                  //通过当前用户redhat执行可执行文件touch，touch进程文件的所属用户取决于文件自身的用户root，所属组取决于发起者身份redhat的基本组,所以目标文件的所属用户是root：redhat</span><br><span class="line">[redhat@162 ~]$ ll red2</span><br><span class="line">-rw-rw-r--. 1 root redhat 0 Feb 16 22:46 red2</span><br><span class="line"></span><br><span class="line">root@162 /]# chmod g+s /usr/bin/touch </span><br><span class="line">[root@162 /]# ll /usr/bin/touch                    对可执行文件设置u+s,g+s</span><br><span class="line">-rwsr-sr-x. 1 root root 109776 Feb 14 03:07 /usr/bin/touch</span><br><span class="line"></span><br><span class="line">[redhat@162 ~]$ touch red3                  //通过当前用户redhat执行可执行文件touch，touch进程文件的所属用户取决于文件自身的用户root，所属组取决于文件自身的所属组root，所以目标文件的所属用户是root：root</span><br><span class="line">[redhat@162 ~]$ ll red3</span><br><span class="line">-rw-rw-r--. 1 root redhat 0 Feb 16 22:46 red2</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">实际案例：</span><br><span class="line">[root@162 /]# ll  /etc/shadow</span><br><span class="line">----------. 1 root root 1812 Feb 16 03:21 /etc/shadow</span><br><span class="line"></span><br><span class="line">为什么用户能够通过passwd修改密码命令对密码文件有写权限</span><br><span class="line"></span><br><span class="line">[root@162 /]# ll /usr/bin/passwd</span><br><span class="line">-rwsr-xr-x. 1 root root 34512 Aug 12  2018 /usr/bin/passwd</span><br><span class="line"></span><br><span class="line">[redhat@162 ~]$ passwd       通过发起者身份redhat，运行passwd可执行文件，可执行文件进程的所属用户取决于文件自身用户root，通过root用户对密码文件进行操作。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">g+s  对目录设置</span><br><span class="line">[root@162 /]# chmod o+w /pub</span><br><span class="line"></span><br><span class="line">[redhat@162 pub]$ touch aa</span><br><span class="line">[redhat@162 pub]$ ll</span><br><span class="line">total 0</span><br><span class="line">-rw-rw-r--. 1 redhat redhat 0 Feb 17 01:12 aa</span><br><span class="line"></span><br><span class="line">[root@162 /]# chmod g+s /pub     -目录所属组禁锢</span><br><span class="line">[root@162 /]# ll -d /pub</span><br><span class="line">drwxr-srwx. 2 root root 16 Feb 17 01:12 /pub</span><br><span class="line"></span><br><span class="line">[redhat@162 pub]$ touch bb          --任何用户在该目录下创建的任意文件的所属组都和目录的所属组一样</span><br><span class="line">[redhat@162 pub]$ ll</span><br><span class="line">total 0</span><br><span class="line">-rw-rw-r--. 1 redhat redhat 0 Feb 17 01:12 aa</span><br><span class="line">-rw-rw-r--. 1 redhat root   0 Feb 17 01:13 bb</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">目录o+t </span><br><span class="line">[root@162 /]# mkdir /test </span><br><span class="line">[root@162 /]# ll -d /test</span><br><span class="line">drwxr-xr-x. 2 root root 6 Feb 17 01:21 /test</span><br><span class="line">[root@162 /]# chmod o+w /test</span><br><span class="line"></span><br><span class="line">[u1@162 zuoye]$ cd /test</span><br><span class="line">[u1@162 test]$ touch u1</span><br><span class="line">[u1@162 test]$ touch u2</span><br><span class="line">[u1@162 test]$ touch u3</span><br><span class="line"></span><br><span class="line">[redhat@162 ~]$ cd /test</span><br><span class="line">[redhat@162 test]$ touch red1</span><br><span class="line">[redhat@162 test]$ touch red2</span><br><span class="line">[redhat@162 test]$ touch red3</span><br><span class="line"></span><br><span class="line">[root@162 test]# touch root1</span><br><span class="line">[root@162 test]# touch root2</span><br><span class="line">[root@162 test]# touch root3</span><br><span class="line"></span><br><span class="line">[redhat@162 test]$ rm root1             ---对于当前目录没有特殊权限，但对当用户拥有写权限，所以用户可以删除任意用户创建的文件</span><br><span class="line">rm: remove write-protected regular empty file &#x27;root1&#x27;? y</span><br><span class="line"></span><br><span class="line">[root@162 test]# chmod o+t  /test      --设置特殊权限</span><br><span class="line">[root@162 test]# ll -d /test</span><br><span class="line">drwxr-xrwt. 2 root root 98 Feb 17 01:25 /test</span><br><span class="line"></span><br><span class="line">[redhat@162 test]$ rm red1</span><br><span class="line"></span><br><span class="line">redhat@162 test]$ rm root2</span><br><span class="line">rm: remove write-protected regular empty file &#x27;root2&#x27;? y</span><br><span class="line">rm: cannot remove &#x27;root2&#x27;: Operation not permitted      ---用户只能删除自己文件不能删除别人的文件</span><br><span class="line">注：对于管理员，目录文件有特殊权限该用户也可以删除任何用户创建的文件</span><br></pre></td></tr></table></figure><h4 id="扩展权限："><a href="#扩展权限：" class="headerlink" title="扩展权限："></a>扩展权限：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">getfacl   FILENAME   查看文件的权限列表</span><br><span class="line"></span><br><span class="line">setfacl -m u:USERNAME:prem   FILENAME</span><br><span class="line">                   g:GROUPNAME:prem  FILENAME</span><br><span class="line"></span><br><span class="line">setfacl -x   u:USERNAME:   FILENAME    删除文件的一条扩展权限</span><br><span class="line"></span><br><span class="line">setfacl -b   FILENAME  清空指定文件的扩展权限</span><br><span class="line"></span><br><span class="line">应用场景（对于系统中的文件，只要求对某一个或者某一些用户对文件由不同的权限可以通过扩展权限来实现）</span><br></pre></td></tr></table></figure><h1 id="day06"><a href="#day06" class="headerlink" title="day06"></a>day06</h1><h2 id="网络管理"><a href="#网络管理" class="headerlink" title="网络管理"></a>网络管理</h2><p>三种网络模式</p><p>仅主机：   虚拟机都为仅主机模式，多台虚拟可以互ping；   物理机    –ping —-&gt;虚拟机</p><p>nat： 虚拟机都为nat模式，多台虚拟可以互ping； 物理机 &lt;—–ping —-&gt;虚拟机    只要物理能访问外网虚拟机就能上网</p><p>桥接： 虚拟机都为桥接模式，多台虚拟可以互ping；物理机 &lt;—–ping —-&gt;虚拟机 （同一网段的地址）；可以访问外网（当前主机的地址能不能访问外网）</p><p>网卡动态和静态地址配置</p><p>1.虚拟图形界面</p><p>2.nmtui  连接图形化界面进行配置（键盘）</p><p>3.nm-connection-editor  鼠标控制</p><p>4.网卡配置文件  </p><p>[root@162 ~]# cat &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-ens160<br>TYPE&#x3D;Ethernet                       网卡类型 Ethernet真实网卡<br>PROXY_METHOD&#x3D;none<br>BROWSER_ONLY&#x3D;no<br>BOOTPROTO&#x3D;dhcp                   网卡模式dhcp动态模式    none  静态模式<br>DEFROUTE&#x3D;yes<br>IPV4_FAILURE_FATAL&#x3D;no<br>IPV6INIT&#x3D;yes<br>IPV6_AUTOCONF&#x3D;yes<br>IPV6_DEFROUTE&#x3D;yes<br>IPV6_FAILURE_FATAL&#x3D;no<br>IPV6_ADDR_GEN_MODE&#x3D;stable-privacy<br>NAME&#x3D;ens160                              网卡配置文件名<br>UUID&#x3D;29a02f09-4754-4f2f-a91b-b0fd3cbf7987<br>DEVICE&#x3D;ens160                            网卡设备名<br>ONBOOT&#x3D;no                              网卡开机后是否自动连接<br>IPV6_PRIVACY&#x3D;no</p><p>注:RHEL7-    一个网卡设备可以对应多个网卡配置文件，但是当前网卡默认只能连接一个网卡配置</p><p>*****5.nmcli  网络管理工具</p><p>nmcli   device    show           显示主机所有网络设备详细信息</p><p>​                             status        显示主机设备和会话（网卡配置文件）</p><p>​                            connect       将设备和指定会话文件链接</p><p>nmcli   connection    show</p><p>​ modify</p><p>​                                     edit</p><p>​                                     add</p><p>​                                     delete</p><p>​                                       up</p><p>​                                        down</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">nmcli配置静态ip地址</span><br><span class="line"></span><br><span class="line">[root@162 ~]# nmcli connection modify ens160 ipv4.method  manual  ipv4.addresses 192.168.220.111/24 ipv4.dns 114.114.114.114  ipv4.gateway 192.168.220.2 connection.autoconnect yes    </span><br><span class="line">--修改ens160会话文件参数   网络模式=manual  ipv4.地址=   connection.autoconnect yes  设置网卡开机自动连接</span><br><span class="line">[root@162 ~]# nmcli connection up ens160         ---激活ens160网卡配置</span><br><span class="line"></span><br><span class="line">[root@162 ~]# cat /etc/sysconfig/network-scripts/ifcfg-ens160 </span><br><span class="line">TYPE=Ethernet</span><br><span class="line">PROXY_METHOD=none</span><br><span class="line">BROWSER_ONLY=no</span><br><span class="line">BOOTPROTO=none</span><br><span class="line">DEFROUTE=yes</span><br><span class="line">IPV4_FAILURE_FATAL=no</span><br><span class="line">IPV6INIT=yes</span><br><span class="line">IPV6_AUTOCONF=yes</span><br><span class="line">IPV6_DEFROUTE=yes</span><br><span class="line">IPV6_FAILURE_FATAL=no</span><br><span class="line">IPV6_ADDR_GEN_MODE=stable-privacy</span><br><span class="line">NAME=ens160</span><br><span class="line">UUID=29a02f09-4754-4f2f-a91b-b0fd3cbf7987</span><br><span class="line">DEVICE=ens160</span><br><span class="line">ONBOOT=yes</span><br><span class="line">DNS1=114.114.114.114</span><br><span class="line">IPV6_PRIVACY=no</span><br><span class="line">IPADDR=192.168.220.111</span><br><span class="line">PREFIX=24</span><br><span class="line">GATEWAY=192.168.220.2</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">[root@162 ~]# nmcli connection edit ens160     --进入编辑网卡配置文件</span><br><span class="line"></span><br><span class="line">===| nmcli interactive connection editor |===</span><br><span class="line"></span><br><span class="line">Editing existing &#x27;802-3-ethernet&#x27; connection: &#x27;ens160&#x27;</span><br><span class="line"></span><br><span class="line">Type &#x27;help&#x27; or &#x27;?&#x27; for available commands.</span><br><span class="line">Type &#x27;print&#x27; to show all the connection properties.</span><br><span class="line">Type &#x27;describe [&lt;setting&gt;.&lt;prop&gt;]&#x27; for detailed property description.</span><br><span class="line"></span><br><span class="line">You may edit the following settings: connection, 802-3-ethernet (ethernet), 802-1x, dcb, sriov, ethtool, match, ipv4, ipv6, tc, proxy</span><br><span class="line">nmcli&gt;                          tab</span><br><span class="line">activate  describe  help      print     remove    set       </span><br><span class="line">back      goto      nmcli     quit      save      verify    </span><br><span class="line">nmcli&gt; goto ipv4               进入iPv4模式</span><br><span class="line">You may edit the following properties: method, dns, dns-search, dns-options, dns-priority, addresses, gateway, routes, route-metric, route-table, routing-rules, ignore-auto-routes, ignore-auto-dns, dhcp-client-id, dhcp-timeout, dhcp-send-hostname, dhcp-hostname, dhcp-fqdn, never-default, may-fail, dad-timeout</span><br><span class="line">nmcli ipv4&gt; </span><br><span class="line">activate  describe  help      print     remove    set       </span><br><span class="line">back      goto      nmcli     quit      save      verify    </span><br><span class="line">nmcli ipv4&gt; set  method </span><br><span class="line">auto        disabled    link-local  manual      shared      </span><br><span class="line">nmcli ipv4&gt; set  method auto    将网络模式改为自动模式</span><br><span class="line">Do you also want to clear &#x27;ipv4.addresses&#x27;? [yes]: yes</span><br><span class="line">nmcli ipv4&gt; save</span><br><span class="line">Error: connection verification failed: ipv4.gateway: gateway cannot be set if there are no addresses configured</span><br><span class="line">You may try running &#x27;verify fix&#x27; to fix errors.</span><br><span class="line">nmcli ipv4&gt; remove </span><br><span class="line">addresses           dhcp-send-hostname  dns-search          method              routing-rules</span><br><span class="line">dad-timeout         dhcp-timeout        gateway             never-default       </span><br><span class="line">dhcp-client-id      dns                 ignore-auto-dns     route-metric        </span><br><span class="line">dhcp-fqdn           dns-options         ignore-auto-routes  routes              </span><br><span class="line">dhcp-hostname       dns-priority        may-fail            route-table         </span><br><span class="line">nmcli ipv4&gt; remove ipv4.gateway  </span><br><span class="line">nmcli ipv4&gt; remove ipv4.dns</span><br><span class="line">nmcli ipv4&gt; save</span><br><span class="line">Connection &#x27;ens160&#x27; (29a02f09-4754-4f2f-a91b-b0fd3cbf7987) successfully updated.</span><br><span class="line">nmcli ipv4&gt; quit</span><br><span class="line">[root@162 ~]# nmcli connection up ens160 </span><br><span class="line"></span><br><span class="line">[root@162 ~]# cat /etc/sysconfig/network-scripts/ifcfg-ens160 </span><br><span class="line">TYPE=Ethernet</span><br><span class="line">PROXY_METHOD=none</span><br><span class="line">BROWSER_ONLY=no</span><br><span class="line">BOOTPROTO=dhcp</span><br><span class="line">DEFROUTE=yes</span><br><span class="line">IPV4_FAILURE_FATAL=no</span><br><span class="line">IPV6INIT=yes</span><br><span class="line">IPV6_AUTOCONF=yes</span><br><span class="line">IPV6_DEFROUTE=yes</span><br><span class="line">IPV6_FAILURE_FATAL=no</span><br><span class="line">IPV6_ADDR_GEN_MODE=stable-privacy</span><br><span class="line">NAME=ens160</span><br><span class="line">UUID=29a02f09-4754-4f2f-a91b-b0fd3cbf7987</span><br><span class="line">DEVICE=ens160</span><br><span class="line">ONBOOT=yes</span><br><span class="line">IPV6_PRIVACY=no</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@162 ~]# nmcli connection add type ethernet ifname ens160 con-name work</span><br><span class="line">Connection &#x27;work&#x27; (dcab47ad-1250-458f-ad64-7471f4bb41e0) successfully added.</span><br><span class="line">[root@162 ~]# vim /etc/sysconfig/network-scripts/ifcfg-work </span><br><span class="line"></span><br><span class="line">TYPE=Ethernet</span><br><span class="line">PROXY_METHOD=none</span><br><span class="line">BROWSER_ONLY=no</span><br><span class="line">BOOTPROTO=dhcp</span><br><span class="line">DEFROUTE=yes</span><br><span class="line">IPV4_FAILURE_FATAL=no</span><br><span class="line">IPV6INIT=yes</span><br><span class="line">IPV6_AUTOCONF=yes</span><br><span class="line">IPV6_DEFROUTE=yes</span><br><span class="line">IPV6_FAILURE_FATAL=no</span><br><span class="line">IPV6_ADDR_GEN_MODE=stable-privacy</span><br><span class="line">NAME=work</span><br><span class="line">UUID=dcab47ad-1250-458f-ad64-7471f4bb41e0</span><br><span class="line">DEVICE=ens160</span><br><span class="line">ONBOOT=yes</span><br><span class="line">[root@162 ~]# nmcli connection modify work ipv4.method  manual  ipv4.addresses 192.168.220.111/24 ipv4.dns 114.114.114.114  ipv4.gateway 192.168.220.2 </span><br><span class="line">[root@162 ~]# nmcli connection up work</span><br><span class="line">root@162 ~]# nmcli connection delete work</span><br></pre></td></tr></table></figure><h1 id="day07"><a href="#day07" class="headerlink" title="day07"></a>day07</h1><h2 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h2><p>1.获取软件 包</p><p>（1）本地获取</p><p>本地光盘存储介质获取</p><p>默认路径：&#x2F;run&#x2F;media&#x2F;root&#x2F;RHEL-8-1-0-BaseOS-x86_64 </p><p>手动挂载： mkdir &#x2F;sr0</p><p>​                   mount  &#x2F;dev&#x2F;sr0    &#x2F;sr0    （临时生效）</p><p>​                  挂载命令    设备名称     挂载点目录</p><p>​  取消挂载： 注意不能再挂载点目录中取消</p><pre><code>                                 umount   设备名</code></pre><p>​                                     umount   挂载点</p><p>（2）网络（上网）</p><p>网易开源镜像站</p><p>阿里开源镜像站</p><p>清华大学</p><p>2.安装软包RHEL8</p><p>&#x2F;mnt&#x2F;AppStream&#x2F;Packages</p><p>&#x2F;mnt&#x2F;BaseOS&#x2F;Packages</p><p>#cd  &#x2F;mnt&#x2F;AppStream&#x2F;Packages</p><p>rpm -ivh   zsh-html-5.5.1-6.el8.noarch.rpm </p><p>​ -qpi    包名   查看一个软件包的详细信息</p><p>​       </p><p>​        -evh      卸载软件包</p><p>​        -qa        查询已安装的所有软件包    rpm -qa | grep 软件名</p><p>​       -ql          查看指定软件的文件列表</p><p>​-qf         查看某个文件是由哪一个包提供</p><p>​       -Uvh     更新软件包</p><p>​       -qd       查询软件的事例文档</p><p>[root@localhost ~]# rpm -ivh <a href="https://down.qq.com/qqweb/LinuxQQ/linuxqq_2.0.0-b2-1089_x86_64.rpm">https://down.qq.com/qqweb/LinuxQQ/linuxqq_2.0.0-b2-1089_x86_64.rpm</a>     </p><p>dnf&#x2F;yum</p><p>能够自动解决依赖关系（自动识别依赖包并且下载对应依赖包，一次性安装无需手动指定）</p><p>1.获取软件包</p><p>（1）本地安装</p><p>mount  &#x2F;dev&#x2F;sr0 &#x2F;mnt</p><p>（2）网络安装</p><p>2.安装软件包</p><p>配置yum配置文件—-&#x2F;etc&#x2F;yum.repos.d&#x2F;*.repo</p><p>vim  &#x2F;etc&#x2F;yum.repos.d&#x2F;base.repo   </p><p>[AppStream]      源标示名称（名称自定义）</p><p>name&#x3D;App         源名称</p><p>baseurl&#x3D;file:&#x2F;&#x2F;&#x2F;mnt&#x2F;AppStream</p><p>gpgcheck&#x3D;0</p><p>[BaseOS]</p><p>name&#x3D;base</p><p>baseurl&#x3D;file:&#x2F;&#x2F;&#x2F;mnt&#x2F;BaseOS</p><p>gpgcheck&#x3D;0</p><p>#dnf   install    httpd    -y</p><p>​           repolist    显示仓库状态</p><p>​          remove    移除，卸载软件</p><p>​          update</p><p>源码安装</p><p> 解包 —— tar<br>解包、释放出源代码文件<br>配置 —— .&#x2F;configure<br>针对当前系统、软件环境，配置好安装参数<br>编译 —— make<br>将源代码文件变为二进制的可执行程序<br>安装 —— make install<br>将编译好的程序文件复制到系统中       </p><p>mkdir &#x2F;test<br>rm -rf &#x2F;test&#x2F;*<br>mv tar-1.29.tar.gz &#x2F;test</p><p> cd &#x2F;test<br>  ll<br>  tar -zxvf  tar-1.29.tar.gz<br>  ll<br>  dnf remove tar -y<br> touch 1<br> tar -cvzf 1.tar.gz  1             –系统默认的tar工具移除<br>  ll<br>  cd tar-1.29&#x2F;<br>  yum install gcc* -y           –安装编译器</p><p> .&#x2F;configure                      —不能通过管理员运行<br>  su redhat</p><p>rm -rf   config.log</p><p>.&#x2F;configure                      –通过普通用户进行配置、</p><p>exit</p><p>  make<br>   make install<br>   ll<br>  tree<br> which tar<br> cd ..<br>  ll<br>  tar -zcvf 1.tar.gz 1<br>  hash<br> hash -d tar<br> tar -zcvf 1.tar.gz 1<br> ll<br> history </p><p>ps    pstree  top     kill    PID    killall  进程名称     &amp;    ctrl-z   jobs      fg   bg   nohup</p><p>top ***</p><h2 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h2><p>1.磁盘设备基本单位 扇区&#x3D;512    数据层  1块 &#x3D; 4KB</p><p>2.主机启动顺序</p><p>主机加电开机+bios硬件自检+mbr+grub2+启动内核+initrams+加载系统系统文件</p><p>3.mbr   默认只记录四个分区表项，但是可以把其中一个主分区作为扩展分区在扩展分区中可以分多个逻辑分区</p><p>​3主分区+1扩展分区（n逻辑分区）</p><p>​                              主分区</p><p>为什么创建多个分区：通过不同分区可以管理不同类型的数据文件；通过多个分区设置不同的文件系统类型，来存放不同数据类型的文件。</p><p>如何创建分区</p><p>1.条件</p><p>至少需要一块硬盘；有剩余空间</p><p>lsblk   可以显示系统所有块设备</p><p>2.磁盘管理工具创建分区</p><p>fdisk     &#x2F;dev&#x2F;nvme0n2</p><p>n      创建新的分区   d删除分区    p打印分区列表   w  保存退   q退出不存</p><p>3.设置文件系统类型（格式化）</p><p>[root@localhost ~]# mkfs.xfs  &#x2F;dev&#x2F;nvme0n2p2</p><p>4.使用分区</p><p>临时挂载</p><p>mkdir &#x2F;p1</p><p>mount   &#x2F;dev&#x2F;nvme0n2p1    &#x2F;p1</p><p>umount    &#x2F;p1</p><p>永久挂载</p><p>vim  &#x2F;etc&#x2F;fstab</p><p>设备名（UUID）      挂载点目录      文件系统类型     参数      开机备份    开机检查</p><p>mount -a  在当前主机运行状态下挂载所有加载&#x2F;etc&#x2F;fstab 文件设备新添加设信息</p><p>reboot 重启加载文件 </p><p>blkid   查看设备id (设备的文件系统类型)</p><p>注： 一个文件系统可以同时挂载到多个挂点目录；多个文件系统挂载到一个挂载点目录，但是通过挂载点查看的是最后一次连接文件系统信息。</p>]]></content>
      
      
      <categories>
          
          <category> RHCSA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaSE</title>
      <link href="/post/2b32338b.html"/>
      <url>/post/2b32338b.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、java语言概述"><a href="#一、java语言概述" class="headerlink" title="一、java语言概述"></a>一、java语言概述</h1><h2 id="1、软件开发介绍"><a href="#1、软件开发介绍" class="headerlink" title="1、软件开发介绍"></a>1、软件开发介绍</h2><p>软件，即一系列按照特定顺序组织的计算机数据和指令的集合。有系统软件和应用软件之分。 常用的dos命令 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dir : 列出当前目录下的文件以及文件夹</span><br><span class="line">md : 创建目录</span><br><span class="line">rd : 删除目录</span><br><span class="line">cd : 进入指定目录</span><br><span class="line">cd.. : 退回到上一级目录</span><br><span class="line">cd\: 退回到根目录</span><br><span class="line">del : 删除文件</span><br><span class="line"><span class="built_in">exit</span> : 退出 dos 命令行</span><br><span class="line">补充：echo javase&gt;<span class="number">1.</span>doc</span><br></pre></td></tr></table></figure><p><strong>计算机语言：人与计算机交流的方式。</strong> </p><p>如果人要与计算机交流，那么就要学习计算机语言。C ,C++ ,Java,.net ,PHP , Kotlin，Python，Scala </p><h2 id="2、计算机编程语言介绍"><a href="#2、计算机编程语言介绍" class="headerlink" title="2、计算机编程语言介绍"></a>2、计算机编程语言介绍</h2><p><strong>第一代语言</strong> </p><p>机器语言。指令以二进制代码形式存在。 </p><p><strong>第二代语言</strong> </p><p>汇编语言。使用助记符表示一条机器指令 </p><p><strong>第三代语言：高级语言</strong> </p><p>C、Pascal、Fortran面向过程的语言 </p><p>C++面向过程&#x2F;面向对象 Java跨平台的纯面向对象的语言</p><p> .NET Python、Scala </p><h2 id="3、java语言概述"><a href="#3、java语言概述" class="headerlink" title="3、java语言概述"></a>3、java语言概述</h2><p> 是SUN(Stanford University Network，斯坦福大学网络公司 ) 1995年推出的一门高级编程语言。是一 种面向Internet的编程语言。Java一开始富有吸引力是因为Java程序可以在Web浏览器中运行。这些Java 程序被称为Java小程序（applet）。applet使用现代的图形用户界面与Web用户进行交互。 applet内嵌 在HTML代码中。随着Java技术在web方面的不断成熟，已经成为Web应用程序的首选开发语言。 </p><p>1991年 Green项目，开发语言最初命名为Oak (橡树) </p><p>1994年，开发组意识到Oak 非常适合于互联网 </p><p>1996年，发布JDK 1.0，约8.3万个网页应用Java技术来制作 </p><p>1997年，发布JDK 1.1，JavaOne会议召开，创当时全球同类会议规模之最 </p><p>998年，发布JDK 1.2，同年发布企业平台J2EE</p><p>1999年，Java分成J2SE、J2EE和J2ME，JSP&#x2F;Servlet技术诞生 </p><p>2004年，发布里程碑式版本：JDK 1.5，为突出此版本的重要性，更名为JDK 5.0 </p><p>2005年，J2SE -&gt; JavaSE，J2EE -&gt; JavaEE，J2ME -&gt; JavaME </p><p>2009年，Oracle公司收购SUN，交易价格74亿美元 </p><p>2011年，发布JDK 7.0 </p><p>2014年，发布JDK 8.0，是继JDK 5.0以来变化最大的版本 </p><p>2017年，发布JDK 9.0，最大限度实现模块化 </p><p>2018年3月，发布JDK 10.0，版本号也称为18.3 </p><p>2018年9月，发布JDK 11.0，版本号也称为18.9 </p><h2 id="4、java技术平台"><a href="#4、java技术平台" class="headerlink" title="4、java技术平台"></a>4、java技术平台</h2><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106165903244.png" alt="image-20220106165903244"></p><h2 id="5、java使用领域"><a href="#5、java使用领域" class="headerlink" title="5、java使用领域"></a>5、java使用领域</h2><p><strong>企业级应用</strong>：主要指复杂的大企业的软件系统、各种类型的网站。Java的安全机制以及它的跨平台的优 势，使它在分布式系统领域开发中有广泛应用。应用领域包括金融、电信、交通、电子商务等。 移动领域应用：主要表现在消费和嵌入式领域，是指在各种小型设备上的应用，包括手机、PDA、机顶 盒、汽车通信设备等。 </p><p>诞生：</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106165944094.png" alt="image-20220106165944094"></p><p>java之父James Gosling团队在开发”Green”项目时，发现C缺少垃圾回收系统，还有可移植的安全性、分 布程序设计和多线程功能。最后，他们想要一种易于移植到各种设备上的平台。java是一个纯粹面向对 象的语言。舍弃了c语言中容易引起错误的指针，增加了垃圾回收器，泛型，枚举等功能。 </p><h2 id="6、java主要特征"><a href="#6、java主要特征" class="headerlink" title="6、java主要特征"></a>6、java主要特征</h2><p>Java语言是易学的。Java语言的语法与C语言和C++语言很接近，使得大多数程序员很容易学习和使用 Java。 </p><p>Java语言是强制面向对象的。Java语言提供类、接口和继承等原语，为了简单起见，只支持类之间的单 继承，但支持接口之间的多继承并支持类与接口之间的实现机制（关键字为implements）。 </p><p>Java语言是分布式的。Java语言支持Internet应用的开发，在基本的Java应用编程接口中有一个网络应用 编程接口（java net），它提供了用于网络应用编程的类库，包括URL、URLConnection、Socket、 ServerSocket等。Java的RMI（远程方法激活）机制也是开发分布式应用的重要手段。</p><p> Java语言是健壮的。Java的强类型机制、异常处理、垃圾的自动收集等是Java程序健壮性的重要保证。 对指针的丢弃是Java的明智选择。 </p><p>Java语言是安全的。Java通常被用在网络环境中，为此，Java提供了一个安全机制以防恶意代码的攻 击。如：安全防范机制（类ClassLoader），如分配不同的名字空间以防替代本地的同名类、字节代码 检查。 </p><p>Java语言是体系结构中立的。Java程序（后缀为java的文件）在Java平台上被编译为体系结构中立的字节 码格式（后缀为class的文件），然后可以在实现这个Java平台的任何系统中运行。 </p><p>Java语言是解释型的。如前所述，Java程序在Java平台上被编译为字节码格式，然后可以在实现这个Java 平台的任何系统的解释器中运行。</p><p> Java是性能略高的。与那些解释型的高级脚本语言相比，Java的性能还是较优的。 </p><p>Java语言是原生支持多线程的。在Java语言中，线程是一种特殊的对象，它必须由Thread类或其子 （孙）类来创建。 </p><h2 id="7、java程序运行机制与运行过程"><a href="#7、java程序运行机制与运行过程" class="headerlink" title="7、java程序运行机制与运行过程"></a>7、java程序运行机制与运行过程</h2><p>Java语言的特点:1）面向对象：两个基本概念：类和对象。三大特征：封装，继承，多态 </p><p>​2）健壮：吸收了C&#x2F;C++语言的优点，但去掉了其影响程序健壮性的部分（如指针、内 存的申请与释放等），提供了一个相对安全的内存管理和访问机制 </p><p>​3）跨平台：跨平台性：通过Java语言编写的应用程序在不同的系统平台上都可以运 行。Write once , Run Anywhere。原理：在操作系统上按照java虚拟机（JVM java Virtual Machine）. 由JVM来负责Java程序在该系统中的运行。</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106170229323.png" alt="image-20220106170229323"></p><p>​核心机制：JAVA虚拟机（JAVA Virtal Machine） 垃圾收集机制（Garbage Collection）</p><p>​ java虚拟机 ：JVM 是一个虚拟的计算机，具有指令集并使用不同的存储区域。负责执行指令，管 理数据，内存，寄存器。对于不同的平台，有不同的虚拟机。只有操作系统是航有对应的java虚拟机， java程序才可在运行。java虚拟机机制屏蔽了底层运行平台的差别，实现了一次编译，到处运行。</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106170409628.png" alt="image-20220106170409628"></p><p>​垃圾回收：不再使用的内存空间应回收。Java 语言消除了程序员回收无用内存空间的责任：它 提供一种系统级线程跟踪存储空间的分配情况。并在JVM空闲时，检查并释放那些可被释放的存储空 间。垃圾回收在Java程序运行过程中自动进行，程序员无法精确控制和干预。</p><h2 id="8、java语言环境搭建"><a href="#8、java语言环境搭建" class="headerlink" title="8、java语言环境搭建"></a><strong>8、java语言环境搭建</strong></h2><p>下载JDK,安装JDK,配置环境变量。</p><p>验证是否成功 </p><p><strong>什么是JDK,JRE?</strong></p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106170500936.png" alt="image-20220106170500936"></p><p>JDK&#x3D;JRE+开发工具集 JRE&#x3D;JVM+JAVASE标准类库 </p><p>安装：傻瓜式安装，默认下一步即可。安装路径不能包含中文，空格等特殊字符。推荐再要安装的路径 下，创建好文件夹。</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106170527913.png" alt="image-20220106170527913">\</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106170541021.png" alt="image-20220106170541021"></p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106170549286.png" alt="image-20220106170549286"></p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106170601891.png" alt="image-20220106170601891"></p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106170610266.png" alt="image-20220106170610266"></p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106170623344.png" alt="image-20220106170623344"></p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106170630923.png" alt="image-20220106170630923"></p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106170640512.png" alt="image-20220106170640512"></p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106170647950.png" alt="image-20220106170647950"></p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106170656498.png" alt="image-20220106170656498"></p><p><strong>配置环境变量</strong></p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106170749177.png" alt="image-20220106170749177"></p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106170757853.png" alt="image-20220106170757853"></p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106170807379.png" alt="image-20220106170807379"></p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106170848229.png" alt="image-20220106170848229"></p><p><strong>配置path</strong></p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106170906910.png" alt="image-20220106170906910"></p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106170919329.png" alt="image-20220106170919329"></p><p><strong>path:%JAVA_HOME%:取到配置JAVA_HOME环境变量的值</strong></p><p> <strong>检测是否成功</strong></p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106170948280.png" alt="image-20220106170948280"></p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106170955140.png" alt="image-20220106170955140"></p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106171003495.png" alt="image-20220106171003495"></p><h2 id="9、helloworld"><a href="#9、helloworld" class="headerlink" title="9、helloworld"></a>9、helloworld</h2><p>将 Java 代码<strong>编写</strong>到扩展名为 .java 的文件中。</p><p>通过 javac 命令对该 java 文件进行<strong>编译</strong>。</p><p>通过 java 命令对生成的 class 文件进行<strong>运行</strong>。</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106171133079.png" alt="image-20220106171133079"></p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106171140302.png" alt="image-20220106171140302"></p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106171147836.png" alt="image-20220106171147836"></p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106171201631.png" alt="image-20220106171201631"></p><p>​编写第一个java程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">System.out.println(“Hello World!”);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 编译:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac Test.java</span><br></pre></td></tr></table></figure><p>有了java源文件，通过编译器将其编译成JVM可以识别的字节码文件。 </p><p>在该源文件目录下，通过javac编译工具对Test.java文件进行编译。 </p><p>如果程序没有错误，没有任何提示，但在当前目录下会出现一个Test.class文件，该文件称为字节码文 件，也是可以执行的java的程序。 </p><p>运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java Test</span><br></pre></td></tr></table></figure><p>有了可执行的java程序(Test.class字节码文件) </p><p>通过运行工具java.exe对字节码文件进行执行。出现提示：缺少一个名称为main的方法 </p><p>因为一个程序的执行需要一个起始点或者入口，所以在Test类中的加入public static void main(String[] args){ } </p><p>对修改后的Test.java源文件需要重新编译，生成新的class文件后，再进行执行。 </p><p>发现没有编译失败，但也没有任何效果，因为并没有告诉JVM要帮我们做什么事情，也就是没有可以具 体执行的语句。 </p><p>想要和JVM来个互动，只要在main方法中加入一句System.out.println(“Hello World”);因为程序进行改 动，所以再重新编译，运行即可 </p><p>现在文件的扩展名</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106171454564.png" alt="image-20220106171454564"></p><h2 id="10、常见问题及解决办法"><a href="#10、常见问题及解决办法" class="headerlink" title="10、常见问题及解决办法"></a>10、常见问题及解决办法</h2><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106171532462.png" alt="image-20220106171532462"></p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106171539332.png" alt="image-20220106171539332"></p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106171549885.png" alt="image-20220106171549885"></p><p>源文件名不存在或者写错 当前路径错误 后缀名隐藏问题 </p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106171834797.png" alt="image-20220106171834797"></p><p>类文件名写错，尤其文件名与类名不一致时，要小心类文件不在当前路径下，或者不在classpath指定 路径下 </p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106171843436.png" alt="image-20220106171843436"></p><p>声明为public的类应与文件名一致，否知编译失败 </p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106171852440.png" alt="image-20220106171852440"></p><p>编译失败，注意错误出现的行数，再到源代码中指定位置改错 </p><p>学习编程最容易犯的错是语法错误。Java要求你必须按照语法规则编写代码。 </p><p>如果你的程序违反了语法规则，例如：忘记了分号、大括号、引号，或者拼错了单词，java编译器都会 报语法错误。尝试着去看懂编译器会报告的错误信息 </p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106171941060.png" alt="image-20220106171941060"></p><p>或使用转义字符实现换行</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106171956088.png" alt="image-20220106171956088"></p><h2 id="11、注释"><a href="#11、注释" class="headerlink" title="11、注释"></a>11、注释</h2><p>单行注释 &#x2F;&#x2F; 多行注释 &#x2F;**&#x2F; </p><p>文档注释 (java特有)</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106172027886.png" alt="image-20220106172027886"></p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106172040733.png" alt="image-20220106172040733">、</p><p>小结程序</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106172057909.png" alt="image-20220106172057909"></p><h2 id="12、良好的编程习惯"><a href="#12、良好的编程习惯" class="headerlink" title="12、良好的编程习惯"></a>12、良好的编程习惯</h2><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106172125033.png" alt="image-20220106172125033"></p><h2 id="练习题："><a href="#练习题：" class="headerlink" title="练习题："></a>练习题：</h2><p>1、 java语言的特点是什么？</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106172142904.png" alt="image-20220106172142904"></p><p>2、System.out.println()与System.out.print()区别是什么？ </p><p>3、一个.java源文件中是否可以包括多个类？什么要求？ </p><p>4、Test类的文件名叫Demo.java </p><p>5、设置path的目的是什么？ </p><p>6、JDK JRE 和 JVM的关系是什么？ </p><p>7、源文件名是否必须和类名相同呢？如果不是，什么情况下相同 </p><p>8、程序中若只有一个public修饰的类，且此类包含main方法，那么类名和源文件名可否不一致？ </p><p>9、java注释方式有哪几种，格式是什么？ </p><p>10、GC是什么？为什么要有GC</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106172220977.png" alt="image-20220106172220977"></p><p>11、垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行 垃圾回收</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106172242190.png" alt="image-20220106172242190"></p><p>12、输出以下内容</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106172300143.png" alt="image-20220106172300143"></p><h1 id="二、数据类型变量与运算符"><a href="#二、数据类型变量与运算符" class="headerlink" title="二、数据类型变量与运算符"></a>二、数据类型变量与运算符</h1><h2 id="1、数据类型"><a href="#1、数据类型" class="headerlink" title="1、数据类型"></a>1、数据类型</h2><p>​在生活中，使用的数据有大有小，有整数，也有小数，同时也会使用字母，或者汉字表示特定含 义。在Java中根据数据的不同特点，数据也分为不同的类型。Java语言是强类型语言，对于每一种数据 都定义了明确的具体数据类型，在内存总分配了不同大小的内存空间</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106172337347.png" alt="image-20220106172337347"></p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220110093928701.png" alt="image-20220110093928701"></p><p>注意：整数默认int,小数默认double。boolean类型的值只有true false </p><h2 id="2、标识符"><a href="#2、标识符" class="headerlink" title="2、标识符"></a>2、标识符</h2><p>自己起名字的地方都叫标识符。 </p><p>​Java中的名称命名规范：可以包含数字，字母，_，$.但是开头不能是数字，不能是java中的关键字。 命名是区分大小写的。 </p><p><strong>包名：</strong>多单词组成时所有字母都小写：xxxyyyzzz </p><p><strong>类名、接口名：</strong>多单词组成时，所有单词的首字母大写：XxxYyyZzz。帕斯卡命名规则 </p><p><strong>变量名、方法名：</strong>多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写： xxxYyyZzz。驼峰命名规则 </p><p><strong>常量名：</strong>所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ </p><p>注意1：在起名字时，为了提高阅读性，要尽量有意义，“见名知意”。 </p><p>注意2：java采用unicode字符集，因此标识符也可以使用汉字声明，但是不建议使用 </p><h2 id="3、关键字与保留字"><a href="#3、关键字与保留字" class="headerlink" title="3、关键字与保留字"></a>3、关键字与保留字</h2><p>关键字(keyword)的定义和特点 </p><p>定义：<strong>被Java语言赋予了特殊含义，用做专门用途的字符串（单词）</strong> </p><p>特点：<strong>关键字中所有字母都为小写</strong></p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106172856220.png" alt="image-20220106172856220"></p><p> 字面值： true false null </p><p>保留字：现有Java版本尚未使用，但以后版本可能会作为关键字使用。自己命名标识符时要避免使用 这些保留字：goto const </p><h2 id="4、变量"><a href="#4、变量" class="headerlink" title="4、变量"></a>4、变量</h2><p>​ 1&gt; 概念：内存中的一个存储区域。该区域的数据可以在同一个类型范围内不断变化。变量是程序中 最基本的存储单元。包含：变量类型 变量名 值； </p><p>​作用：用于在内存中保存数据的。 </p><p>​注意：先声明再使用 </p><p>​使用变量名来访问这块区域的数据 </p><p>​变量的作用域：其定义所在的一对{ }内 </p><p>​变量只有在其作用域内才有效 </p><p>​同一个作用域内，不能定义重名的变量 </p><p>​2&gt;使用 </p><p>​声明变量： 数据类型 变量名; </p><p>​赋值： 变量名&#x3D;值; </p><p>​合并以上步骤：数据类型 变量名 &#x3D; 值； </p><p>​变量除去按照数据类型来分后，还可以按照位置来分【了解，后面详解】</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106173207732.png" alt="image-20220106173207732"></p><p>​3&gt; 整形变量：byte short int long </p><p>Java各整数类型有固定的表数范围和字段长度，不受具体OS的影响，以保证java程序的可移植性。 </p><p>java的整型常量默认为 int 型，声明long型常量须后加‘l’或‘L’ </p><p>java程序中变量通常声明为int型，除非不足以表示较大的数，才使用long</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220107140601383.png" alt="image-20220107140601383"></p><p>​4&gt; 浮点类型：float、double </p><p>与整数类型类似，Java 浮点类型也有固定的表数范围和字段长度，不受具体操系统的影响。 浮点型常量有两种表示形式： </p><p>十进制数形式：如：5.12 512.0f .512 (必须有小数点） </p><p>科学计数法形式:如：5.12e2 512E2 100E-2 </p><p>float:单精度，尾数可以精确到7位有效数字。很多情况下，精度很难满足需求。</p><p>double:双精度，精度是float的两倍。通常采用此类型。 </p><p><strong>Java 的浮点型常量默认为double型，声明</strong>float型常量，须后加f或F。</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106173404278.png" alt="image-20220106173404278"></p><p>​5&gt;字符类型 char</p><p> char 型数据用来表示通常意义上“字符”(2字节) </p><p>Java中的所有字符都使用Unicode编码，故一个字符可以存储一个字母，一个汉字，或其他书面语的一 个字符。 </p><p>字符型变量的三种表现形式： </p><p>字符常量是用单引号(‘ ’)括起来的单个字符。例如：char c1 &#x3D; ‘a’; char c2 &#x3D; ‘中’; char c3 &#x3D; ‘9’;</p><p> Java中还允许使用转义字符‘\’来将其后的字符转变为特殊字符型常量。 </p><p>例如：char c3 &#x3D; ‘\n’; &#x2F;&#x2F; ‘\n’表示换行符 </p><p>直接使用 Unicode 值来表示字符型常量：‘\uXXXX’。其中，XXXX代表 一个十六进制整数。如：\u000a 表示 \n。 </p><p>char类型是可以进行运算的。因为它都对应有Unicode码。 </p><p><strong>扩展：</strong></p><p><strong>ascii 码</strong>在计算机内部，所有数据都使用<strong>二进制</strong>表示。每一个二进制位（bit）有 0 和 1 两种状 态，因此 8 个二进制位就可以组合出 <strong>256 种</strong>状态，这被称为一个字节（byte）。一个字节一共可以用来 表示 256 种不同的状态，每一个状态对应一个符号，就是 256 个符号，从0000000 到 11111111。 </p><p>ASCII码：上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规 定。这被称为ASCII码。ASCII码一共规定了<strong>128个</strong>字符的编码，比如空格“SPACE”是32（二进制 00100000），大写的字母A是65（二进制01000001）。这128个符号（包括32个不能打印出来的控制 符号），只占用了一个字节的后面7位，最前面的1位统一规定为0。 </p><p>ASCII编码表中，A&#x3D;65，a&#x3D;97</p><p><strong>缺点</strong>：不能表示所有字符。 相同的编码表示的字符不一样。</p><p> <strong>unicode码：</strong>乱码：世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此， 要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。 Unicode：<strong>一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，使用 Unicode 没有乱码的问题。</strong> </p><p><strong>Unicode 的缺点：</strong>Unicode 只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储：无 法区别 Unicode 和 ASCII：计算机无法区分三个字节表示一个符号还是分别表示三个符号。另外，我们 知道，英文字母只用一个字节表示就够了，如果unicode统一规定，每个符号用三个或四个字节表示， 那么每个英文字母前都必然有二到三个字节是0，这对于存储空间来说是极大的浪费。</p><p>​6&gt;boolean类型：boolean类型数据只允许取值true和false，无null。 </p><p>不可以使用0或非 0 的整数替代false和true，这点和C语言不同。</p><p> Java虚拟机中没有任何供boolean值专用的字节码指令，Java语言表达所操作的boolean值，在编译之后 都使用java虚拟机中的int数据类型来代替：true用1表示，false用0表示。 </p><h2 id="5、类型转换"><a href="#5、类型转换" class="headerlink" title="5、类型转换"></a><strong>5、类型转换</strong></h2><p>​1&gt;自动类型转换 </p><p>容量小的类型自动转换为容量大的数据类型。数据类型按容量大小排序为</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106173920283.png" alt="image-20220106173920283"></p><p>​有多种类型的数据混合运算时，系统首先自动将所有数据转换成容量最大的那种数据类型，然后再进 行计算。</p><p> byte,short,char之间不会相互转换，他们三者在计算时首先转换为int类型。 </p><p>boolean类型不能与其它数据类型运算 </p><p>当把任何基本数据类型的值和字符串(String)进行连接运算时(+)，基本数据类型的值将自动转化为字符 串(String)类型 </p><p>​2&gt;强制类型转换 </p><p>自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型。使用时要加上强制转换符： ()，但可能造成精度降低或溢出,格外要注意 。 </p><p>通常，字符串不能直接转换为基本类型，但通过基本类型对应的包装类则可以实现把字符串转换成基本 类型 </p><p>boolean类型不可以转换为其他的数据类型 </p><p>扩展：进制 所有数字在计算机底层都以<strong>二进制</strong>形式存在 </p><p>对于整数，有四种表示方式： </p><p><strong>二进制</strong>(binary)：0,1 ，满2进1.以0b或0B开头。 </p><p>​二进制的整数有如下三种形式： </p><p>​原码：直接将一个数值换成二进制数。最高位是符号位 </p><p>​负数的反码：是对原码按位取反，只是最高位（符号位）确定为1。 </p><p>​负数的补码：其反码加1。 </p><p>​计算机以二进制补码的形式保存所有的整数。 </p><p>​正数的原码、反码、补码都相同 </p><p>​负数的补码是其反码+1</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106173933617.png" alt="image-20220106173933617"></p><p><strong>十进制</strong>(decimal)：0-9 ，满10进1。</p><p> <strong>八进制</strong>(octal)：0-7 ，满8进1. 以数字0开头表示。 </p><p><strong>十六进制</strong>(hex)：0-9及A-F，满16进1. 以0x或0X开头表示。此处的A-F不区分大小写。如：0x21AF +1&#x3D; 0X21B0</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106173954580.png" alt="image-20220106173954580"></p><h2 id="6、-运算符"><a href="#6、-运算符" class="headerlink" title="6、 运算符"></a>6、 运算符</h2><p>运算符是一种特殊的符号，用以表示数据的运算、赋值和比较等。</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106174011615.png" alt="image-20220106174011615"></p><p>课堂讲解：</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106174025758.png" alt="image-20220106174025758"></p><h2 id="练习："><a href="#练习：" class="headerlink" title="练习："></a>练习：</h2><p>1、在内存中存储本金1000元 显示内存中存储的数据的值 </p><p>2、 使用变量存储数据，实现个人简历信息的输出<img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106174038013.png" alt="image-20220106174038013"></p><p>3、 输出Java课考试最高分：98.5 输出最高分学员姓名：张三 输出最高分学员性别：男 </p><p>4、从控制台输入学员王浩3门课程成绩，编写程序实现 Java课和SQL课的分数之差 3门课的平均分</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106174050004.png" alt="image-20220106174050004"></p><p>5、 根据天数（46）计算周数和剩余的天数 </p><p>6、已知圆的半径radius&#x3D; 1.5，求其面积 </p><p>7、键盘输入四位数字的会员卡号 使用“&#x2F;”和“%”运算符分解获得会员卡各个位上的数字 将各个位上数字 求和 </p><p>8、 根据分解后的数字之和，判断用户是否中奖<img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106174117471.png" alt="image-20220106174117471"></p><p>9、 从控制台输入张三同学的成绩，与李四的成绩（80分）比较，输出“张三的成绩比李四的成绩高吗?” 的判断结果 </p><p>10、打印购物小票</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106174128902.png" alt="image-20220106174128902"></p><p>11、 为抵抗洪水，解放军战士连续作战89小时，编程计算共多少天零多少小时？ </p><p>12、 自定义一个整数，输出该数分别与1~10相乘的结果。 </p><p>13、思考，以下代码有区别吗？<img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106174139732.png" alt="image-20220106174139732"></p><p>14、对两个数实行等量交换</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220106174151200.png" alt="image-20220106174151200"></p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220108155136069.png" alt="image-20220108155136069"></p><h1 id="三、流程控制语句"><a href="#三、流程控制语句" class="headerlink" title="三、流程控制语句"></a>三、流程控制语句</h1><p>流程控制语句是用来控制程序中各语句执行顺序的语句，可以把语句组合成能完成一定功能的小逻辑模 块。 </p><p>其流程控制方式采用结构化程序设计中规定的三种基本流程结构，即：顺序结构，分支结构，循环结 构。 </p><p>顺序结构：程序从上到下逐行执行，中间没任何判断和跳转。 </p><p>分支结构：选择结构。有两类，一类是if，一类是switch </p><p>循环结构：while,do…while,for循环。 </p><h2 id="1、选择结构"><a href="#1、选择结构" class="headerlink" title="1、选择结构"></a>1、选择结构</h2><h3 id="1-if语句"><a href="#1-if语句" class="headerlink" title="1.if语句"></a>1.if语句</h3><p>有三种格式：</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220108152638682.png" alt="image-20220108152638682"></p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220108152650310.png" alt="image-20220108152650310"></p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220108152659491.png" alt="image-20220108152659491"></p><h3 id="2、switch语句"><a href="#2、switch语句" class="headerlink" title="2、switch语句"></a>2、switch语句</h3><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220108152728036.png" alt="image-20220108152728036"></p><p>switch(表达式)中表达式的值必须是下述几种类型之一：byte short char，int，枚举 (jdk 5.0)，String (jdk7.0)；</p><p> case子句中的值必须是常量，不能是变量名或不确定的表达式值； </p><p>同一个switch语句，所有case子句中的常量值互不相同； </p><p>break语句用来在执行完一个case分支后使程序跳出switch语句块；如果没有break，程序会顺序执行到 switch结尾 </p><p>default子句是可任选的。同时，位置也是灵活的。当没有匹配的case时，执行default。</p><h3 id="练习1-："><a href="#练习1-：" class="headerlink" title="练习1 ："></a><strong>练习1 ：</strong></h3><p>​1、如果成绩在90分以上是A,80分以上是B,70分以上是C,60分以上是D,其他 E </p><p>​2、今天是周末还是工作？如果是周末，如果气温大于36度，就游泳，否则就爬山，如果是工作日，看看天气好嘛？如果天气好，就去拜访客户，如果天气不好，就在单位查资料。</p><p>​3、飞机票的原价是 5000元，12-3旺季 旺季头等舱打折扣9折，经济舱是8折 其余时间是淡季， 头等舱，打5折，经济舱打四折用户输入出行的月份，选择头等舱还是经济舱，请输出用户应支付的机票 的价格 请输入出行的月份: 3 请选择 1.头等舱 2.经济舱 您的机票的价格为:4500元 </p><p>​4、如果考试考了第一名，奖励一个笔记本，如果第二名，奖励一个移动硬盘，如果第三名，奖励了一个U盘，否则没任何奖励。 </p><h3 id="练习2-："><a href="#练习2-：" class="headerlink" title="练习2 ："></a><strong>练习2 ：</strong></h3><p>​1、输入今天星期几？一三五，吃鱼。二四六吃肉。日吃素 </p><p>​2、商场搞活动，换购活动，1. 满50元，可以加两元换购一瓶矿泉水，2.满100元，可以加五元换 购一瓶矿泉水，3.满100元，加10元换购炒锅一个，4.满200元，可以加5元换购一瓶爽肤水，5.满200 元，加10元换购保温壶一个 0不换购。 </p><p>​3、输入三个数，然后按照从小到大顺序输出三个数。 </p><p>​4、输入一个四位数，如果这个四位数和随机生成的一个数相同，则终奖了 </p><h3 id="练习3："><a href="#练习3：" class="headerlink" title="练习3："></a><strong>练习3：</strong></h3><ol><li></li></ol><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220108152936000.png" alt="image-20220108152936000"></p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220108152948347.png" alt="image-20220108152948347"></p><ol start="2"><li></li></ol><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220108153044952.png" alt="image-20220108153044952"></p><p>3、设计一个迷你计算器</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220108153101079.png" alt="image-20220108153101079"></p><p>3、从键盘分别输入判断一年是否是闰年的标准：</p><p>​1）可以被4整除，但不可被100整除或 </p><p>​2）可以被400 整除 </p><p>4、假设你想开发一个玩彩票的游戏，程序随机地产生一个两位数的彩票，提示用户输入一个两位数，然 后按照下面的规则判定用户是否能赢。 </p><p>​1)如果用户输入的数匹配彩票的实际顺序，奖金10 000美元。 </p><p>​2)如果用户输入的所有数字匹配彩票的所有数字，但顺序不一致，奖金 3 000美元。 </p><p>​3)如果用户输入的一个数字仅满足顺序情况下匹配彩票的一个数字，奖金1 000美元。 </p><p>​4)如果用户输入的一个数字仅满足非顺序情况下匹配彩票的一个数字，奖金500美元。 </p><p>​5)如果用户输入的数字没有匹配任何一个数字，则彩票作废。</p><p> 提示：使用Math.random() 产生随机数</p><p> Math.random() 产生[0,1)范围的随机值 </p><p>Math.random() * 90：[0,90) </p><p>Math.random() * 90 + 10：[10,100) 即得到 [10,99] </p><p>使用(int)(Math.random() * 90 + 10)产生一个两位数的随机数。 </p><p>5、提供三个1-6的随机数，作为掷骰子得到的点数。</p><p>​如果各个点数相同，则为豹子。 </p><p>​如果三个骰子点数和，小于或等于9，则为“小”。 </p><p>​如果三个骰子点数和，大于9，则为“大”。 </p><p>​用户随机选择：押大、押小或者押豹子。通过判断，输出客户是否押正确。</p><p>​ &#x2F;&#x2F;1、产生一个[1-6]的数 int a &#x3D; (int)(Math.random()*6+1); </p><p>6、编写一个程序，为一个给定的年份找出其对应的中国生肖。中国的生肖基于12年一个周期，每年用 一个动物代表：rat（鼠）、ox（牛）、tiger（虎）、rabbit（兔）、dragon（龙）、snake（蛇）、 horse（马）、sheep（羊）、monkey（候）rooster（鸡）、dog（狗）、pig（猪）。</p><p>​提示：2019 年：猪 2019 % 12 &#x3D;&#x3D; 3 </p><p>7、随机生成一个100以内的数，猜数字游戏：从键盘输入数，如果大了提示，大了，如果小了，提示小 了，如果对了，就不再猜了，并统计一共猜了多少次？提示：随机数 </p><p>8、一个数如果恰好等于它的因子之和，这个数就称为”完数”。（因子：除去这个数本身的约数）例如 6&#x3D;1＋2＋3.编程 找出1000以内的所有完数 </p><p>9、输入两个正整数m和n，求其最大公约数和最小公倍数 </p><h3 id="switch与if比较"><a href="#switch与if比较" class="headerlink" title="switch与if比较"></a><strong>switch与if比较</strong></h3><p>if和switch语句很像，具体什么场景下，应用哪个语句呢？ </p><p>如果判断的具体数值不多，而且符合byte、short 、char、int、String、枚举等几种类型。虽然两个语 句都可以使用，建议使用swtich语句。因为效率稍高。 其他情况：对区间判断，对结果为boolean类型 判断，使用if，if的使用范围更广。也就是说，使用switch-case的，都可以改写为if-else。反之不成立。 </p><h2 id="2、循环结构"><a href="#2、循环结构" class="headerlink" title="2、循环结构"></a><strong>2、循环结构</strong></h2><p>在某些条件满足的情况下，反复执行特定代码的功能。有三种循环，分布是while 循环，do-while循环 以及for循环。</p><p>循环会有四要素：初始化变量，循环条件，循环操作，改变变量的值防止死循环。 </p><p>生活中的循环：</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220108153437109.png" alt="image-20220108153437109"></p><h3 id="1-gt-while循环"><a href="#1-gt-while循环" class="headerlink" title="1&gt;while循环"></a>1&gt;while循环</h3><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220108153451153.png" alt="image-20220108153451153"></p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220108153501638.png" alt="image-20220108153501638"></p><p>特点：先判断再执行； </p><h3 id="2-gt-do-while"><a href="#2-gt-do-while" class="headerlink" title="2&gt;do-while"></a>2&gt;do-while</h3><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220108153515759.png" alt="image-20220108153515759"></p><p>特点：先执行再判断</p><p> while循环和do-while循环的区别 </p><h3 id="3-gt-for循环"><a href="#3-gt-for循环" class="headerlink" title="3&gt;for循环"></a>3&gt;for循环</h3><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220108153546189.png" alt="image-20220108153546189"></p><h2 id="3、跳转语句"><a href="#3、跳转语句" class="headerlink" title="3、跳转语句"></a><strong>3、跳转语句</strong></h2><p>break:改变程序控制流 </p><p>用于do-while、while、for中时，可跳出循环而执行循环后面的语句 用在switch语句中</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220108153611270.png" alt="image-20220108153611270"></p><p>continue，只能用在循环里面。作用：跳过循环体中剩余的语句而执行下一次循环</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220108153634021.png" alt="image-20220108153634021"></p><p>return：并非专门用于结束循环的，它的功能是结束一个方法。 </p><p>当一个方法执行到一个return语句时，这个方法将被结束。</p><p> 与break和continue不同的是，return直接结束整个方法，不管这个return处于多少层循环之内 </p><h2 id="练习：-1"><a href="#练习：-1" class="headerlink" title="练习："></a>练习：</h2><p>​1、打印1-100之间的所有奇数的和 </p><p>​2、打印1~100之间所有是7的倍数的整数的个数及总和（体会设置计数器的思想） </p><p>​3、输出所有的水仙花数，所谓水仙花数是指一个3位数，其各个位上数字立方和等于其本身 </p><p>​例如：153 &#x3D; 111 + 333 + 555 </p><p>​4、从键盘读入个数不确定的整数，并判断读入的正数和负数的个数，输入为0时结束程序 </p><p>​5、用户登录系统，最多输入三次用户名与密码，提醒用户登录是否成功，以及还有几次机会。 </p><p>​6、实现循环购物(第二章练习)</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220108153731332.png" alt="image-20220108153731332"></p><pre><code>     7、 假设一个简单的ATM机的取款过程是这样的：首先提示用户输入密码(password)，最多只能输入 三次，超过三次则提示用户“密码错误，请取卡”结束交易。如果用户密码正确，再提示用户输入金额 (amout)，ATM机只能输出100元的纸币，一次取钱要求最低0元，最高1000元，如果用户输入的金额符 合上述要求，则打印输出用户取的钱数，最后提示用户“交易完成，请取卡”，否则提示用户重新输入金 额。假设用户密码是111111。      8、 编写JAVA程序，实现输出1--100之间所有不能被7整除的数，并求和要求：每输出4个数据换行显</code></pre><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220108153754770.png" alt="image-20220108153754770"></p><p>​9、求阶乘</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220108153811593.png" alt="image-20220108153811593"></p><p>​ 10、实现菜单循环</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220108153828521.png" alt="image-20220108153828521"></p><p>二重循环：打印九九乘法表</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220108153916237.png" alt="image-20220108153916237"></p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220111165134257.png" alt="image-20220111165134257"></p><h1 id="四、数组"><a href="#四、数组" class="headerlink" title="四、数组"></a>四、数组</h1><h2 id="1、数组的概述"><a href="#1、数组的概述" class="headerlink" title="1、数组的概述"></a>1、数组的概述</h2><p>在执行程序的过程中，经常需要存储大量的数据，例如，假设需要读取100个数，计它们的平均值，然 后找出有多少个数大于平均值。首先，程序读入这些书并且计算它们的平均值，然后将每个数与平均值 进行比较判断它是否大于平均值。为了完成这个任务，必须将全部的数据存储到变量中。必须声明100 个变量，并且重复书写100次几乎完全相同的代码。这样编写程序的方式似乎是不太现实的，那么该如 何解决这个问题呢？</p><p> Java和许多高级语言都提供了一种称作数据（array）的数据结构，可以用它来存储一个元素个数固定且 元素类型下相同的有序集。数组主要解决多变量多数据的存储问题，方便程序后期统一维护操作数据。 数组的本质是什么呢？数组就是一系列空间大小相等且地址连续的一片存储空间。为什么空间大小是相 等的呢？就是为了方便统一维护我们的数据，必须得保证数据之间的类型是一样的。为什么变量空间的 地址是连续的呢？地址连续切大小相等方便计算后续元素的具体物理内存地址。</p><p> 数组就是一片地址连续且空间大小一致的存储空间(但是每个空间存的还是其他数据的地址。数组存在于 堆内存中，但凡在堆中存储的数据都称之为对象。数组提供下标来访问数组当中的元素。数组变量存的 就是数组在堆内存中首元素的地址。数组通过下标来访问元素的具体计算方式是：所要访问数据的地址 &#x3D; 首元素地址 + 下标 * 数据类型大小。数组一旦定义下来，其长度不可改变；数组中有几个地址？就看 数组有几个元素空间（数组的长度）。创建数组时必须明确规定大小或内容。</p><h2 id="2、一维数组的使用"><a href="#2、一维数组的使用" class="headerlink" title="2、一维数组的使用"></a>2、一维数组的使用</h2><p><strong>创建数组只指定长度但不指定内容</strong> 数据类型[] 数组名 &#x3D; new 数据类型[长度]; </p><p><strong>创建数组指定内容</strong>(同时长度就确定了) </p><p>数据类型[] 数组名 &#x3D; new 数据类型[]{数据1, 数据2, 数据3, …, 数据n}; </p><p>数据类型[] 数组名 &#x3D; {数据1, 数据2, 数据3, …, 数据n} </p><p>数组默认值</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220108154111832.png" alt="image-20220108154111832"></p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220108154121749.png" alt="image-20220108154121749"></p><p>定义并用运算符new为之分配空间后，才可以引用数组中的每个元素；</p><p>数组元素的引用方式：数组名[数组元素下标] </p><p>数组元素下标可以是整型常量或整型表达式。如a[3] , b[i] , c[6*i];</p><p> 数组元素下标从0开始；长度为n的数组合法下标取值范围: 0 —&gt;n-1；如int a[]&#x3D;new int[3]; 可引用的数 组元素为a[0]、a[1]、a[2] </p><p>每个数组都有一个属性length指明它的长度，例如：a.length 指明数组a的长度(元素个数) </p><p>数组一旦初始化，其长度是不可变的 </p><h2 id="3、一维数组内存分析"><a href="#3、一维数组内存分析" class="headerlink" title="3、一维数组内存分析"></a>3、一维数组内存分析</h2><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220108154207485.png" alt="image-20220108154207485"></p><p><strong>目前关注：方法区，虚拟机栈，堆</strong> </p><p>栈stack:局部变量 </p><p>堆heap:new出来的结构 </p><p>方法区：method area 静态域 常量池 类的元数据</p><h2 id="4、一维数组操作"><a href="#4、一维数组操作" class="headerlink" title="4、一维数组操作"></a><strong>4、一维数组操作</strong></h2><p>​1&gt; 数组遍历 </p><p>​2&gt;查找数组中的最大值和最小值</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220108154415032.png" alt="image-20220108154415032"></p><p>​3&gt;查找元素在数组中是否存在</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220108154431147.png" alt="image-20220108154431147"></p><p>​4&gt;数组倒着输出</p><p>​5&gt;数组添加元素，修改元素，以及删除元素</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220108154447248.png" alt="image-20220108154447248"></p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220108154631184.png" alt="image-20220108154631184"></p><p>​ 6&gt;数组元素复制</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220108154645368.png" alt="image-20220108154645368"></p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220114095442324.png" alt="image-20220114095442324"></p><h3 id="练习：-2"><a href="#练习：-2" class="headerlink" title="练习："></a>练习：</h3><p>1&gt;循环录入8个成绩，查找到最大值最小值值，以及其位置 </p><p>2&gt;输入五个成绩，求总分，以及按照从小到大排序 </p><p>3&gt;给定一个数列3，4，12，56，45 用户输入要查找的数，判断该数在该数列中是否存在 </p><p>4&gt;用户输入十个汉字，分别统计 王，李，张的姓氏的个数，其他均认为是非法字符，统计非法字符的 个数 </p><p>5&gt;有五种水果，apple,pear,banana,orange,mango按英文字母排列 这五种水果 </p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220113144029491.png" alt="image-20220113144029491"></p><p>6&gt;输入五句话，然后倒着输出 </p><p>7&gt;实现如下功能：</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220108155235177.png" alt="image-20220108155235177"></p><p>8&gt;阅读代码，直接写出结果</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220108155248477.png" alt="image-20220108155248477"></p><p> 9&gt;从键盘读入学生成绩，找出最高分，并输出学生成绩等级。成绩&gt;&#x3D;最高分-10 等级为’A’ 成绩&gt;&#x3D;最高 分-20 等级为’B’ 成绩&gt;&#x3D;最高分-30 等级为’C’ 其余 等级为’D’</p><p>10&gt;打印斐波那契数列 1, 1, 2, 3, 5, 8, 13, 21, 34, 55 </p><p>11&gt;创建要给长度为6的int类型数组，要求数组元素的值再1-30之间，且随机赋值。同时要求数组元 素各不相同</p><p>12、数组反转：</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220111175351166.png" alt="image-20220111175351166"></p><p> 13、数组查找【线性查找与二分查找】 </p><p>二分查找：数组是有序的。</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220111175420442.png" alt="image-20220111175420442"></p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220111175427182.png" alt="image-20220111175427182"></p><h2 id="排序算法：十大内部排序算法"><a href="#排序算法：十大内部排序算法" class="headerlink" title="排序算法：十大内部排序算法"></a>排序算法：十大内部排序算法</h2><p> 选择排序【直接选择排序，堆排序】 </p><p>交换排序【冒泡排序，快速排序 (手写代码)】</p><p> 插入排序【直接插入排序，折半插入排序，希尔排序】 </p><p>归并排序 </p><p>桶式排序 </p><p>基数排序</p><p>1&gt;冒泡排序</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220108155318090.png" alt="image-20220108155318090"></p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220111175514841.png" alt="image-20220111175514841"></p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220111175520596.png" alt="image-20220111175520596"></p><p>2&gt; 选择排序</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220111175531687.png" alt="image-20220111175531687"></p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220111175539005.png" alt="image-20220111175539005"></p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220111175544789.png" alt="image-20220111175544789"></p><p>3&gt; 插入排序</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220111175601483.png" alt="image-20220111175601483"></p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220111175608424.png" alt="image-20220111175608424"></p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220111175614819.png" alt="image-20220111175614819"></p><p> 4&gt; 快速排序【使用递归】</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220111175913536.png" alt="image-20220111175913536"></p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220111175738797.png" alt="image-20220111175738797"></p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220111175749603.png" alt="image-20220111175749603"></p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220111175937662.png" alt="image-20220111175937662"></p><h2 id="5、二维数组"><a href="#5、二维数组" class="headerlink" title="5、二维数组"></a>5、二维数组</h2><p>Java 语言里提供了支持多维数组的语法。如果说可以把一维数组当成几何中的线性图形，那么二维数组 就相当于是一个表格，像右图Excel中的表格一样。对于二维数组的理解，我们可以看成是一维数组 array1又作为另一个一维数组array2的元素而存在。其实，从数组底层的运行机制来看，其实没有多维 数组。 </p><p>格式1（动态初始化）</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220117145305390.png" alt="image-20220117145305390"></p><p>定义了名称为arr的二维数组二维数组中有3个一维数组 每一个一维数组中有2个元素一维数组的名称分别为arr[0], arr[1], arr[2]给第一个一维数组1脚标位赋值 为78写法是：arr[0][1] &#x3D; 78; </p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220117145332628.png" alt="image-20220117145332628"></p><p>格式2（动态初始化）：</p><p>int[][] arr &#x3D; new int[3][];二维数组中有3个一维数组。每个一维数组都是默认初 始化值null (注意：区别于格式1） </p><p>可以对这个三个一维数组分别进行初始化arr[0] &#x3D; new int[3]; arr[1] &#x3D; new int[1]; arr[2] &#x3D; new int[2];</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220111180016545.png" alt="image-20220111180016545"></p><p>练习：1.打印杨辉三角<img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220111180207529.png" alt="image-20220111180207529"></p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220111180217786.png" alt="image-20220111180217786"></p><h1 id="五、初步认识初始面向对象"><a href="#五、初步认识初始面向对象" class="headerlink" title="五、初步认识初始面向对象"></a>五、初步认识初始面向对象</h1><h2 id="1、面向对象和面向过程"><a href="#1、面向对象和面向过程" class="headerlink" title="1、面向对象和面向过程"></a>1、面向对象和面向过程</h2><p>面向过程也是解决问题的一种思想，当我们在解决问题时，会按照预先设定的想法和步骤，一步一步去 实现，而具体的每一步都需要我们去实现和操作。这些步骤相互调用和协作，完成我们的需求。上述描 述的每一个具体步骤我们都是参与者，并且需要面对具体的每一个步骤和过程，这就是面向过程最直接 的体现。通过上面简单的描述发现，面向过程，其实就是面向着具体的每一个步骤和过程，就是面对具 体的每一个功能函数。这些功能函数相互调用，完成需求。 </p><p>面向对象当不再面对具体的每一个方法时，发现操作也变的简单了很多。而封装具体功能的这类，是我 们需要面对的。而基于这个封装了具体功能的类，那怎么使用呢？当面向封装了具体功能类，若要使用 这个类，一般情况下，在Java中需要通过创建这个类的实体来使用。这个实体称之为对象。在开发中， 我们是在不断的找封装不同功能的类。基于这些类，创建其对象，使用这些对象完成相应的操作。通过 上面的讲解和分析得出：<strong>面向对象是基于面向过程，对象是将功能进行了封装。</strong>只要找到了具体的类， 创建出对象，就可以调用其中的具体功能。面向对象也是用来解决问题的一种思维模式。在以后开发 中，先找对象，调用对象中的具体功能。如果真的没有能够完成需求的对象，这时就自己创建对象，并 将所需的功能定义到对象中，方便以后使用。 </p><p>面向对象是一种更符合人们思考习惯的思想面向过程中更多的体现的是执行者，面向对象中更多的体现 是指挥者。指挥对象做事情面向对象将复杂的问题简单化在面向对象的世界中：万事皆对象。 </p><p>面向对象和面向过程，其实都是一种思想。面向对象是相对面向过程而言的。面向过程，强调的是功能 行为，以函数为最小单位，考虑怎么做。面向对象，将功能封装到对象中，强调具备了功能的对象，以 类&#x2F;对象为最小的单位，考虑谁来做。 </p><p>面向对象分析和设计的思路： </p><p>根据问题需要，选择问题所针对的现实世界中的实体。</p><p>从实体中寻找解决问题相关的属性和功能，这些属性和功能就形成的概念世界中的类。 </p><p>把抽象的实体用计算机语言进行描述，形成计算机世界中类的定义。即借助某种程序语言，把类构造成 计算机能够识别和处理的数据结构。 </p><p>把类实例化成计算机世界中的对象，对象是计算机世界中解决问题的最终工具。</p><h2 id="2、-类和对象的关系"><a href="#2、-类和对象的关系" class="headerlink" title="2、 类和对象的关系"></a>2、 类和对象的关系</h2><p>面向对象程序设计（OOP）就是使用对象进行程序设计。<strong>对象（Object）代表现实世界中可以明确标识 的一个实体。</strong>例如：一个学生、一张桌子、一个圆、一个按钮甚至是一笔贷款都可以看作是一个对象。 每个对象都有自己独特的标识、状态和行为。一个对象的状态（state，也称为特征（property）或者属 性（arrtibute））是由具有当前值的数据域来表示的。例如：圆对象具有一个数据域radius，它是标识 圆的属性。一个矩形对象具有数据域width和height，它们都是描述矩形的属性。我们一般把对象的特有 属性称之为成员变量。 </p><p>一个对象的行为（behavior，也称为动作（action））是由方法定义的。调用对象的一个方法就是要求 对象完成一个动作。例如：可以为圆对象定义一个名为getArea()和getPerimeter()的方法。圆对象可以 调用getArea()返回圆的面积，调用getPerimeter()返回它的周长。我们一般把对象的行为称之为成员函 数。 </p><p>使用一个通用类来定义同一类型的对象。类是一个模板、蓝本或者说是合约，用来定义对象的数据域是 什么以及方法是做什么的。一个对象是类的一个实例。可以从一个类中创建多个实例。创建实例的过程 称为实例化。对象和实例经常是可以互换的。 </p><p>类是用于描述现实事物的，它将现实事物进行抽象化，模板化描述。将事物的特点（属性）和行为封装 在其中。比如小汽车的图纸，图纸就是小汽车的模版。图纸上画着小汽车的各种特点和功能要求。 </p><p>Java类使用变量定义数据域，使用方法定义动作。除此之外，类还提供了一种称为构造方法 （constructor）的特殊类型的方法，调用它可以创建一个新对象。构造方法本身是可以完成任何动作 的，但是设计构造方法是为了完成初始化动作。</p><p>对象是现实生活中存在的具体的实例、个体。即生活看到每一个事物，以及我们想象中的任务抽象的概 念，都是某一类事物的实例和个体。而这些个体都属于某一类事物，即这些个体都是某一类事物中的具 体的实例。比如，小汽车就是一类事物，而小汽车又是基于小汽车图纸制造出来的真实个体。因此我们 生活中的每一个实物都可以理解为是某一类事物的中的一个个体。创建对象的，通过对象就可以调用具 体的属性和行为。 </p><p>类和对象是面向对象的核心概念。类是对一类事物的描述，是抽象的概念上的定义。对象是实际存在的 该类事物的每个个体，因而也称为实例。类是抽象的概念，对象是具体的概念。 </p><p>可以理解:类&#x3D;抽象概念的人，对象&#x3D;实实在在的某个人 </p><p>面向对象程序设计的重点是类的设计</p><p>类的设计，其实就是类的成员设计。常见的类的成员有：属性【类中的成员变量】，方法【行为，类中 的成员方法】。</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220117145659074.png" alt="image-20220117145659074"></p><p>如果将对象比作汽车，那么类就是汽车的设计图纸。所以面向对象程序设计的重点是类的设计，而不是 对象的设计。<img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220117145709494.png" alt="image-20220117145709494"></p><p>类是模子，规定对象将会拥有的属性和方法</p><h2 id="3、类的语法格式："><a href="#3、类的语法格式：" class="headerlink" title="3、类的语法格式："></a>3、类的语法格式：</h2><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220117145732485.png" alt="image-20220117145732485"></p><p>java创建类的步骤： </p><p>定义类(考虑修饰符，类名) </p><p>编写类的属性(考虑修饰符，属性类型，属性名，初始化) </p><p>编写类的方法（考虑修饰符，返回值类型，方法名，形参等)。</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220117145806016.png" alt="image-20220117145806016"></p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220117145838771.png" alt="image-20220117145838771"></p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220117145848947.png" alt="image-20220117145848947"></p><h3 id="练习：-3"><a href="#练习：-3" class="headerlink" title="练习："></a>练习：</h3><p>1、 创建一个汽车类，包含属性有 品牌 型号 价格 颜色 使用年限。打印输出车的信息 </p><p>2、创建一个人类，包含人的姓名，性别，年龄。包含的吃饭的方法，睡觉的方法 编写好类后，如何使用？需要创建类的对象以及调用属性和方法 </p><p>3、创建管理员类，包含属性 用户名和密码，有一个输出方法，打印输出管理员信息。[类的设 计] </p><p>[实现修改管理员密码，要求先登录，如果登录成功，有权限修改密码，否则不能修改 main] 。</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220117145926714.png" alt="image-20220117145926714"></p><p>匿名对象：我们也可以不定义对象的引用，而直接调用这个对象的方法。这样的对象叫做匿名对象， 如：new Person().shout(); 如果对一个对象只需要进行一次方法调用，那么就可以使用匿名对象 。</p><p>4、编写学生类和教师类，并通过测试类创建对象进行测试</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220117150002147.png" alt="image-20220117150002147"></p><h2 id="4、成员变量"><a href="#4、成员变量" class="headerlink" title="4、成员变量"></a>4、成员变量</h2><p>成员变量又访问修饰符【后面详解】</p><p>可以是任意类型 </p><p>类中定义的变量称为成员变量，在方法中定义的变量是局部变量。成员变量和局部变量的区别。</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220117150129394.png" alt="image-20220117150129394"></p><p>当一个对象被创建时，会对其中各种类型的成员变量自动进行初始化赋值。除了基本数据类型之外的变 量类型都是引用类型</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220117150151420.png" alt="image-20220117150151420"></p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220117150159549.png" alt="image-20220117150159549"></p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220117150213129.png" alt="image-20220117150213129"></p><h2 id="5、方法"><a href="#5、方法" class="headerlink" title="5、方法"></a>5、方法</h2><p>方法是类或对象行为特征的抽象，用来完成某个功能操作，在某些语言中也称为函数或过程。</p><p>将功能封装为方法的目的是，实现代码重用，简化代码。 </p><p>java中的方法不独立存在，所有的方法定义在类中。 </p><p>案例：榨汁机案例【举例】 </p><p>类的方法定义类的某种行为（或功能）</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220117150253394.png" alt="image-20220117150253394"></p><p>方法分类: 按照有无返回值分类 ：1&gt; 无返回值 void 2&gt;有返回值 方法体最后加return。 </p><p>方法调用:方法是个黑匣子，完成某个特定的应用程序功能，并返回结果。方法通过方法名被调用。只有 被调用才会执行。 </p><p>调用方法就是执行方法中包含的语句。方法之间允许相互调用，不需要知道方法的具体实现，实现 宠重用，提高效率。 </p><p>方法之间存在相互调用，方法内部不能重复定义方法，只能调用另一个方法。</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220117150334416.png" alt="image-20220117150334416"></p><p>方法重载：方法名相同，参数列表不同，与访问修饰符与返回值类型无关，形成方法的重载。 </p><p>如果一个方法调用自身，我们称为方法的递归调用。递归容易出现堆栈溢出，必须找到出口，结束 该方法的执行。 </p><p>方法递归包含了一种隐式的循环，它会重复执行某段代码，但这种重复执行无须循环控制。</p><p>递归一定要向已知方向递归，否则这种递归就变成了无穷递归，类似于死循环。</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220117150425780.png" alt="image-20220117150425780"></p><h2 id="6、对象的创建和使用：内存解析"><a href="#6、对象的创建和使用：内存解析" class="headerlink" title="6、对象的创建和使用：内存解析"></a>6、对象的创建和使用：内存解析</h2><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220117150442689.png" alt="image-20220117150442689"></p><p>堆（Heap），此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一 点在Java虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配。 </p><p>通常所说的栈（Stack），是指虚拟机栈。虚拟机栈用于存储局部变量等。局部变量表存放了编译期可知 长度的各种基本数据类型（boolean、byte、char 、 short 、 int 、 float 、 long 、double）、对象引 用（reference类型，它不等同于对象本身，是对象在堆内存的首地址）。 方法执行完，自动释放。 </p><p>方法区（Method Area），用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的 代码等数据。 </p><p>对象内存分析【初步】</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220117150516357.png" alt="image-20220117150516357"></p><h3 id="练习：-4"><a href="#练习：-4" class="headerlink" title="练习："></a>练习：</h3><p>1、创建客户类，有客户类型以及积分。现在回馈客户，如果是金卡积分在1000以上，或者是普 卡，积分在5000以上，可以获赠500积分。 </p><p>2、编写游客类，包括客户名和年龄，输出客户的门票价格，如果在12岁以下或60岁以上，门票 不要钱，否则门票打五折。【门票原价100元】 </p><p>3、编写一个Student类，包含name、gender、age、id、score属性，分别为String、String、 int、int、double类型。类中声明一个say方法，返回String类型，方法返回信息中包含所有属性值。 </p><p>4、创建Person类，有属性name,age,sex属性，调用study方法，输出客户信息，调用person的 showAage的方法，给age属性加1。 </p><p>5、利用面向对象的思想的编程方法，设计及时circle的圆面积和圆周长</p><p>6、创建银行客户类Account类，有卡号cid，余额 balance，密码password.有方法，返回卡号详 细信息，密码显示6个*。设计取钱和存钱的方法。该银行卡号是从属某个Customer类。其中Customer 类有姓名，身份证号，联系电话，家庭地址等属性，有say方法，可以输出个人信息。 </p><h2 id="7、对象数组"><a href="#7、对象数组" class="headerlink" title="7、对象数组"></a>7、对象数组</h2><p>数组的类型是自己定义的类的类型，也就是一组相关对象的集合。利用对象数组完成对学生信息的查 看，添加，修改，删除。</p><h3 id="练习：-5"><a href="#练习：-5" class="headerlink" title="练习："></a>练习：</h3><p>1、创建学术类，包含学号，姓名，年龄，成绩，创建5个学生，成绩右随机数生成。打印学生信 息，并按照成绩由小到大的顺序输出。 </p><p>2、设计计算器的类，可以实现两个数相加，三个数详解，四个数相加，若干个数详解</p><h2 id="8、动态参数"><a href="#8、动态参数" class="headerlink" title="8、动态参数"></a>8、动态参数</h2><p>JavaSE 5.0 中提供了Varargs(variable number of arguments)机制，允许直接定义能和多个实参相匹 配的形参。从而，可以用一种更简单的方式，来传递个数可变的实参。 </p><ol><li><p>声明格式：方法名(参数的类型名 …参数名) </p></li><li><p>可变参数：方法参数部分指定类型的参数个数是可变多个：0个，1个或多个 </p></li><li><p>可变个数形参的方法与同名的方法之间，彼此构成重载 </p></li><li><p>可变参数方法的使用与方法参数部分使用数组是一致的 </p></li><li><p>方法的参数部分有可变形参，需要放在形参声明的最后 </p></li><li><p>在一个方法的形参位置，最多只能声明一个可变个数形参</p></li></ol><h2 id="9、值传递和引用传递"><a href="#9、值传递和引用传递" class="headerlink" title="9、值传递和引用传递"></a>9、值传递和引用传递</h2><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220117150938568.png" alt="image-20220117150938568"></p><p>形参是基本数据类型：将实参基本数据类型变量的“数据值”传递给形参 </p><p>形参是引用数据类型：将实参引用数据类型变量的“地址值”传递给形参</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220117151004539.png" alt="image-20220117151004539"></p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220117151022390.png" alt="image-20220117151022390"></p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220117151031703.png" alt="image-20220117151031703"></p><h3 id="练习：-6"><a href="#练习：-6" class="headerlink" title="练习："></a>练习：</h3><p>1、什么是方法重载 </p><p>2、java中参数传递的方式 </p><p>3、成员变量和局部变量的区别 </p><p>4、说说你对方法的理解</p><h1 id="六、封装"><a href="#六、封装" class="headerlink" title="六、封装"></a>六、封装</h1><h2 id="1、封装"><a href="#1、封装" class="headerlink" title="1、封装"></a>1、封装</h2><p>​我们程序设计追求“高内聚，低耦合”。高内聚 ：类的内部数据操作细节自己完成，不允许外部干 涉；低耦合 ：仅对外暴露少量的方法用于使用。 </p><p>​隐藏对象内部的复杂性，只对外公开简单的接口。便于外界调用，从而提高系统的可扩展性、可维 护性。通俗的说，把该隐藏的隐藏起来，该暴露的暴露出来。这就是封装性的设计思想。<img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220117151210949.png" alt="image-20220117151210949"></p><p>面向对象特点–抽象 从许多事物中舍弃个别的、非本质的特征，抽取共同的、本质性的特征，就叫作抽 象。 抽象是形成类的必须手段。 面向对象就是对现实世界的一种抽象 使用面向对象的思想描述以上图 片</p><p>Java中通过将数据声明为私有的(private)，再提供公共的（public）方法:getXxx()<strong>和setXxx()<strong>实现 对该属性的操作，以实现下述</strong>目的：</strong></p><ul><li><p>隐藏一个类中不需要对外提供的实现细节； </p></li><li><p>使用者只能通过事先定制好的方法来访问数据，可以方便地加入控制逻辑，限制对属性的不合理操 作； </p></li><li><p>便于修改，增强代码的可维护性； </p></li><li><p>提高了代码的重用性 隐藏了实现细节，对外提供访问的方式。</p></li></ul><p>如在以前的代码中，将属性直接定义在类中，用户在创建对象的时候，可以给属性任意赋值，如 age，用户在创建对象的时候，赋值为-20，该值就是一个非法的值。此时可以使用封装。 </p><p><strong>封装的步骤：</strong></p><p>​1)属性private </p><p>​2)提供get&#x2F;set方法</p><p>​3)在方法中加入流程控制语句 </p><p><strong>封装特点：</strong> </p><ul><li>隐藏一个类的实现细节；</li><li>调用者只能通过事先定制好的方法来访问数据，可以方便地加入控制逻辑，限制对属性的不合理操 作； </li><li>便于修改，增强代码的可维护性；</li></ul><p> 四种访问修饰符：</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220117151447781.png" alt="image-20220117151447781"></p><p>对于class的权限修饰只可以用public和default(缺省)。 public类可以在任意地方被访问。 default 类只可以被同一个包内部的类访问</p><h3 id="练习：-7"><a href="#练习：-7" class="headerlink" title="练习："></a>练习：</h3><p>1、创建一个学生类，设置学生的成绩在0-100之间 </p><p>2、创建一个人类，人类的年龄在0-130之间</p><h2 id="2、构造方法"><a href="#2、构造方法" class="headerlink" title="2、构造方法"></a>2、构造方法</h2><p>在开发中经常需要在创建对象的同时明确对象的属性值，比如员工入职公司就要明确他的姓名、年 龄等属性信息。创建对象就要明确属性值，那怎么解决呢？也就是在创建对象的时候就要做的事情，当 使用new关键字创建对象时，怎么给对象的属性初始化值呢？这就要学习Java另外一门小技术，构造函 数。那什么是构造函数呢？从字面上理解即为构建创造时用的函数，即就是对象创建时要执行的函数。 既然是对象创建时要执行的函数，那么只要在new对象时，知道其执行的构造函数是什么，就可以在执 行这个函数的时候给对象进行属性赋值</p><p>构造方法特征：名字和类名保持一致，没有返回值类型 不能被static,final,等修饰，不能有return 语句</p><p>构造方法的作用：创建对象，对对象进行初始化。 带参构造方法可以给属性赋值。</p><p>语法格式：修饰符 类名(参数列表){ </p><p>​初始化语句; </p><p>​}</p><p>隐式无参构造方法（系统默认提供） </p><p>显示定义一个或多个构造方法（无参，有参）</p><p><strong>注意：</strong></p><ul><li><p>Java语言中，每个类都至少有一个构造方法</p></li><li><p>一个类中如果没有定义构造方法，默认的有一个public修饰的无参的构造方法。 </p></li><li><p>在一个类中可以定义多个构造方法，形成方法的重载。 </p></li><li><p>如果在类中定义构造方法后，默认的无参构造方法就不存在了。</p></li><li><p>构造方法不能被继承</p></li></ul><p><strong>JavaBean:</strong></p><ul><li><p>是一种java语言写成的可重用组件 </p></li><li><p>所谓javaBean是指复合如下标准的java</p></li><li><p>类 类是公共的，public修饰</p></li><li><p>有一个无参的默认构造方法 </p></li><li><p>属性私有化，提供相应的get|set方法</p></li></ul><h2 id="3、this关键字"><a href="#3、this关键字" class="headerlink" title="3、this关键字"></a>3、this关键字</h2><p>this:代表当前对象 </p><p>可以通过this调用属性，方法，以及构造方法。 </p><p>通过this调用构造方法，必须放在语句的第一行。</p><p> 在java中，this关键字是比较难理解的，他在方法内部使用，即这个方法所属对象的应用。在 构造方法总使用，表示该构造方法正在初始化的对象。</p><p> 如果成员变量和局部变量同名的时候，可以使用this来区分。 </p><p><strong>总结：</strong></p><ul><li><p>可以在类的构造器中使用”this(形参列表)”的方式，调用本类中重载的其他的构造器！ </p></li><li><p>明确：构造器中不能通过”this(形参列表)”的方式调用自身构造器 </p></li><li><p>如果一个类中声明了n个构造器，则最多有 n - 1个构造器中使用了”this(形参列表)” </p></li><li><p>“this(形参列表)”必须声明在类的构造器的首行！ </p></li><li><p>在类的一个构造器中，最多只能声明一个”this(形参列表)”</p></li></ul><h2 id="4、-包与import"><a href="#4、-包与import" class="headerlink" title="4、 包与import"></a>4、 包与import</h2><p>package语句作为Java源文件的第一条语句，指明该文件中定义的类所在的包。(若缺省该语句， 则指定为无名包)。它的格式为：package xxx.xxx.xxx;</p><p> 包对应于文件系统中的目录，package语句中，用”.”来指明包(目录)的层次。 </p><p>包通常用小写单词标识，通常使用所在公司网址的倒置。com.openlab</p><p><strong>作用：</strong></p><ul><li>包帮助管理大型，将功能相近的类放到一个包中 </li><li>便于管理类 </li><li>解决类命名冲突问题 </li><li>控制访问权限</li></ul><p>使用import导入不同的包下的类</p><h3 id="练习：-8"><a href="#练习：-8" class="headerlink" title="练习："></a>练习：</h3><p>1、编写一个类Teacher，代表教员，要求如下：a) 具有属性：姓名，年龄，其中年龄不能 小于26岁，否则输出错误信息b) 具有方法：自我介绍，负责输出该教员的年龄，姓名c) 编写测试类 TeacherTest进行测试，看是否符合要求。 </p><p>2、编写一个类Teacher2，代表教员，要求如下a) 具有属性：姓名，年龄，性别和专业 b) 具有方法：自我介绍，负责输出该教员的年龄，姓名，性别和专业c) 具有两个带参的构造方法，第一个 构造方法中，设置教员的性别为男，专业为Java，其余属性的值由参数给定，第二个构造方法中，所有 属性的值都由参数给定d) 编写测试类Teacher2Test，分别以两种方式完成对两个Teacher2对象的初始 化工作，并分别调用它们的自我介绍方法，看看输出结果是否正确。 </p><p>3、使用面向对象的思想描述游戏中的怪物问题描述某公司要开发新游戏，请用面向对象的思 想设计怪物类，设定属性包括：怪物名字、生命值、攻击力、 防御力；方法包括：攻击的方法，防御的 方法.</p><p>​要求：</p><ul><li>通过构造函数实现属性赋值 </li><li>攻击方法，描述攻击状态。内容包括怪物名字，生命值，攻 击力 </li><li>防御方法通过输入参数接收攻击力。需要判断，如果攻击力小 于防御力，伤害值&#x3D;0；反之伤害值&#x3D;攻击力 -防御力 根据伤害值情况，显示不同的防御信息。内容包括怪物名字， 防御力，防御后的生命值.</li><li>编写测试方法，通过构造函数实例化怪物类的对象，并调用相关方法（测 试数据信息自定）运行效果：</li></ul><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220117152232586.png" alt="image-20220117152232586"></p><p>4、简述你对this关键字的理解 </p><p>5、说说构造方法的特点</p><p>6、以下方法执行的结果是什么？</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220122195852734.png" alt="image-20220122195852734"></p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220122195900467.png" alt="image-20220122195900467"></p><h1 id="七、继承"><a href="#七、继承" class="headerlink" title="七、继承"></a>七、继承</h1><h2 id="1、继承的含义"><a href="#1、继承的含义" class="headerlink" title="1、继承的含义"></a>1、继承的含义</h2><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220117152330642.png" alt="image-20220117152330642"></p><p>设计如下类：狗狗类 企鹅类 猫类。可以使用继承来简化代码。 </p><p>为什么需要继承：</p><p>​多个类中存在相同的属性和行为的时候，讲这些内容抽取到一个单独的一个类 中。那么多个类无需再定义这些属性和行为，只要继承即可。这个单独的类称作父类，其他类叫做子 类。可满足 is - a 的关系即可用继承实现。使用extends实现继承。</p><p><strong>作用:</strong></p><ul><li><p>使用继承的出现减少了代码冗余，提高的了代码的复用性。 </p></li><li><p>继承的出现，更有利于功能的扩展 </p></li><li><p>继承的出现让类和类之间产生了关系，提供了多态的前提。</p></li></ul><p>子类继承了父类，就继承了父类的方法和属性。</p><p>在子类中，可以使用父类中定义的方法和属性，也可以创建新的数据和方法。 </p><p>在java中，使用extends实现继承。子类继承父类，是对父类的扩展。 </p><p><strong>继承规则：</strong></p><ul><li>private修饰的不能继承。构造方法不继承。</li><li>java是单继承和多层继承。不能多继承。 </li><li>一个子类只能继承一个父类 </li><li>一个父类可以有多个子类。</li></ul><h3 id="练习：-9"><a href="#练习：-9" class="headerlink" title="练习："></a>练习：</h3><p>1、设计学生类，学生类继承自人类，人类中包含属性，姓名，性别，年龄，有输出人基本 信息的方法。学生继承了人类，还有属性，学号，成绩。同时也输出学生的信息</p><h2 id="2、super"><a href="#2、super" class="headerlink" title="2、super"></a>2、super</h2><p>super作用 </p><ul><li>在Java类中使用super来调用父类中的指定操作： </li><li>super可用于访问父类中定义的属性 </li><li>super可用于调用父类中定义的成员方法 </li><li>super可以用在子类构造器中调用父类中的构造器 <ul><li>尤其当父子类出现同名成员时，可以用super表明调用的是父类中的成员</li></ul></li><li>super的追溯不仅限于直接父类。 </li><li>super和this的用法相像，this代表本类对象的引用，super代表父类的内存空间的标识</li></ul><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220122195938436.png" alt="image-20220122195938436"></p><p>通过super调用父类的构造器： </p><ul><li><p>子类中所有的构造器<strong>默认</strong>都会访问父类中<strong>空参数</strong>的构造器 </p></li><li><p>当父类中没有空参数的构造器时，子类的构造器必须通过this(参数列表)或者super(参数列表) 语句指定调用本类或者父类中相的构造器。同时，只能”二选一”，且必须放在构造器的首行 </p></li><li><p>如果子类构造方法即无显示调用父类活本类的其他构造方法，且父类中又没有无参构造方法， 则编译错误。</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220122195957571.png" alt="image-20220122195957571"></p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220122200004912.png" alt="image-20220122200004912"></p></li></ul><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220122200017608.png" alt="image-20220122200017608"></p><p>父类的构造方法都会被执行到。 </p><p>this与super的区别</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220117152858990.png" alt="image-20220117152858990"></p><h2 id="3、方法重写"><a href="#3、方法重写" class="headerlink" title="3、方法重写"></a>3、方法重写</h2><p>在子类中可以根据需要对从父类中继承来的方法进行改造，也称为方法的重置、覆盖。在程序执 行时，子类的方法将覆盖父类的方法。</p><ol><li><p>子类重写的方法必须和父类被重写的方法具有相同的方法名称、参数列表 </p></li><li><p>子类重写的方法的返回值类型不能大于父类被重写的方法的返回值类型 </p></li><li><p>子类重写的方法使用的访问权限不能小于父类被重写的方法的访问权限子类不能重写父类 中声明为private权限的方法 </p></li><li><p>子类方法抛出的异常不能大于父类被重写方法的异常 </p></li><li><p>static方法是属于类的，子类无法覆盖父类的方法。</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220122200044178.png" alt="image-20220122200044178"></p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220122200051484.png" alt="image-20220122200051484"></p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220122200100231.png" alt="image-20220122200100231"></p></li></ol><h3 id="练习"><a href="#练习" class="headerlink" title="练习:"></a>练习:</h3><p>1、某汽车租赁公司出租多种车辆，车型及租金情况如下：</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220122200247448.png" alt="image-20220122200247448"></p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220122200259027.png" alt="image-20220122200259027"></p><h2 id="4、访问修饰符"><a href="#4、访问修饰符" class="headerlink" title="4、访问修饰符"></a>4、访问修饰符</h2><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220117153045707.png" alt="image-20220117153045707"></p><h2 id="5、对象实例化过程"><a href="#5、对象实例化过程" class="headerlink" title="5、对象实例化过程"></a>5、对象实例化过程</h2><p>1&gt;子类继承父类后，就获取了父类中声明的属性和方法 </p><p>2&gt;创建子类的对象，再堆空间中，就会加载所有父类中声明的属性 </p><p>3&gt;当我们通过子类的构造方法创建子类对象时，我们一定会直接或间接的调用其父类的构造方法， 进而调用父类的构造方法，直到调用了Object类中的无参构造方法为止。真是因为加载过所有的父类结 构，所以才可以看到内存中有父类中的结构，子类对象才可以考虑进行调用。虽然子类调用了父类的构 造方法，但是并没有创建父类的对象。 </p><p>无论通过哪个构造器创建子类对象，需要保证先初始化父类。</p><h2 id="6、抽象类"><a href="#6、抽象类" class="headerlink" title="6、抽象类"></a>6、抽象类</h2><p>抽象类用abstract修饰。抽象类不能直接new对象。抽象类中的方法不一定都是抽象方法.</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220122200325590.png" alt="image-20220122200325590"></p><p><strong>抽象类的特点</strong></p><ol><li>抽象类和抽象方法都需要被abstract修饰。抽象方法一定要定义在抽象类中。 </li><li>抽象类不可以创建实例，原因：调用抽象方法没有意义。 </li><li>只有覆盖了抽象类中所有的抽象方法后，其子类才可以实例化。否则该子类还是一个抽象类。</li></ol><p>之所以继承，更多的是在思想，是面对共性类型操作会更简单</p><p><strong>细节问题：</strong></p><ol><li><p>抽象类一定是个父类？是的，因为不断抽取而来的。</p></li><li><p>抽象类是否有构造函数？有，虽然不能给自己的对象初始化，但是可以给自己的子类对象初始化。 抽象类和一般类的<strong>异同点：</strong></p><p>相同：它们都是用来描述事物的。它们之中都可以定义属性和行为。 </p><p>不同：一般类可以具体的描述事物。抽象类描述事物的信息不具体抽象类中可以多定义一个成员：抽象 函数。一般类可以创建对象，而抽象类不能创建对象。</p></li><li><p>抽象类中是否可以不定义抽象方法。是可以的，那这个抽象类的存在到底有什么意义呢？仅仅是不 让该类创建对象。 </p></li><li><p>抽象关键字abstract不可以和哪些关键字共存？final：fianl修饰的类是无法被继承的，而abstract 修饰的类一定要有子类.final修饰的方法无法被覆盖，但是abstract修饰的方法必须要被子类去实现 的。static：静态修饰的方法属于类的，它存在与静态区中，和对象就没关系了。而抽象方法没有 方法体，使用类名调用它没有任何意义。private：私有的方法子类是无法继承到的，也不存在覆 盖，而abstract和private一起使用修饰方法，abstract既要子类去实现这个方法，而private修饰子 类根本无法得到父类这个方法。互相矛盾。 </p></li><li><p>抽象类是不能使用new操作符来初始化的。但是，仍然可以定义它的构造方法，这构造函数在它的 子类的构造函数中调用。即使子类的父类是具体的，这个子类也可以是抽象的。不能使用new操作 符从一个抽象类创建一个实例，但是抽象类可以用作一种数据类型</p></li></ol><p>   <img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220122200354260.png" alt="image-20220122200354260"></p><h2 id="7、抽象方法"><a href="#7、抽象方法" class="headerlink" title="7、抽象方法"></a>7、抽象方法</h2><p>用abstract修饰的方法是抽象方法。</p><p>抽象方法没有方法体。 </p><p>抽象方法没有方法体 抽象方法必须在抽象类里 </p><p>抽象方法必须在子类中被实现，除非子类是抽象类</p><p>抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模板，子类在抽象类的基础上进行 扩展、改造，但子类总体上会保留抽象类的行为方式。 </p><p><strong>解决的问题：</strong> 当功能内部一部分实现是确定的，一部分实现是不确定的。这时可以把不确定的部分暴露 出去，让子类去实现。</p><p>换句话说，在软件开发中实现一个算法时，整体步骤很固定、通用，这些步骤已经在父类中写好 了。但是某些部分易变，易变部分可以抽象出来，供不同子类实现。这就是一种模板模式</p><h2 id="8、final"><a href="#8、final" class="headerlink" title="8、final"></a>8、final</h2><p>final可以修饰属性，方法，类 </p><p>final修饰的属性是常量 </p><p>final修饰的方法，不能被重写，可以被继承</p><p>final修饰的类不能被继承</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220122200436562.png" alt="image-20220122200436562"></p><h3 id="练习：-10"><a href="#练习：-10" class="headerlink" title="练习："></a>练习：</h3><p>1、修改Pet类为抽象类，Pet类中的eat方法为抽象方法，输出Dog信息 </p><p>2、设计Bird、Fish类，都继承自抽象类Animal，实现其方法info()，并打印它们的信息</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220122200547931.png" alt="image-20220122200547931"></p><p>3、Engine(引擎),具有power(功率,整数)属性,相对应的setter和getter方法,work()方法:输出”xx功率 的发动机在运转”。Car(Engine轿车),具有Engine属性,相对应的setter和getter方法,run()方法，在方法中 判断Engine对象是否为null,选择输出”发动机发动不了”或者”xx功率的发动机在运转,汽车在跑”。Benz(奔 驰),继承Car类,重写run()方法Driver(驾驶员),具有属性name(姓名),相对应的setter和getter方 法,driveCar(Benz benz)方法,在方法中输出“xxx 在开车”，并调用benz的run()方法。</p><p>4、写一个名为 Account 的类模拟账户。该类的属性和方法如下图所示。该类包括的属性：账号 id，余额 balance，年利率 annualInterestRate；包含的方法：访问器方法（getter 和setter 方法）， 返回月利率的方法 getMonthlyInterest()，取款方法 withdraw()，存款方法deposit()。创建 Account 类 的一个子类 CheckAccount 代表可透支的账户，该账户中定义一个属性overdraft 代表可透支限额。在 CheckAccount 类中重写 withdraw 方法，其算法如下：如果（取款金额&lt;账户余额），可直接取款如果 （取款金额&gt;账户余额），计算需要透支的额度判断可透支额 overdraft 是否足够支付本次透支需要，如 果可以将账户余额修改为 0，冲减可透支金额如果不可以提示用户超过可透支额的限额</p><p>5、java类是否可以多继承，怎么实现多继承？</p><p>6、代码阅读</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220122200617859.png" alt="image-20220122200617859"></p><p> 7、代码阅读题</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220122200628540.png" alt="image-20220122200628540"></p><p> 8、编写一个Java应用程序，设计一个汽车类Vehicle，包含的属性有车轮个数wheels和车重weight。 小车类Car是Vehicle的子类，其中包含的属性有载人数loader。卡车类Truck是Car类的子类，其中包含 的属性有载重量payload。 </p><p>9、定义员工类Employee，包含姓名、工号和工资，包含计算奖金方法bonus，普通员工和经理都 是员工，计算奖金的方法为工资*奖金系数，普通员工的奖金系数为1.5（常量），经理为2（常量），分 别实现bonus方法，创建对象测试。 </p><p>10、封装一个西游记人物类Person：包含私有属性：姓名（name）、身高（height）、武器 （weapon）、种族（race），并提供get方法和set方法。在测试类中实例化三个对象：tangseng（唐 僧）、sunwukong（孙悟空）、baigujing（白骨精），分别设置他们的种族为：人族、仙族、妖族在 打印对象时，按照例如：“姓名：孙悟空；种族：仙族”的格式在控制台输出信息。提供一个技能方法 void skill()，这个方法根据当前对象name属性判断技能，如果是孙悟空，就打印“七十二变”，如果是唐 僧，就打印“紧箍咒”，如果是白骨精，就打印“九阴白骨爪”，在测试类中调用这个方法。 </p><p>11、阅读如下代码</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220122200655676.png" alt="image-20220122200655676"></p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220122200707738.png" alt="image-20220122200707738"></p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220122200714985.png" alt="image-20220122200714985"></p><h1 id="八、多态"><a href="#八、多态" class="headerlink" title="八、多态"></a>八、多态</h1><h2 id="1-多态"><a href="#1-多态" class="headerlink" title="1.多态"></a>1.多态</h2><p>生活中的多态：不同类型的打印机打印效果不同。</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220117153605257.png" alt="image-20220117153605257"></p><p>同一种事物，由于条件不同，产生的结果也不同 </p><p>生活中的多态：同一个引用类型，使用不同的实例而执行不同操作 </p><p>父类的类型指向子类的实例</p><p>实现多态的方式称为–动态绑定 </p><p>指在执行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。 </p><p>多态的两种表现形式—重载与重写 </p><p>多态的<strong>必要条件</strong>： 要有继承 要有重写 <strong>父类的引用指向子类对象</strong> </p><p>父类更通用，子类更具体 </p><p>Pet pet &#x3D; new Dog();</p><p>Pet pet &#x3D; new Cat(); 这种方式称之为 <strong>向上转型</strong></p><p>子类转换为父类：在进行向上转型后，会发现 子类中特有的属性与方法已经丢失。此时需要进行<strong>向下转型</strong>（强制类型转化）。（容易抛出ClassCastException异常）。为了防止以上异常的出现，可以使用 <em><strong>instanceof</strong></em>判断该实例究竟是哪个类的类型。</p><p><strong>小结：</strong></p><ul><li>多态可以减少类中代码量，可以提高代码的可扩展性和可维护性 </li><li>向上转型——子类转换为父类，自动进行类型转换 </li><li>向下转型——父类转换为子类，结合instanceof运算符进行强制类型转换</li></ul><p><strong>实现多态的两种方式</strong> </p><ul><li><p>使用父类作为方法形参实现多态 </p></li><li><p>使用父类作为方法返回值实现多态 </p></li><li><p>类型转换</p></li></ul><p><strong>基本数据类型：</strong></p><ul><li><p>字节数小的数据类型可以自动转换成大的数据类型</p><p> 如long g&#x3D;20; double d&#x3D;12.0f</p></li><li><p>大的数据类型需要强制转换成小的数据类型 </p><p>如 floate f&#x3D;(float)12.0 int a&#x3D;(int)1200L</p></li></ul><p><strong>复合数据类型：</strong></p><ul><li><p>从子类到父类的类型转换可以自动进行</p></li><li><p>从父类到子类的类型转换必须通过强制类型转换实现</p></li><li><p>无继承关系的引用类型间的转换是非法的</p></li><li><p>在转换前如不确定，可以使用instanceof操作符测试一个对象的类型 Object类</p></li></ul><h2 id="2、Object类"><a href="#2、Object类" class="headerlink" title="2、Object类"></a>2、Object类</h2><p>Object类是所有的Java类的基类，如果一个类没有继承父类，此时默认继承Object类。</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220122200906874.png" alt="image-20220122200906874"></p><h3 id="1、-x3D-x3D-与equals方法"><a href="#1、-x3D-x3D-与equals方法" class="headerlink" title="1、&#x3D;&#x3D; 与equals方法"></a>1、&#x3D;&#x3D; 与equals方法</h3><p>&#x3D;&#x3D;:是一个运算符。可以用在基本数据类型和引用数据类型的变量中。如果比较的是基本数据类型， 比较两个变量保存的值是否相等。如果比较的是引用数据类型，比较两个对象的地址值是否相等。也就 是两个引用是否指向同一个对象。</p><p> equals:是Object类中的方法。只能用在引用数据类型。在Object类中与&#x3D;&#x3D;是一样的，也是比较两个 对象的地址是否相等。但是String，Date,包装类 重写了equals方法，除去比较地址还会比较内容。 </p><p>我们自己的类也可以重写equals方法，会比较类中的属性是否相等。 </p><h4 id="练习：-11"><a href="#练习：-11" class="headerlink" title="练习："></a>练习：</h4><p>定义学生类，有属性，姓名，年龄，电话。如果属性都相等，我们则认为是同一个对象</p><h3 id="2、toString-方法"><a href="#2、toString-方法" class="headerlink" title="2、toString()方法"></a>2、toString()方法</h3><p>toString()方法，打印对象的时候，默认执行toString方法。</p><h3 id="重载和重写的区别："><a href="#重载和重写的区别：" class="headerlink" title="重载和重写的区别："></a><strong>重载和重写的区别：</strong></h3><p><strong>重载</strong>,发生在同一个类中的，方法名相同，参数列表不同。与访问修饰符和返回值类型无关。 </p><p><strong>重写</strong>, 发生在继承关系中的，子类重写父类的方法。方法名相同，参数列表相同，访问修饰符不能比父 类的严格。返回值类型相同或是父类方法返回值类型的子类。</p><p> <strong>重载</strong>，指允许存在多个同名方法，而这些方法的参数不同，编译器根据方法不同，对同名的方法做修 饰，对于编译器而言，这些同名方法就成了不同的方法，他们的调用地址在编译期就绑定了。重载是可 以包含父类和子类的，即子类可以重载父类的同名不同参数的方法。重载，在方法调用之前，编译器就 已经确定了所要调用的方法。称为静态绑定。</p><p><strong>重写</strong>，要等到方法调用那一刻，解释运行器才会确定所要调用的具体方法，称为动态绑定。</p><h3 id="练习：-12"><a href="#练习：-12" class="headerlink" title="练习："></a>练习：</h3><p>1、什么是多态，谈谈你堆多态的理解，多态情况下方法执行 </p><p>2、一个类可以有几个父类，一个父类可以由几个子类，子类能获取父类的构造方法吗？</p><p> 3、重写重载的区别</p><p> 4、super关键字 与this关键字 </p><p>5、抽象类和抽象方法 </p><p>6、final关键字 </p><p>7、多态是编译时行为还是运行时行为？【运行时行为】</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220122201142450.png" alt="image-20220122201142450"></p><p>8、编写Order类，有int型的orderId，String型的orderName，相应的getter()和setter()方法， 两个参数的构造器，重写父类的equals()方法：public boolean equals(Object obj)，并判断测试类中创 建的两个对象是否相等。</p><p> 9、父类GeometricObject代表几何形状，子类Circle代表圆形，MyRectangle代表矩形。定义一个 测试类GeometricTest，编写equalsArea方法测试两个对象的面积是否相等，编写 displayGeometricObject方法显示对象的面积。</p><p>10、编写立体图形类，SolidFigure，必须有属性高，定义圆柱体Cylinde,长方体Rectangular。实 现计算面机getArea和体积的方法getVolume。</p><h2 id="3、static关键字"><a href="#3、static关键字" class="headerlink" title="3、static关键字"></a>3、static关键字</h2><p> 有些属性和方法，希望无论有多少个对象，共享内存中的一份数据。此时可以用static修饰我们的数 和方法。 </p><p>static：静态的。可以修饰属性，方法，代码块以及内部类。 </p><p>static代表静态的。如果使用static声明属性，则该属性称之为称之为静态属性。使用static声明的属 性对所有的对象共享。static修饰的属性属于<strong>类级别</strong>的。对于静态的属性更推荐 使用类名. 的方式直接调 用 </p><p>static：可以修饰成员变量，叫做静态变量。 </p><p>没用static修饰的变量教实例变量，或非静态变量。</p><p> 实例变量：各个对象有自己的独立的非静态属性。一个对象实例属性值的更改，不会影响到其他 对象。</p><p>静态变量：属于类级别的，多个类的对象共享一个静态变量。当通过一个对象更改静态属性的时 候，其他对象获取的是修改后的结果。静态变量随着类的加载而加载，可以通过类名直接调用。静态变 量的加载早于对象的创建。<strong>类只会加载一次，静态变量也是加载一次，存在方法区的静态域中，方法区 中主要保存类的加载信息，静态域，常量池。</strong></p><p>画图理解：</p><p> static:可以修饰方法，叫做静态方法。也是随着类的加载来加载，也是可以通过类名.方式来调 用。静态方法只能调用静态成员。在静态方法内，不能使用this,super关键字。 </p><p>静态结构域类的结构的生命周期是相同的。 </p><p>属性被多个对象共享可以使用static修饰。 </p><p>单例模式:讲解</p><h2 id="4、代码块"><a href="#4、代码块" class="headerlink" title="4、代码块"></a>4、代码块</h2><p> 代码块分为三类，有 普通代码块 构造块 静态代码块</p><p>1） 普通代码块：普通代码块就是指直接在方法或语句中定义的代码块。(了解) </p><p>在方法中定义一个普通代码块。代码块中的num作用范围在大括号结束的时候，就完毕了。 </p><p>2） 构造块：是直接写在类中的代码块 </p><p>可以发现构造块的执行时间在构造方法之前。而且会发现在继续创建对象的时候，构造块还会执行。</p><ol><li>可以有输出语句。 </li><li>可以对类的属性、类的声明进行初始化操作。 </li><li>除了调用非静态的结构外，还可以调用静态的变量或方法。 </li><li>若有多个非静态的代码块，那么按照从上到下的顺序依次执行。 </li><li>每次创建对象的时候，都会执行一次。且先于构造器执行。</li></ol><p>3） 静态代码块：使用static关键字声明的代码块。在以上代码中加入静态代码块。 会发现静态代码块在构造块之前执行。 会发现，静态代码块只会加载一次。</p><ol><li><p>可以有输出语句。 </p></li><li><p>可以对类的属性、类的声明进行初始化操作。 </p></li><li><p>不可以对非静态的属性初始化。即：不可以调用非静态的属性和方法。 </p></li><li><p>若有多个静态的代码块，那么按照从上到下的顺序依次执行。</p></li><li><p>静态代码块的执行要先于非静态代码块</p></li><li><p>静态代码块随着类的加载而加载，且只执行一次。</p></li></ol><p>   <strong>提示：</strong>分别加入两个静态属性与两个非静态属性，给其中一个赋值。断点调试看整个代码的执行过程。 继承关系下的构造方法执行顺序</p><p>   <img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220131095628326.png" alt="image-20220131095628326"></p><p>   继承关系下：父类静态资源-&gt;子类静态资源-&gt;父类非静态资源-&gt;父类构造方法-&gt;子类非静态资源-&gt;子类构造方法</p><h1 id="九、接口"><a href="#九、接口" class="headerlink" title="九、接口"></a>九、接口</h1><p>请大家使用面向对象的思想实现防盗门的功能,大家会怎么设计呢？ </p><p>可以借助接口实现。接口是用interface 修饰的。</p><p><strong>接口的特点：</strong> </p><ul><li>接口不可以被实例化 </li><li>实现类必须实现接口的所有方法 </li><li>实现类可以实现多个接口 </li><li>接口中的变量都是静态常量</li></ul><p>使用程序描述USB接口</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220117154100596.png" alt="image-20220117154100596"></p><p>接口表示一种能力，接口的能力体现在接口的方法上。</p><p><strong>面向接口编程</strong> </p><ul><li><p>在程序设计的时候，<em><strong>关心实现类有何能力，而不关心实现细节</strong></em> </p></li><li><p>如果继承用 is-a 的形式来形容，那么接口就是 has-a </p></li><li><p>一个人可以具有多项能力</p></li></ul><p><strong>接口的特点：</strong> </p><ul><li>一个类可以实现多个接口</li></ul><p><strong>接口有比抽象类更好的特性：</strong></p><ol><li><p>可以被多继承 </p></li><li><p>设计和实现完全分离</p></li><li><p>更自然的使用多态</p></li><li><p>更容易搭建程序框架</p></li><li><p>更容易更换实现</p></li></ol><p>Java中的接口 </p><p>属性全都是全局静态常量 </p><p>方法都是全局抽象方法 </p><p>无构造方法 </p><p>一个类可以实现多个接口，非抽象类实现接口时必须实现接口中的全部方法 </p><p>抽象类利于代码复用，接口利于代码维护. </p><p>接口可以继承接口，而且可以继承多个接口。</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220117154420893.png" alt="image-20220117154420893"></p><p>JDK8中接口的新特点 </p><p>Java 8中，你可以为接口添加静态方法和默认方法。从技术角度来说，这是完全合法的，只是它看起来 违反了接口作为一个抽象定义的理念。 </p><p><strong>静态方法：</strong>使用 static 关键字修饰。可以通过接口直接调用静态方法，并执行其方法体。我们经常在相 互一起使用的类中使用静态方法。 </p><p><strong>默认方法：</strong>默认方法使用 default 关键字修饰。可以通过实现类对象来调用。我们在已有的接口中提供 新方法的同时，还保持了与旧版本代码的兼容性。 </p><p>若一个接口中定义了一个默认方法，而另外一个接口中也定义了一个同名同参数的方法（不管此方法是 否是默认方法），在实现类同时实现了这两个接口时，会出现：<strong>接口冲突</strong>。解决办法：实现类必须覆盖 接口中同名同参数的方法，来解决冲突。</p><p> 若一个接口中定义了一个默认方法，而父类中也定义了一个同名同参数的非抽象方法，则不会出现冲突 问题。因为此时遵守：<strong>类优先原则</strong>。接口中具有相同名称和参数的默认方法会被忽略。</p><h2 id="练习：-13"><a href="#练习：-13" class="headerlink" title="练习："></a>练习：</h2><p>1、牛犇有两个很好的朋友，一个是中国的王小强，喜欢吃四川菜，打太极一个是美国的约翰，喜 欢吃披萨，打橄榄球。每当朋友来拜访的时候，牛犇就会按照他们的喜欢招待他们。</p><p>2、1)下面关于接口的说法中不正确的是（）。</p><p>​A．接口中所有的方法都是抽象的 </p><p>​B．接口中所有的方法都是public访问权限</p><p>​C．子接口继承父接口所用的关键字是implements</p><p>​D．接口是Java中的特殊类，包含常量和抽象方法</p><p>​2)Java语言接口间的继承关系是（）。</p><p>​ A．单继承 B．多重继承 C．不能继承 D．不一定 </p><p>​3)一个类实现接口的情况是（）。</p><p>​A．一次可以实现多个接口 B．一次只能实现一个接口 </p><p>​C．不能实现接口 D．不一定</p><p>3、接口【abstract class】和抽象类【interface】的区别</p><p>4、接口是否可继承接口? 抽象类是否可实现(implements)接口? 抽象类是否可继承实体类(concrete class)?</p><p> 5、代码阅读,以下代碼是否正確？</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220122201950144.png" alt="image-20220122201950144"></p><h1 id="十、内部类"><a href="#十、内部类" class="headerlink" title="十、内部类"></a>十、内部类</h1><p>在java中，允许一个类的定义位于另一个类的内部，前者称为内部类。 </p><p>内部类与外部封装他的类之间存在逻辑上的所属关系。</p><p>Inner class 一般用在定义他的类或语句块之内，在外边引用他时必须给出完整的名字。Inner class 的名字不能与包含他的类的名相同。</p><p> 当一个事物的内部，还有一个部分需要一个完整的结构进行描述，而这个内部的完整的结构又只为外 部事物提供服务，那么整个内部的完整结构最好使用内部类。 </p><p>在Java中，允许一个类的定义位于另一个类的内部，前者称为内部类，后者称为外部类。 </p><p>Inner class一般用在定义它的类或语句块之内，在外部引用它时必须给出完整的名称。 </p><p>Inner class的名字不能与包含它的外部类类名相同；</p><p> <strong>分类： 成员内部类</strong>（static成员内部类和非static成员内部类） 局部内部类不谈修饰符）、匿名内部 类</p><h2 id="1、成员内部类"><a href="#1、成员内部类" class="headerlink" title="1、成员内部类"></a>1、成员内部类</h2><p><strong>成员内部类作为类的成员的角色：</strong> </p><p>和外部类不同，Inner class还可以声明为<strong>private</strong>或<strong>protected</strong>； </p><p>可以调用外部类的结构 </p><p>Inner class 可以声明为<strong>static</strong>的，但此时就不能再使用外层类的非static的成员变量；</p><p> <strong>成员内部类作为类的角色：</strong> </p><p>可以在内部定义属性、方法、构造器等结构 </p><p>可以声明为<strong>abstract</strong>类 ，因此可以被其它的内部类继承 </p><p>可以声明为<strong>final</strong>的 </p><p>编译以后生成OuterClass$InnerClass.class字节码文件（也适用于局部内部类） </p><p><strong>【注意】</strong> </p><ol><li><p>非static的成员内部类中的成员不能声明为static的，只有在外部类或static的成员内部类中才可声 明static成员。 </p></li><li><p>外部类访问成员内部类的成员，需要“内部类.成员”或“内部类对象.成员”的方式 </p></li><li><p>成员内部类可以直接使用外部类的所有成员，包括私有的数据 </p></li><li><p>当想要在外部类的静态成员部分使用内部类时，可以考虑内部类声明为静态的</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220122202303024.png" alt="image-20220122202303024"></p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220122202309846.png" alt="image-20220122202309846"></p><p>Inner class可以声明为抽象类 ，因此可以被其它的内部类继承。也可以声明为final的。和外层类不 同，Inner class可以声明为private或protected；Inner class 可以声明为static的，但此时就不能 再使用外层封装类的非static的成员变量；（静态类的使用直接 ：A.C c &#x3D; <em><strong>new</strong></em> A.C();）非static的 内部类中的成员不能声明为static的，只有在顶层类或static的内部类中才可声明static成员； </p><p>为什么要使用内部类？在《Think in java》中有这样一句话：使用内部类最吸引人的原因是：每个 内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实 现，对于内部类都没有影响。 在我们程序设计中有时候会存在一些使用接口很难解决的问题，这个 时候我们可以利用内部类提供的、可以继承多个具体的或者抽象的类的能力来解决这些程序设计问 题。可以这样说，接口只是解决了部分问题，而内部类使得多重继承的解决方案变得更加完整。使 用内部类最大的优点就在于它能够非常好的解决多重继承的问题，但是如果我们不需要解决多重继 承问题，那么我们自然可以使用其他的编码方式，但是使用内部类还能够为我们带来<strong>如下特性</strong>（摘 自《Think in java》）：</p><p>1、内部类可以用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独 立。 </p><p>2、在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类。 </p><p>3、创建内部类对象的时刻并不依赖于外围类对象的创建。 </p><p>4、内部类并没有令人迷惑的“is-a”关系，他就是一个独立的实体。 </p><p>5、内部类提供了更好的封装，除了该外围类，其他类都不能访问。</p><p>成员内部类也是最普通的内部类，它是外围类的一个成员，所以他是可以无限制的访问外围类的所 有 成员属性和方法，尽管是private的，但是外围类要访问内部类的成员属性和方法则需要通过内 部类实例来访问.</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220122202418732.png" alt="image-20220122202418732"></p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220122202424887.png" alt="image-20220122202424887"></p><p>在成员内部类中要注意两点，<em><strong>第一</strong>：</em>成员内部类中不能存在任何static的变量和方法；<em><strong>第二</strong>：</em> 成员内部类是依附于外围类的，所以只有先创建了外围类才能够创建内部类。 </p><p>成员内部类之静态内部类 </p><p>static修饰的内部类我们称之为静态内部类，不过我们更喜欢称之为嵌套内部类。静态内部类与非 静态内部类之间存在一个最大的区别，我们知道非静态内部类在编译完成之后会隐含地保存着一个 引用，该引用是指向创建它的外围内，但是静态内部类却没有。没有这个引用就意味着：它的创建 是不需要依赖于外围类的。它不能使用任何外围类的非static成员变量和方法。</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220122202503538.png" alt="image-20220122202503538"></p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220211205832822.png" alt="image-20220211205832822"></p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220211205845431.png" alt="image-20220211205845431"></p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220211205901809.png" alt="image-20220211205901809"></p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220211205911497.png" alt="image-20220211205911497"></p></li></ol><h2 id="2、局部内部类"><a href="#2、局部内部类" class="headerlink" title="2、局部内部类"></a>2、局部内部类</h2><p> 局部嵌套类，简称局部类，局部类所属范围：在块、构造器以及方法内，这里的块包括普通块和静 态块。局部类只在本块范围内有效。局部类是嵌套类，但不是成员类，而且有名称（不是匿名 类）。 只能在声明它的方法或代码块中使用，而且是先声明后使用。除此之外的任何地方都不能使用该类 但是它的对象可以通过外部方法的返回值返回使用，返回值类型只能是局部内部类的父类或父接口 类型</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220122202618825.png" alt="image-20220122202618825"></p><p>内部类仍然是一个独立的类，在编译之后内部类会被编译成独立的.class文件，但是前面冠以外部 类的类名和$符号，以及数字编号。、 只能在声明它的方法或代码块中使用，而且是先声明后使用。除此之外的任何地方都不能使用该 类。</p><p> 局部内部类可以使用外部类的成员，包括私有的。 </p><p>局部内部类可以使用外部方法的局部变量，但是必须是final的。由局部内部类和局部变量的声明周 期不同所致。</p><p> 局部内部类和局部变量地位类似，不能使用public,protected,缺省,private </p><p>局部内部类不能使用static修饰，因此也不能包含静态成员</p><h2 id="3、匿名内部类"><a href="#3、匿名内部类" class="headerlink" title="3、匿名内部类"></a>3、匿名内部类</h2><p> 匿名类，就是没有名称的类，其名称由Java编译器给出，一般是形如：外部类名称+$+匿名类顺 序，没有名称也就是其他地方就不能引用，不能实例化，只用一次，当然也就不能有构造器。 匿名类根据位于地方不同分为：成员匿名类和局部匿名类。</p><p> 匿名类不能使用任何关键字和访问控制符，匿名类和局部类访问规则一样，只不过内部类显式的定 义了一个类，然后通过new的方式创建这个局部类实例，而匿名类直接new一个类实例，没有定义 这个类。匿名类最常见的方式就是回调模式的使用，通过默认实现一个接口创建一个匿名类然后， 然后new这个匿名类的实例。</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220122202803546.png" alt="image-20220122202803546"></p><h1 id="十一、异常"><a href="#十一、异常" class="headerlink" title="十一、异常"></a>十一、异常</h1><p>1、异常概述与体现结构 </p><p>​异常：在Java语言中，将程序执行中发生的不正常情况称为“异常”。 (开发过程中的语法错误和逻 辑错误不是异常) </p><p>Java程序在执行过程中所发生的异常事件可分为两类： </p><p>​1&gt;Error：Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。比 如：StackOverflowError和OOM。一般不编写针对性的代码进行处理。 </p><p>​2&gt;Exception:其它因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行 处理。例如：空指针异常，数组下标越界异常。</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220211210016410.png" alt="image-20220211210016410"></p><p>​3&gt;Exception下异常又可以分为 运行时异常 和 编译时异常 </p><p>​1)运行时异常是指编译器不要求强制处置的异常。一般是指编程时的逻辑错误，是程序员应该 积极避免其出现的异常。<strong>java.lang.RuntimeException</strong>类及它的子类都是运行时异常。对于这类异 常，可以不作处理，因为这类异常很普遍，若全处理可能会对程序的可读性和运行效率产生影响。 </p><p>​2）是指编译器要求必须处置的异常。即程序在运行时由于外界因素造成的一般性异常。编译 器要求Java程序必须捕获或声明所有编译时异常。对于这类异常，如果程序不处理，可能会带来意想不 到的结果。 </p><p>2、异常处理机制 </p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220211210125322.png" alt="image-20220211210125322"></p><p>​Java采用的异常处理机制，是将异常处理的程序代码集中在一起，与正常的程序代码分开，使得 程序简洁、优雅，并易于维护 </p><p>​1&gt;捕获异常 try-catch-finally：如果一个方法内抛出异常，该异常对象会被抛给调用者方法中处 理。如果异常没有在调用者方法中处理，它继续被抛给这个调用方法的上层方法。这个过程将一直继续 下去，直到异常被处理。这一过程称为捕获(catch)异常。 如果一个异常回到main()方法，并且main()也 不处理，则程序运行终止。 程序员通常只能处理Exception，而对Error无能为力。</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220211210200278.png" alt="image-20220211210200278"></p><p>try捕获异常的第一步是用try{…}语句块选定捕获异常的范围，将可能出现异常的代码放在try语句块 中。 </p><p>catch (Exceptiontype e)在catch语句块中是对异常对象进行处理的代码。每个try语句块可以伴随 一个或多个catch语句，用于处理可能产生的不同类型的异常对象。 </p><p>捕获异常的有关信息：与其它对象一样，可以访问一个异常对象的成员变量或调用它的方法。 </p><p>getMessage() 获取异常信息，返回字符串 </p><p>printStackTrace() 获取异常类名和异常信息，以及异常出现在程序中的位置。返回值void。 </p><p>finally 捕获异常的最后一步是通过finally语句为异常处理提供一个统一的出口，使得在控制流转到 程序的其它部分以前，能够对程序的状态作统一的管理。 </p><p>不论在try代码块中是否发生了异常事件，catch语句是否执行，catch语句是否有异常，catch语句 中是否有return，finally块中的语句都会被执行。finally语句和catch语句是任选的。 </p><p>前面使用的异常都是RuntimeException类或是它的子类，这些类的异常的特点是：即使没有使用try 和catch捕获，Java自己也能捕获，并且编译通过( 但运行时会发生异常使得程序运行终止 )。</p><p>如果抛出的异常是IOException等类型的非运行时异常，则必须捕获，否则编译错误。也就是说，我 们必须处理编译时异常，将异常进行捕捉，转化为运行时异常 </p><ol><li>正常情况</li></ol><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220211210307721.png" alt="image-20220211210307721"></p><ol start="2"><li><p>异常情况</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220211210335833.png" alt="image-20220211210335833"></p></li><li><p>异常类型不匹配</p></li></ol><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220211210343959.png" alt="image-20220211210343959"></p><ol start="4"><li><p>finally：在try&#x2F;catch块后加入finally块，可以确保无论是否发生异常，finally块中的代码总能 被执行.</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220211210402237.png" alt="image-20220211210402237"></p></li></ol><p>2&gt;声明异常：声明抛出异常是Java中处理异常的第二种方式。 </p><p>如果一个方法(中的语句执行时)可能生成某种异常，但是并不能确定如何处理这种异常，则此方法 应显示地声明抛出异常，表明该方法将不对这些异常进行处理，而由该方法的调用者负责处理。在方法 声明中用throws语句可以声明抛出异常的列表，throws后面的异常类型可以是方法中产生的异常类型， 也可以是它的父类。 </p><p>3&gt;抛出异常Java程序的执行过程中如出现异常，会生成一个异常类对象，该异常对象将被提交给 Java运行时系统，这个过程称为抛出(throw)异常。 </p><p>3、自定义异常一般地，用户自定义异常类都是RuntimeException的子类。 自定义异常类通常需要 编写几个重载的构造器。 自定义异常需要提供serialVersionUID 自定义的异常通过throw抛出。 自定义 异常最重要的是异常类的名字，当异常出现时，可以根据名字判断异常类型。 </p><h2 id="练习：-14"><a href="#练习：-14" class="headerlink" title="练习："></a>练习：</h2><p>1、运行时异常与一般异常有何异同 </p><p>2、Java中的异常处理机制的简单原理和应用 </p><p>3、JAVA语言如何进行异常处理，关键字：throws,throw,try,catch,finally分别代表什么意义？在 try块中可以抛出异常吗？ </p><p>4、try {}里有一个return语句，那么紧跟在这个try后的finally {}里的code会不会被执行，什么时 候被执行，在return前还是后? </p><p>5、error和exception有什么区别。 </p><p>6、写出以下代码的运行结果</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220220200840313.png" alt="image-20220220200840313"></p><p>7、写出以下代码的结果</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220220200925619.png" alt="image-20220220200925619"></p><p> 8、写出程序结果</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220220200950637.png" alt="image-20220220200950637"></p><p>9、写出如下代码的运行结果</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220220201006466.png" alt="image-20220220201006466"></p><p> 10、写出如下代码的运行结果</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220220201020201.png" alt="image-20220220201020201"></p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220220201030946.png" alt="image-20220220201030946"></p><h1 id="十二、常用类"><a href="#十二、常用类" class="headerlink" title="十二、常用类"></a>十二、常用类</h1><h2 id="1、基本数据类和引用数据类型"><a href="#1、基本数据类和引用数据类型" class="headerlink" title="1、基本数据类和引用数据类型"></a>1、基本数据类和引用数据类型</h2><p>八种基本数据类型有对应的包装类型，认识基本数据类型与包装类型之间的转化。同时知道数组转化为 字符串，以及将字符串转化为数值类型。 </p><p><strong>装箱：</strong>将基本数据类型转化为包装类型称之为装箱</p><p>int i &#x3D; 500; Integer t &#x3D; new Integer(i); </p><p>Float f &#x3D; new Float(“4.56”); </p><p><strong>拆箱：</strong>将包装类型转化为基本数据类型称之为拆箱 </p><p>boolean b &#x3D; bObj.booleanValue(); </p><p><strong>字符串转换成基本数据类型</strong> </p><p>通过包装类的构造器实现：int i &#x3D; new Integer(“12”); </p><p>通过包装类的parseXxx(String s)静态方法：Float f &#x3D; Float.parseFloat(“12.1”); </p><p><strong>基本数据类型转换成字符串</strong> 调用字符串重载的valueOf()方法：String fstr &#x3D; String.valueOf(2.34f); </p><p>更直接的方式：String intStr &#x3D; 5 +</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220220201207616.png" alt="image-20220220201207616"></p><h3 id="练习：-15"><a href="#练习：-15" class="headerlink" title="练习："></a>练习：</h3><p>1、写出如下代码的结果</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220220201218906.png" alt="image-20220220201218906"></p><h2 id="2、String类"><a href="#2、String类" class="headerlink" title="2、String类"></a>2、String类</h2><p>String类代表字符串。Java程序中的所有字符串字面值都是此类的实例实现。String类是一个final 类，代表不可变的字符串。字符串是常量，用双引号引起来表示。他们的值在创建后不能更改。Sting对 象的字符串内容是存储在一个字符数组value[]中的。String如果直接赋值，是将字符串保存到方法区中 的常量池中。如果new,会在堆中，然后堆再指向方法区常量池中的字符串。字符串存储再常量池中的目 的是共享。<strong>只要其中有一个是变量，结果就在堆中</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">结论：</span><br><span class="line">常量与常量的拼接结果在常量池。且常量池中不会存在相同内容的常量.</span><br><span class="line">只要其中有一个是变量，结果就在堆中</span><br><span class="line">如果拼接的结果调用intern()方法，返回值就在常量池中</span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">说明：在字符串常量池中创建了一个字面量为<span class="string">&quot;a&quot;</span>的字符串。</span><br><span class="line">s1 = s1 + <span class="string">&quot;b&quot;</span>;</span><br><span class="line">说明：实际上原来的“a”字符串对象已经丢弃了，现在在堆空间中产生了一个字符串s1+<span class="string">&quot;b&quot;</span>（也就是<span class="string">&quot;ab&quot;</span>)。如果多次执行这些改变串内容的操作，会导致大量副本字符串对象存留在内存中，降低效率。如果这样的操作放到循环中，会极大影响程序的性能。</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">说明：直接在字符串常量池中创建一个字面量为<span class="string">&quot;ab&quot;</span>的字符串。</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span>;</span><br><span class="line">说明：s3指向字符串常量池中已经创建的<span class="string">&quot;ab&quot;</span>的字符串。</span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1.intern();</span><br><span class="line">说明：堆空间的s1对象在调用intern()之后，会将常量池中已经存在的<span class="string">&quot;ab&quot;</span>字符串赋值给s4。</span><br></pre></td></tr></table></figure><p>字符串常用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">length</span><span class="params">()</span>：返回字符串的长度： <span class="keyword">return</span> value.length</span><br><span class="line"><span class="type">char</span> <span class="title function_">charAt</span><span class="params">(<span class="type">int</span> index)</span>： 返回某索引处的字符<span class="keyword">return</span> value[index]<span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>：判断是否是空字符串：<span class="keyword">return</span> value.length == <span class="number">0</span> String <span class="title function_">toLowerCase</span><span class="params">()</span>：使用默认语言环境，将 String 中的所有字符转换为小写</span><br><span class="line">String <span class="title function_">toUpperCase</span><span class="params">()</span>：使用默认语言环境，将 String 中的所有字符转换为大写</span><br><span class="line">String <span class="title function_">trim</span><span class="params">()</span>：返回字符串的副本，忽略前导空白和尾部空白</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>：比较字符串的内容是否相同</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">equalsIgnoreCase</span><span class="params">(String anotherString)</span>：与equals方法类似，忽略大小写</span><br><span class="line">String <span class="title function_">concat</span><span class="params">(String str)</span>：将指定字符串连接到此字符串的结尾。 等价于用“+”<span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(String anotherString)</span>：比较两个字符串的大小</span><br><span class="line">String <span class="title function_">substring</span><span class="params">(<span class="type">int</span> beginIndex)</span>：返回一个新的字符串，它是此字符串的从beginIndex开始截取到最后的一个子字符串。String <span class="title function_">substring</span><span class="params">(<span class="type">int</span> beginIndex, <span class="type">int</span> endIndex)</span> ：返回一个新字符串，它是此字符串从beginIndex开始截取到endIndex(不包含)的一个子字符串。</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">endsWith</span><span class="params">(String suffix)</span>：测试此字符串是否以指定的后缀结束</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String prefix)</span>：测试此字符串是否以指定的前缀开始</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String prefix, <span class="type">int</span> toffset)</span>：测试此字符串从指定索引开始的子字符串是否以指定前缀开始</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(CharSequence s)</span>：当且仅当此字符串包含指定的 <span class="type">char</span> 值序列时，返回 <span class="literal">true</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(String str)</span>：返回指定子字符串在此字符串中第一次出现处的索引</span><br><span class="line"><span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(String str, <span class="type">int</span> fromIndex)</span>：返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始</span><br><span class="line"><span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(String str)</span>：返回指定子字符串在此字符串中最右边出现处的索引</span><br><span class="line"><span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(String str, <span class="type">int</span> fromIndex)</span>：返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索</span><br><span class="line">注：indexOf和lastIndexOf方法如果未找到都是返回-<span class="number">1</span></span><br><span class="line">String <span class="title function_">replace</span><span class="params">(<span class="type">char</span> oldChar, <span class="type">char</span> newChar)</span>：返回一个新的字符串，它是通过用newChar 替换此字符串中出现的所有 oldChar 得到的。</span><br><span class="line">String <span class="title function_">replace</span><span class="params">(CharSequence target, CharSequence replacement)</span>：使用指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串。</span><br><span class="line">String <span class="title function_">replaceAll</span><span class="params">(String regex, String replacement)</span> ： 使用给定的replacement替换此字符串所有匹配给定的正则表达式的子字符串。</span><br><span class="line">String <span class="title function_">replaceFirst</span><span class="params">(String regex, String replacement)</span> ： 使用给定的replacement替换此字符串匹配给定的正则表达式的第一个子字符串。</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(String regex)</span>：告知此字符串是否匹配给定的正则表达式。</span><br><span class="line">String[] split(String regex)：根据给定正则表达式的匹配拆分此字符串。</span><br><span class="line">String[] split(String regex, <span class="type">int</span> limit)：根据匹配给定的正则表达式来拆分此字符串，最多不超过limit个，如果超过了，剩下的全部都放到最后一个</span><br></pre></td></tr></table></figure><p>String特点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String:字符串，使用一对<span class="string">&quot;&quot;</span>引起来表示。</span><br><span class="line"><span class="number">1.</span>String声明为<span class="keyword">final</span>的，不可被继承</span><br><span class="line"><span class="number">2.</span>String实现了Serializable接口：表示字符串是支持序列化的。</span><br><span class="line">实现了Comparable接口：表示String可以比较大小</span><br><span class="line"><span class="number">3.</span>String内部定义了<span class="keyword">final</span> <span class="type">char</span>[] value用于存储字符串数据</span><br><span class="line"><span class="number">4.</span>String:代表不可变的字符序列。简称：不可变性。</span><br><span class="line">体现：<span class="number">1.</span>当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。</span><br><span class="line"> <span class="number">2.</span> 当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</span><br><span class="line"> <span class="number">3.</span> 当调用String的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</span><br><span class="line"> <span class="number">5.</span>通过字面量的方式（区别于<span class="keyword">new</span>）给一个字符串赋值，此时的字符串值声明在字符串常量池中。</span><br><span class="line"> <span class="number">6.</span>字符串常量池中是不会存储相同内容的字符串的。</span><br></pre></td></tr></table></figure><h2 id="3、StringBuffer类"><a href="#3、StringBuffer类" class="headerlink" title="3、StringBuffer类"></a>3、StringBuffer类</h2><p>java.lang.StringBuffer代表<strong>可变的字符序列</strong>，JDK1.0中声明，可以对字符串内容进行增删，此时不会产 生新的对象。很多方法与String相同。作为参数传递时，方法内部可以改变值。 </p><p>StringBuffer类不同于String，其对象必须使用构造器生成。有三个构造器： </p><p>扩容问题:如果要添加的数据底层数组盛不下了，那就需要扩容底层的数组。 </p><p>​默认情况下，扩容为原来容量的2倍 + 2，同时将原有数组中的元素复制到新的数组中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">指导意义：开发中建议大家使用：StringBuffer(<span class="type">int</span> capacity) 或</span><br><span class="line">StringBuilder(<span class="type">int</span> capacity)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer()：初始容量为<span class="number">16</span>的字符串缓冲区</span><br><span class="line">StringBuffer(<span class="type">int</span> size)：构造指定容量的字符串缓冲区</span><br><span class="line">StringBuffer(String str)：将内容初始化为指定字符串内容</span><br></pre></td></tr></table></figure><p>StringBuffer常用的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer <span class="title function_">append</span><span class="params">(xxx)</span>：<span class="comment">//提供了很多的append()方法，用于进行字符串拼接</span></span><br><span class="line">StringBuffer <span class="title function_">delete</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span> end)</span>：<span class="comment">//删除指定位置的内容</span></span><br><span class="line">StringBuffer <span class="title function_">replace</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end, String str)</span>：<span class="comment">//把[start,end)位置替换为str</span></span><br><span class="line">StringBuffer <span class="title function_">insert</span><span class="params">(<span class="type">int</span> offset, xxx)</span>：<span class="comment">//在指定位置插入xxx</span></span><br><span class="line">StringBuffer <span class="title function_">reverse</span><span class="params">()</span> ：<span class="comment">//把当前字符序列逆转</span></span><br></pre></td></tr></table></figure><h2 id="4、StringBuilder类"><a href="#4、StringBuilder类" class="headerlink" title="4、StringBuilder类"></a>4、StringBuilder类</h2><p>StringBuilder 和 StringBuffer 非常类似，均代表可变的字符序列，而且提供相关功能的方法也一样 面试题：对比String、StringBuffer、StringBuilder </p><p>String(JDK1.0)：不可变字符序列 </p><p>StringBuffer(JDK1.0)：可变字符序列、效率低、线程安全 </p><p>tringBuilder(JDK 5.0)：可变字符序列、效率高、线程不安全 </p><p>注意：作为参数传递的话，方法内部String不会改变其值，StringBuffer和StringBuilder会改变其值。 </p><p>String、StringBuffer、StringBuilder三者的异同？ </p><p>String:不可变的字符序列；底层使用char[]存储 </p><p>StringBuffer:可变的字符序列；线程安全的，效率低；底层使用char[]存储 </p><p>StringBuilder:可变的字符序列；jdk5.0新增的，线程不安全的，效率高；底层使用char[]存储。</p><h3 id="练习：-16"><a href="#练习：-16" class="headerlink" title="练习："></a>练习：</h3><p>1、画出内容结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String s1=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">String s2=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">String s3=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">s1+=<span class="string">&quot;world&quot;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2、String是可变的吗？String可以被继承吗？为什么？ </p><p>3、String s&#x3D;new String(“hello”);再内存中创建了几个对象？ </p><p>4、String,StringBuffer,StingBuilder三者对比 </p><p>5、说出String类常用的方法 </p><p>6、字符串反转，给定字符串，给定起始位置和结束位置，对字符串进行反转</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">reverse</span><span class="params">(String str,<span class="type">int</span> start,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">    <span class="type">char</span>[]arr= str.toCharArray();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=start,j=end;i&lt;j;i++,j--)&#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i]=arr[j];</span><br><span class="line">        arr[j]=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(arr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> reverse(<span class="string">&quot;helloworld&quot;</span>,<span class="number">2</span>,<span class="number">8</span>);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>7、获取一个字符串再另一个字符串中出现的次数。比如“ab”在“abcccabddddabeeeeaaaaab“中出现的 次数”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">(String mainWords,String subWords)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(mainWords.length()&gt;subWords.length())&#123;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> index;</span><br><span class="line">        <span class="type">int</span> mainLength=mainWords.length();</span><br><span class="line">        <span class="type">int</span> subLength=subWords.length();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> ((index=mainWords.indexOf(subWords))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            mainWords=mainWords.substring(index+subLength);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> getCount(<span class="string">&quot;abcccabddddabeeeeaaaaab&quot;</span>,<span class="string">&quot;ab&quot;</span>);</span><br><span class="line">        System.out.println(count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">(String mainWords,String subWords)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(mainWords.length()&gt;subWords.length())&#123;</span><br><span class="line">            <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>((index=mainWords.indexOf(subWords,index))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            index+=subWords.length();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 8、查找最大相同字串”aabbccadeahellocadfasfdas“,与字符串”aaellocc“最大相同字串是”elloc“。【只 有一个相同字符串】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getSameWord</span><span class="params">(String maxStr,String minStr)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;minStr.length();i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">0</span>,y=minStr.length()-i;y&lt;=minStr.length();x++,y++)&#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">subStr</span> <span class="operator">=</span> minStr.substring(x,y);</span><br><span class="line">        <span class="keyword">if</span>(maxStr.contains(subStr))&#123;</span><br><span class="line">        <span class="keyword">return</span> subStr;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>9、写出以下代码的运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">sb.append(str);</span><br><span class="line">System.out.println(sb.length());</span><br><span class="line">System.out.println(sb);</span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(str);</span><br><span class="line">System.out.println(sb1);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="5、日期类型"><a href="#5、日期类型" class="headerlink" title="5、日期类型"></a>5、日期类型</h2><h3 id="1-gt-System类"><a href="#1-gt-System类" class="headerlink" title="1&gt;System类"></a>1&gt;System类</h3><p>System类提供的public static long currentTimeMillis()用来返回当前时间与1970年1月1日0时0分0秒之 间以毫秒为单位的时间差。<strong>此方法适于计算时间差。</strong> </p><h3 id="2-gt-java-util-Date类"><a href="#2-gt-java-util-Date类" class="headerlink" title="2&gt;java.util.Date类"></a>2&gt;java.util.Date类</h3><p>Date()：使用无参构造器创建的对象可以获取本地当前时间。 </p><p>Date(long date)： </p><p><strong>常用的方法：</strong> </p><p>getTime():返回自 1970 年 1 月 1 日 00:00:00 GMT 以来此 Date 对象表示的毫秒数。 </p><p>toString():把此 Date 对象转换为以下形式的 String： dow mon ddhh:mm:ss zzz yyyy 其中： dow 是 一周中的某一天 (Sun, Mon, Tue, Wed, Thu, Fri, Sat)，zzz是时间标准</p><h3 id="3-gt-SimpleDateFormat类"><a href="#3-gt-SimpleDateFormat类" class="headerlink" title="3&gt;SimpleDateFormat类"></a>3&gt;SimpleDateFormat类</h3><p>Date类的API不易于国际化，大部分被废弃了，java.text.SimpleDateFormat类是一个不与语言环境有 关的方式来格式化和解析日期的具体类。 </p><p>它允许进行格式化：日期文本、解析：文本日期 </p><p><strong>格式化： SimpleDateFormat()</strong> ：默认的模式和语言环境创建对象 </p><p><strong>public SimpleDateFormat(String pattern)：</strong>该构造方法可以用参数pattern指定的格式创建一个 对象，该对象调用： </p><p>**public String format(Date date)**：方法格式化时间对象date </p><p><strong>解析： public Date parse(String source)：</strong>从给定字符串的开始解析文本，以生成一个日期</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220220202002426.png" alt="image-20220220202002426"></p><h3 id="4-gt-java-util-Calendar-日历-类"><a href="#4-gt-java-util-Calendar-日历-类" class="headerlink" title="4&gt; java.util.Calendar(日历)类"></a>4&gt; java.util.Calendar(日历)类</h3><p>Calendar是一个抽象基类，主用用于完成日期字段之间相互操作的功能。 </p><p>获取Calendar实例的方法 </p><p>使用Calendar.getInstance()方法 调用它的子类GregorianCalendar的构造器。 </p><p>一个Calendar的实例是系统时间的抽象表示，通过get(int field)方法来取得想要的时间信息。比如 YEAR、MONTH、DAY_OF_WEEK、HOUR_OF_DAY 、MINUTE、SECOND</p><p>public void set(int field,int value) </p><p>public void add(int field,int amount) </p><p>public final Date getTime() </p><p>public final void setTime(Date date) </p><p><strong>注意</strong> </p><p>获取月份时：一月是0，二月是1，以此类推，12月是11 </p><p>获取星期时：周日是1，周二是2 ， 。。。。周六是7 </p><h2 id="6、Math类"><a href="#6、Math类" class="headerlink" title="6、Math类"></a>6、Math类</h2><p>java.lang.Math提供了一系列静态方法用于科学计算。其方法的参数和返回值类型一般为double型。 </p><h2 id="7、BigInteger与BigDecimal"><a href="#7、BigInteger与BigDecimal" class="headerlink" title="7、BigInteger与BigDecimal"></a>7、BigInteger与BigDecimal</h2><p>Integer类作为int的包装类，能存储的最大整型值为2 31-1，Long类也是有限的，最大为2 63-1。如果要 表示再大的整数，不管是基本数据类型还是他们的包装类都无能为力，更不用说进行运算了。 </p><p>java.math包的<strong>BigInteger</strong>可以表示不可变的任意精度的整数。BigInteger 提供所有 Java 的基本 整数操作符的对应物，并提供 java.lang.Math 的所有相关方法。另外，BigInteger 还提供以下运算：模 算术、GCD 计算、质数测试、素数生成、位操作以及一些其他操作。 </p><p>构造器 <strong>BigInteger</strong>(String val)：根据字符串构建BigInteger对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> BigInteger <span class="title function_">abs</span><span class="params">()</span>：返回此 BigInteger 的绝对值的 BigInteger。</span><br><span class="line">BigInteger <span class="title function_">add</span><span class="params">(BigInteger val)</span> ：返回其值为 (<span class="built_in">this</span> + val) 的 BigInteger</span><br><span class="line">BigInteger <span class="title function_">subtract</span><span class="params">(BigInteger val)</span> ：返回其值为 (<span class="built_in">this</span> - val) 的 BigInteger</span><br><span class="line">BigInteger <span class="title function_">multiply</span><span class="params">(BigInteger val)</span> ：返回其值为 (<span class="built_in">this</span> * val) 的 BigInteger</span><br><span class="line">BigInteger <span class="title function_">divide</span><span class="params">(BigInteger val)</span> ：返回其值为 (<span class="built_in">this</span> / val) 的 BigInteger。整数相除只保留整数部分。</span><br><span class="line">BigInteger <span class="title function_">remainder</span><span class="params">(BigInteger val)</span> ：返回其值为 (<span class="built_in">this</span> % val) 的 BigInteger。BigInteger[] divideAndRemainder(BigInteger val)：返回包含 (<span class="built_in">this</span> / val) 后跟(<span class="built_in">this</span> % val) 的两个 BigInteger 的数组。</span><br><span class="line">BigInteger <span class="title function_">pow</span><span class="params">(<span class="type">int</span> exponent)</span> ：返回其值为 (thisexponent) 的BigInteger。</span><br></pre></td></tr></table></figure><h3 id="BigDecimal类"><a href="#BigDecimal类" class="headerlink" title="BigDecimal类"></a>BigDecimal类</h3><p>一般的Float类和Double类可以用来做科学计算或工程计算，但在商业计算中，要求数字精度比较高， 故用到java.math.BigDecimal类。BigDecimal类支持不可变的、任意精度的有符号十进制定点数。 </p><h2 id="8、Comparable接口与Compator接口"><a href="#8、Comparable接口与Compator接口" class="headerlink" title="8、Comparable接口与Compator接口"></a>8、Comparable接口与Compator接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">class</span> <span class="title class_">student</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;student&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Integer score;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSex</span><span class="params">(String sex)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(Integer age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getScore</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setScore</span><span class="params">(Integer score)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">student</span><span class="params">(Integer id, String name, String sex, Integer age, Integer score)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(student s)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.age.compareTo(s.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="十三、线程"><a href="#十三、线程" class="headerlink" title="十三、线程"></a>十三、线程</h1><h2 id="1、基本概念"><a href="#1、基本概念" class="headerlink" title="1、基本概念"></a>1、基本概念</h2><p>​程序：为了完成特定任务，用某种语言编写的一组指令的集合。是一段静态的代码，静态对象。 </p><p>​进程：是程序的一次执行过程，或是正在运行的一个程序。是一个动态的过程。有他自身的产生， 存在和消亡的过程。【生命周期】程序是静态的，进程是动态的。进程做为资源的分配单位，系统在运 行时会为每个进程分配不同的内存区域。 </p><p>​线程：线程是程序的执行单元。是程序使用CPU的最基本单位。一个进程的执行，是靠线程来走 的。</p><p>​程序可以进一步细化为线程，是一个程序内部的一条执行路径。若一个进程同一时间并行执 行多个线程，就是支持多线程的。线程做为调度和执行的单位，每个线程拥有独立的运行栈和程序计算 器，线程切换的开销小。一个进程中的多个线程共享相同的内存单元|内存地址。他们从同一堆中分配对 象，可以访问相同的变量和对象。这就使得线程间通信更简洁，高效。但多个线程操作共享的系统资源 可能会带来安全隐患。 </p><p>​单核CPU和多核CPU：单核CPU，其实是一种假的多线程。因为再一个时间单元内，也只能执行一 个线程的任务。因为CPU时间单元特别短，因此感觉不出来。多核的话，才能更好的发挥多线程的效 率。一个java程序java.exe,至少三个线程main()主线程，gc()垃圾回收线程，异常处理线程。如果发生异 常，会影响主线程。 </p><p>​并行域并发：并行： 多个CPU同时执行多个任务。也就是 多人同时做不同的事情。 </p><p>​并发：一个CPU(采用时间片)同时执行多个任务。比如，秒杀，多人做同一件事。 </p><p>​多线程的优点：以单核CPU为例，只使用单个线程 先后完成多个任务（调用多个方法），肯定比 用多个线程来完成用的时间更短，为何仍徐多线程呢？多线程的优点：1&gt;提供应用程序的响应，对图形 化界面更有意义，可增强用户体验。提供计算机系统CPU的利用率。改善程序结构，将既长又复杂的进 程分为多个线程，独立运行，利用理解和修改。 </p><p>​什么时候需要多线程呢？程序需要同时执行两个或多个任务 </p><p>​程序需要实现一些需要等待的任务时，如用户输入，文件读写操作，网络操作，搜索等。 </p><p>​需要一些后台执行的程序时。 </p><h2 id="2、-线程的创建和使用"><a href="#2、-线程的创建和使用" class="headerlink" title="2、 线程的创建和使用"></a>2、 线程的创建和使用</h2><p>​之前的程序都是单线程的。 </p><p>​方式一: JAVA语言的JVM允许程序运行多个线程，它通过java.lang.Thread类来体现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread01</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;i++) &#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;---&quot;</span>+i);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread01Test</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread01</span> <span class="variable">thread01</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread01</span>();</span><br><span class="line">        thread01.setName(<span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">        <span class="comment">//thread01.run();//不会启动线程的，现在的程序还是单线程的程序</span></span><br><span class="line">        thread01.start();<span class="comment">//启动线程</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">MyThread01</span> <span class="variable">thread02</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread01</span>();</span><br><span class="line">        thread02.setName(<span class="string">&quot;线程2&quot;</span>);</span><br><span class="line">        thread02.start();<span class="comment">//启动线程</span></span><br><span class="line">        </span><br><span class="line">        thread01.start();<span class="comment">//启动线程</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;i++) &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>     Thread类的特点：每个线程都说通过某个特定的Thread对象的run()方法来完成操作的，经常把run() 方法的主体称为线程体。我们再使用的时候，是通过调用start()方法来启动这个线程的。 一个线程对象 只能调用一次start()方法启动线程。如果重复调用就会抛出异常&quot;IllegalThreadStateException&quot; </code></pre><p>​方式二：实现Runnable接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread02</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThread02</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    System.out.println(name + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread02</span> <span class="variable">thread01</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread02</span>(<span class="string">&quot;线程01&quot;</span>);</span><br><span class="line">        <span class="type">MyThread02</span> <span class="variable">thread02</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread02</span>(<span class="string">&quot;线程02&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(thread01);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(thread02);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3、线程状态"><a href="#3、线程状态" class="headerlink" title="3、线程状态"></a>3、线程状态</h2><p>​新建(New)：在程序中用构造方法创建了一个线程对象后，新的线程对象便处于新建状态，此 时，他已经有了相应的内存空间和其他资源，但还不处于可运行状态。 </p><p>​就绪(Runnable)：新建线程对象后，可调用线程的start()方法就可以启动线程。当线程启动时， 线程进入就绪状态。此时，线程将进入线程队列排队，等待CPU服务，这表名他已经具备了运行条件 </p><p>​运行(Running)：当就绪状态的线程被调用并获得处理器资源时，线程就进入了运行状态。此 时，自动调用该线程对象的run()方法。run()方法定义了该线程的操作和功能。 </p><p>​阻塞(Blocked)：一个正在执行的线程在某些特殊情况下，如被认为挂起或需要执行耗时的输入&#x2F; 输出操作时，会让出CPU并暂时终止自己的行为，进入堵塞状态，在可执行状态下，如果调用 sleep(),suspend().wait()等方法，线程将进入堵塞状态。堵塞时，线程不能进入排队队列，只有当引起 堵塞的原因被消除后，线程才可以转入就绪状态。线程调用了sleep()方法主动放弃所占用的处理器资 源。线程调用了一个阻塞式IO方法,在该方法返回之前,该线程被阻塞。线程试图获得一个同步监视器,但 该同步监视器正被其它线程所持有。线程在等待某个通知(notify)。 </p><p>​死亡(Dead)：线程调用stop()方法时或run()方法执行结束后，处于死亡状态。处于死亡状态的线 程不具备继续运行的能力。</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220220202058387.png" alt="image-20220220202058387"></p><p><strong>一些方法：</strong> </p><h3 id="1-gt-join方法"><a href="#1-gt-join方法" class="headerlink" title="1&gt;join方法"></a>1&gt;join方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;i++)&#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+ <span class="string">&quot;:&quot;</span>+i);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">th1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(thread, <span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">th2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(thread, <span class="string">&quot;线程2&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">th3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(thread, <span class="string">&quot;线程3&quot;</span>);</span><br><span class="line">        th1.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        th1.join();<span class="comment">//等待th1运行完毕后，其他线程才执行</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        th2.start();</span><br><span class="line">        th3.start();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;i++)&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-gt-sleep方法"><a href="#2-gt-sleep方法" class="headerlink" title="2&gt; sleep方法"></a>2&gt; sleep方法</h3><p>​在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统 计时器和调度程序精度和准确性的影响。该线程不丢失任何监视器的所属权。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;i++)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+ <span class="string">&quot;:&quot;</span>+i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">th1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(thread, <span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">        th1.start();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;i++)&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-gt-Interrupt-线程被中断"><a href="#3-gt-Interrupt-线程被中断" class="headerlink" title="3&gt;Interrupt 线程被中断"></a>3&gt;Interrupt 线程被中断</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始执行：&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程被中断&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;程序结束:&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThreadTest</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">th1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(thread, <span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">        th1.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            th1.interrupt();<span class="comment">//线程直接被中断了。</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-gt-yield"><a href="#4-gt-yield" class="headerlink" title="4&gt; yield"></a>4&gt; yield</h3><p>​暂停当前正在执行的线程对象，并执行其他线程。yield()应该做的是让当前运行线程 回到可运行状态，以允许具有相同优先级的其他线程获得运行机会。因此，使用yield()的目的是让相同 优先级的线程之间能适当的轮转执行。但是，实际中无法保证yield()达到让步目的，因为让步的线程还 有可能被线程调度程序再次选中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+i);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">run</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(run, <span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">            System.out.println(name+<span class="string">&quot;:&quot;</span>+i);</span><br><span class="line">            Thread.<span class="keyword">yield</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-gt-join方法"><a href="#5-gt-join方法" class="headerlink" title="5&gt;join方法"></a>5&gt;join方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;i++)&#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+i);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThredTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">run</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">th1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(run, <span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">th2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(run, <span class="string">&quot;线程2&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">th3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(run, <span class="string">&quot;线程3&quot;</span>);</span><br><span class="line">        th1.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        th1.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        th2.start();</span><br><span class="line">        th3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-gt-线程的优先级"><a href="#6-gt-线程的优先级" class="headerlink" title="6&gt;线程的优先级"></a>6&gt;线程的优先级</h3><p>​线程默认优先级是5，可以自己设置线程的优先级。通过，setPriority()方 法来设置线程的优先级。优先级的范围是1-10.线程优先级高仅仅表示线程获取CPU时间片的几率高，但 是要在次数比较多，或者多此运行时才能看比较好的效果。 </p><p>线程分为两类，一类是守护线程，一类是用户线程。他们在几乎每个方面都说相同的，唯一的 区别是判断JVM何时离开。守护线程是用来服务用户线程的。通过在start()方法前调用 </p><p>thread.setDaemon(true)可以把一个用户线程变成守护线程。Java垃圾回收就是一个典型的守护线程。 弱JVM中都是守护线程，当前JVM将退出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">run</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">th1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(run, <span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">th2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(run, <span class="string">&quot;线程2&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">th3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(run, <span class="string">&quot;线程3&quot;</span>);</span><br><span class="line">        th1.setPriority(<span class="number">10</span>);</span><br><span class="line">        th3.setPriority(<span class="number">1</span>);</span><br><span class="line">        th1.start();</span><br><span class="line">        th2.start();</span><br><span class="line">        th3.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4、同步域死锁"><a href="#4、同步域死锁" class="headerlink" title="4、同步域死锁"></a>4、同步域死锁</h2><p>​创建三个窗口买票，总票数为60张票。按照之前的代码，会发现代码出现问题，又相同的票或者 负数出现。出现问题的原因是当某个线程操作车票的过程中，操作尚未完成，其他线程进入，也操作了 该车票。如何解决？当一个线程a在操作ticket的时候，其他线程不能参与进来，直到线程a操作完成， 其他线程才可以操作。可以采用同步解决该问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(同步监视器)&#123;</span><br><span class="line"><span class="comment">//需要被同步的代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 操作共享数据的代码，即为需要被同步的代码，不能多包含也不能少包含。</p><p> 共享数据：多个线程共同操作的变量 </p><p>同步监视器：俗称，锁。任何一个类的对象，都可以充当锁，但是要去必须多个线程公用一把锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tickets</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">60</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (num &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() +<span class="string">&quot;再售&quot;</span> + num);</span><br><span class="line">                    num--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TicketsTest</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">Tickets</span> <span class="variable">run</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tickets</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">th1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(run,<span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">th2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(run,<span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">th3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(run,<span class="string">&quot;窗口3&quot;</span>);</span><br><span class="line">        th1.start();</span><br><span class="line">        th2.start();</span><br><span class="line">        th3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​同步的特点：前提：多个线程。 </p><p>​解决问题的时候要注意:多个线程使用的是同一个锁对象。</p><p>​同步的好处：同步的出现解决了多线程的安全问题。 </p><p>​同步弊端：当线程相当多时，因为每个线程都会去判断同步上的锁，这是很耗费资源的，无形中会 降低程序的运行效率。 </p><p>synchronized： 同步，需要被同步的代码。 </p><p>​同步方法，仍然需要同步监视器，只是不需要显示声明 </p><p>​非静态的同步方法，同步监视器是this </p><p>​静态的同步方法，同步监视器是 当前类本身。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Singleton singleton;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton==<span class="literal">null</span>)&#123;</span><br><span class="line">        singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Singleton singleton;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton==<span class="literal">null</span>)&#123;</span><br><span class="line">       <span class="keyword">synchronized</span>(Singletion.class)&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton==<span class="literal">null</span>)&#123;</span><br><span class="line">        singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​死锁 : 不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源， 就形成了死锁。出现死锁后，不会出现异常，不会出现提升，只是所有的线程都处于阻塞状态，无法继 续。解决办法：专门的算法，原则。尽量减少同步资源的定义，尽量避免嵌套同步。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLock</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> String s1=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Lock1</span> <span class="variable">lock1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Lock1</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(lock1);</span><br><span class="line">        </span><br><span class="line">        <span class="type">Lock2</span> <span class="variable">lock2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Lock2</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(lock2);</span><br><span class="line">        </span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lock2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Lock2执行&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (DeadLock.s2) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Lock2持有s2的锁&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (DeadLock.s1) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Lock2持有s1锁&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lock1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Lock1执行&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (DeadLock.s1) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Lock1持有s1的锁&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (DeadLock.s2) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Lock1持有s2锁&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何避免死锁呢？加锁顺序（线程按照一定的顺序加锁）。加锁时限（线程尝试获取锁的时候加上一定 的时限，超过时限则放弃对该锁的请求，并释放自己占有的锁）。死锁检测。</p><p> Lock(锁): 从JDK5.0开始，java提供了更强大的线程同步机制。通过显示定义同步锁对象来实现同步。同 步锁使用Lock对象充当。该接口是控制多个线程对共享资源进行访问的公交。锁提供了对共享资源的独 占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象。 </p><p>ReentrantLock类实现了Lock接口，他拥有与synchronized相同的并发性盒内存语义，再实现线程安全 的控制中，比较常用的RenntrantLock可以显示的加锁和释放锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Window</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="comment">//1.实例化ReentrantLock</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//2.调用锁定方法lock()</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() +<span class="string">&quot;：售票，票号为：&quot;</span> + ticket);</span><br><span class="line">                ticket--;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//3.调用解锁方法：unlock()</span></span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Window</span> <span class="variable">w</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Window</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(w);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(w);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(w);</span><br><span class="line">        </span><br><span class="line">        t1.setName(<span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">        t2.setName(<span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">        t3.setName(<span class="string">&quot;窗口3&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><pre><code>     synchronized与lock的异同：二者都可以解决线程安全问题。synchronized机制再执行完相应的同 步代码以后，自动的释放同步监视器。Lock需要手动的启动同步（lock()），同时结束同步也需要手动的 实现（unlock()） </code></pre><h3 id="练习：-17"><a href="#练习：-17" class="headerlink" title="练习："></a>练习：</h3><p>两个用户分布向一个账户存3000元，每次存1000，存3次。每次存款后打印账户余额</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> balance;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBalance</span><span class="params">(<span class="type">int</span> balance)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">inMoney</span><span class="params">(<span class="type">int</span> money)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.balance = <span class="built_in">this</span>.balance+money;</span><br><span class="line">        </span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;存款，卡中余额：&quot;</span>+balance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Customer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    Account account;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Customer</span><span class="params">(Account account)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.account = account;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        account.inMoney(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CustomerTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Account</span> <span class="variable">account</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Account</span>();</span><br><span class="line">        <span class="type">Customer</span> <span class="variable">cus1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Customer</span>(account);</span><br><span class="line">        cus1.setName(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        <span class="type">Customer</span> <span class="variable">cus2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Customer</span>(account);</span><br><span class="line">        cus2.setName(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        cus1.start();</span><br><span class="line">        cus2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、线程之间的通信"><a href="#5、线程之间的通信" class="headerlink" title="5、线程之间的通信"></a>5、线程之间的通信</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.openlab.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintNum</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                </span><br><span class="line">    <span class="comment">// wait();</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;</span><br><span class="line">            notify();</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">100</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+i);</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">        wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PrintNumTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">PrintNum</span> <span class="variable">run</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintNum</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">th1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(run,<span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">th2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(run,<span class="string">&quot;线程2&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">th3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(run,<span class="string">&quot;线程3&quot;</span>);</span><br><span class="line">        th1.start();</span><br><span class="line">        th2.start();</span><br><span class="line">        th3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>wait方法，一旦执行，线程进入阻塞状态，并释放对象的锁。 </p><p>notify方法，一旦执行，会唤醒等待的线程，如果有多个线程，唤醒优先级高的 </p><p>notifyAll方法，会 唤醒所有等待的线程。 </p><p>这三个方便必须再同步方法或同步代码块中使用。 </p><p>sleep和wait方法的异同？相同点：一旦执行方法，都可以使得当前的线程进入阻塞状态。</p><p> 不同点：两个方法声明的位置不同，Thread中是sleep方法。Object类中是wait方法。 </p><p>调用的范围不同：sleep方法可以再任何需要的场景下调用。wait必须在同步代码块中运行。如果两个方 法都用在同步代码块或同步方法中，sleep不会释放对象锁。wait方法会释放锁。 </p><p>生产者与消费者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 工厂</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span>];<span class="comment">//生产者生产的物品放入该数组中，消费者从该数组中取值</span></span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//记录生产者生产一个，或消费者消费一个</span></span><br><span class="line"><span class="comment">//1.生产东西</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">setProduct</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(index==<span class="number">1</span>) &#123;<span class="comment">//生产者已经生产，但是消费者未消费</span></span><br><span class="line"><span class="built_in">this</span>.wait(<span class="number">3000</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">            arr[<span class="number">0</span>]=num;<span class="comment">//生产的东西保存，以便消费者消费</span></span><br><span class="line">            System.out.println(<span class="string">&quot;生产者生产:&quot;</span>+arr[<span class="number">0</span>]);</span><br><span class="line">            <span class="built_in">this</span>.notify();<span class="comment">//通知消费者消费</span></span><br><span class="line">            index++;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">//2.取东西</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">getProduct</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(index==<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.wait();<span class="comment">//如果发现index==0说明还未生产好，需要等待</span></span><br><span class="line">                &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        System.out.println(<span class="string">&quot;消费者消费:&quot;</span>+arr[<span class="number">0</span>]);</span><br><span class="line">        index--;</span><br><span class="line">        <span class="comment">//this.notify();//通知生产者生产</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Product</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line"><span class="type">Factory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Product</span><span class="params">(Factory factory)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line"><span class="built_in">this</span>.factory = factory;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++) &#123;</span><br><span class="line">    factory.setProduct(i);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"><span class="type">Factory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Customer</span><span class="params">(Factory factory)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.factory = factory;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++) &#123;</span><br><span class="line">    factory.getProduct();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Factory</span> <span class="variable">fa</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Factory</span>();</span><br><span class="line">        <span class="type">Product</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Product</span>(fa);</span><br><span class="line">        p.start();</span><br><span class="line">        <span class="type">Customer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Customer</span>(fa);</span><br><span class="line">        c.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6、其他创建线程方式"><a href="#6、其他创建线程方式" class="headerlink" title="6、其他创建线程方式"></a>6、其他创建线程方式</h2><h3 id="1-gt-实现Callable接口"><a href="#1-gt-实现Callable接口" class="headerlink" title="1&gt; 实现Callable接口"></a>1&gt; 实现Callable接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建一个实现Callable的实现类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumThread</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&#123;</span><br><span class="line"><span class="comment">//2.实现call方法，将此线程需要执行的操作声明在call()中</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                sum += i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadNewTest</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//3.创建Callable接口实现类的对象</span></span><br><span class="line"><span class="type">NumThread</span> <span class="variable">numThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NumThread</span>();</span><br><span class="line"><span class="comment">//4.将此Callable接口实现类的对象作为传递到FutureTask构造器中，创建FutureTask的对象</span></span><br><span class="line"><span class="type">FutureTask</span> <span class="variable">futureTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>(numThread);</span><br><span class="line"><span class="comment">//5.将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask).start();</span><br><span class="line">        </span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//6.获取Callable中call方法的返回值</span></span><br><span class="line"><span class="comment">//get()返回值即为FutureTask构造器参数Callable实现类重写的call()的返回值。</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">sum</span> <span class="operator">=</span> futureTask.get();</span><br><span class="line">System.out.println(<span class="string">&quot;总和为：&quot;</span> + sum);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">   e.printStackTrace();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-gt-线程池"><a href="#2-gt-线程池" class="headerlink" title="2&gt;线程池:"></a>2&gt;线程池:</h3><p>经常创建和销毁，使用量特别大的资源，比如并发情况下的线程，对性能影响很大。如何 解决？提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁的创建 销毁，实现重复利用。使用线程池的 好处：提高响应速度，减少了创建新线程的时间，奖励资源消耗， 重复利用线程池中的线程，不需要每次都创建。便于线程管理。有一些属性：corePoolSize:核心池的大 小，maxnumPoolSize:最大线程数，keeAliveTime:线程没有任务时最多保持多长时间会终止。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumberThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt;= <span class="number">100</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> +i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumberThread1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt;= <span class="number">100</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i % <span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> +i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//1. 提供指定线程数量的线程池</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">service1</span> <span class="operator">=</span> (ThreadPoolExecutor) service;</span><br><span class="line"><span class="comment">//设置线程池的属性</span></span><br><span class="line"><span class="comment">// System.out.println(service.getClass());</span></span><br><span class="line"><span class="comment">// service1.setCorePoolSize(15);</span></span><br><span class="line"><span class="comment">// service1.setKeepAliveTime();</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//2.执行指定的线程的操作。需要提供实现Runnable接口或Callable接口实现类的对象</span></span><br><span class="line">service.execute(<span class="keyword">new</span> <span class="title class_">NumberThread</span>());<span class="comment">//适合适用于Runnable</span></span><br><span class="line">service.execute(<span class="keyword">new</span> <span class="title class_">NumberThread1</span>());<span class="comment">//适合适用于Runnable</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">// service.submit(Callable callable);//适合使用于Callable</span></span><br><span class="line"><span class="comment">//3.关闭连接池</span></span><br><span class="line">service.shutdown();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="十四、枚举和注解"><a href="#十四、枚举和注解" class="headerlink" title="十四、枚举和注解"></a>十四、枚举和注解</h1><h2 id="1、枚举"><a href="#1、枚举" class="headerlink" title="1、枚举"></a>1、枚举</h2><p><strong>当需要定义一组常量时，强烈建议使用枚举类</strong> </p><p>枚举类的实现 JDK1.5之前需要自定义枚举类 JDK 1.5 新增的 <strong>enum 关键字</strong>用于定义枚举类 </p><p>若枚举只有一个对象, 则可以作为一种单例模式的实现方式。 </p><p><strong>枚举类的属性</strong> </p><p><strong>枚举类对象的属性不应允许被改动, 所以应该使用 private final 修饰</strong> </p><p>枚举类的使用 private final 修饰的属性应该在构造器中为其赋值若枚举类显式的定义了带参数的构造器, 则在列出枚举值时也必须对应的传入参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Day</span> &#123;</span><br><span class="line">MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">SeasonEnum</span> &#123;</span><br><span class="line">SPRING(<span class="string">&quot;Spring&quot;</span>,<span class="string">&quot;春意盎然&quot;</span>),</span><br><span class="line">SUMMER(<span class="string">&quot;Summer&quot;</span>,<span class="string">&quot;烈日炎炎&quot;</span>),</span><br><span class="line">AUTUMN(<span class="string">&quot;Autumn&quot;</span>,<span class="string">&quot;秋高气爽&quot;</span>),</span><br><span class="line">WINTER(<span class="string">&quot;Winter&quot;</span>,<span class="string">&quot;寒风凛冽&quot;</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line"><span class="keyword">private</span> <span class="title function_">SeasonEnum</span><span class="params">(String seasonName, String seasonDesc)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.seasonName = seasonName;</span><br><span class="line"><span class="built_in">this</span>.seasonDesc = seasonDesc; &#125;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getSeasonName</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> seasonName; &#125;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getSeasonDesc</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> seasonDesc; &#125; &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">SeansEnum</span> <span class="keyword">implements</span> <span class="title class_">info</span>&#123;</span><br><span class="line">SPRING(<span class="string">&quot;Spring&quot;</span>,<span class="string">&quot;春意盎然&quot;</span>)&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;春天，春意盎然&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">    SUMMER(<span class="string">&quot;Summer&quot;</span>,<span class="string">&quot;烈日炎炎&quot;</span>)&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;夏天，夏日炎炎&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    AUTUMN(<span class="string">&quot;Autumn&quot;</span>,<span class="string">&quot;秋高气爽&quot;</span>)&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;秋天，秋高气爽&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    WINTER(<span class="string">&quot;Winter&quot;</span>,<span class="string">&quot;寒风凛冽&quot;</span>)&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;冬天，冰雪皑皑&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SeansEnum</span><span class="params">(String seasonName, String seasonDesc)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.seasonName = seasonName;</span><br><span class="line">        <span class="built_in">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonName</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> seasonName;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonDesc</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">info</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">SeansEnum</span> <span class="variable">autumn</span> <span class="operator">=</span> SeansEnum.AUTUMN;</span><br><span class="line">autumn.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2、注解"><a href="#2、注解" class="headerlink" title="2、注解"></a>2、注解</h2><p>从 JDK 5.0 开始, Java 增加了对元数据(MetaData) 的支持, 也就是Annotation(注解)</p><p> Annotation 其实就是代码里的<strong>特殊标记</strong>, 这些标记可以在编译, 类加载, 运行时被读取, 并执行相应的处 理。通过使用 Annotation, 程序员可以在不改变原有逻辑的情况下, 在源文件中嵌入一些补充信息。代码 分析工具、开发工具和部署工具可以通过这些补充信息进行验证或者进行部署。 </p><p>Annotation 可以像修饰符一样被使用, 可用于修饰包,类, 构造器,方法,成员变量, 参数,局部变量的声明, 这 些信息被保存在 Annotation 的 “name&#x3D;value” 对中 </p><p>常见注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>: 限定重写父类方法, 该注解只能用于方法</span><br><span class="line"><span class="meta">@Deprecated</span>: 用于表示所修饰的元素(类, 方法等)已过时。通常是因为所修饰的结构危险或存在更好的选择</span><br><span class="line"><span class="meta">@SuppressWarnings</span>: 抑制编译器警告</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>JDK中的元注解 </p><p>JDK 的元 Annotation 用于修饰其他 Annotation 定义。</p><p>JDK5.0提供了4个标准的meta-annotation类型，分别是：Retention Target Documented Inherited。 </p><p>@Retention: 只能用于修饰一个 Annotation 定义, 用于指定该 Annotation 的生命周期, @Rentention 包含一个 RetentionPolicy 类型的成员变量, 使用@Rentention 时必须为该 value 成员变量指定值: </p><p>**RetentionPolicy.SOURCE:**在源文件中有效（即源文件保留），编译器直接丢弃这种策略的注释 </p><p>**RetentionPolicy.CLASS:**在class文件中有效（即class保留） ， 当运行 Java 程序时, JVM 不会保留注 解。 这是默认值 </p><p><strong>RetentionPolicy.RUNTIME:<strong>在运行时有效（即运行时保留），</strong>当运行 Java</strong> 程序时, JVM 会保留注释。 程序可以通过反射获取该注释。 </p><p><strong>@Target:</strong> 用于修饰 Annotation 定义, 用于指定被修饰的 Annotation 能用于修饰哪些程序元素。 </p><p>@Target 也包含一个名为 value 的成员变量。 </p><h1 id="十五、集合"><a href="#十五、集合" class="headerlink" title="十五、集合"></a>十五、集合</h1><p>数组在内存存储方面的特点：数组初始化以后，长度就确定了。数组声明的类型，就决定了进行元素初 始化时的类型数组在存储数据方面的弊端：数组初始化以后，长度就不可变了，不便于扩展。数组中提 供的属性和方法少，不便于进行添加、删除、插入等操作，且效率不高。同时无法直接获取存储元素的 个数。数组存储的数据是有序的、可以重复的。—-&gt;存储数据的特点单一，Java 集合类可以用于存储数 量不等的多个<strong>对象</strong>，还可用于保存具有映射关系的关联数组。保存数据的时候，需要考虑使用集合。 </p><p>Java 集合可分为 Collection 和 Map 两种体系。Collection接口：单列数据，定义了存取一组对象的方法 的集合List：元素有序、可重复的集合。Set：元素无序、不可重复的集合。Map接口：双列数据，保存 具有映射系“key-value对”的集合。</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220220202502317.png" alt="image-20220220202502317"></p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220220202508889.png" alt="image-20220220202508889"></p><h2 id="1、Collection接口"><a href="#1、Collection接口" class="headerlink" title="1、Collection接口"></a>1、Collection接口</h2><p>既然Collection接口是集合中的顶层接口，那么它中定义的所有功能子类都可以使用。查阅API中描述的 Collection接口。Collection 层次结构 中的根接口。Collection 表示一组对象，这些对象也称为 collection 的元素。一些 collection 允许有重复的元素，而另一些则不允许。一些 collection 是有序 的，而另一些则是无序的。这里我们不关心具体创建的Collection中的那个子类对象，这里重点演示的是 Collection接口中的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>:确保此 collection 包含指定的元素（可选操作）。</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span>:将指定 collection 中的所有元素都添加到此collection 中（可选操作）。</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>:移除此 collection 中的所有元素（可选操作）。</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span>:如果此 collection 包含指定的元素，则返回 <span class="literal">true</span> 。</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span>:如果此 collection 包含指定 collection 中的所有元素，则返回 <span class="literal">true</span> 。</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span>:比较此 collection 与指定对象是否相等。</span><br><span class="line"><span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>:返回此 collection 的哈希码值。</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>:如果此 collection 不包含元素，则返回 <span class="literal">true</span> 。</span><br><span class="line">Iterator <span class="title function_">iterator</span><span class="params">()</span>:返回在此 collection 的元素上进行迭代的迭代器。</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span>:从此 collection 中移除指定元素的单个实例，如果存在的话（可选操作）。</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span>:移除此 collection 中那些也包含在指定collection 中的所有元素（可选操作）。</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span>:仅保留此 collection 中那些也包含在指定collection 的元素（可选操作）。</span><br><span class="line"><span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>:返回此 collection 中的元素数。</span><br><span class="line">Object[] toArray():返回包含此 collection 中所有元素的数组。</span><br><span class="line">T[] toArray(T[] a):返回包含此 collection 中所有元素的数组；返回数组的运行时类型与指定数组的运行时类型相同。</span><br></pre></td></tr></table></figure><h2 id="2、迭代器的使用"><a href="#2、迭代器的使用" class="headerlink" title="2、迭代器的使用"></a>2、迭代器的使用</h2><p>Iterator原理由于集合容器有很多，每个容器都有自身的数据存储结构，即每个容器自身最清楚自己中数 据是如何存储的，容器这么多，每个容器数据存储又不相同，这时就在它们之间找取出元素的共性进行 了抽取，抽取出集合容器取出元素的共同特点。在取元素之前先要判断集合中有没有元素，如果有，就 把这个元素取出来，继续在判断，如果还有就再取出来。一直把集合中的所有元素全部取出。这种取出 方式专业术语称为迭代。集合中把这种取元素的方式描述在Iterator接口中。</p><p><strong>注意</strong>：在进行集合元素取出时，如果集合中已经没有元素了，还继续使用迭代器的next方法，将会发生 java.util.NoSuchElementException没有这个元素异常。 </p><h2 id="3、List接口常用接口"><a href="#3、List接口常用接口" class="headerlink" title="3、List接口常用接口"></a>3、List接口常用接口</h2><p>鉴于Java中数组用来存储数据的局限性，我们通常使用List替代数组。一个有序集合（也被称为序列）。 此接口的用户在列表中的每个元素都被插入的地方有精确的控制。用户可以通过它们的整数索引（在列 表中的位置）访问元素，并在列表中搜索元素。 与set不同的是，列表通常允许重复元素。 </p><p>List集合类中<strong>元素有序、且可重复</strong>，集合中的每个元素都有其对应的顺序索引。 </p><p>List容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素。 </p><p>JDK API中List接口的实现类常用的有：ArrayList、LinkedList和Vector。 </p><p>List方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> ：在列表的指定位置插入指定元素（可选操作）。</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span> index, Collection&lt;? extends E&gt; c)</span> ：将指定collection 中的所有元素都插入到列表中的指定位置。</span><br><span class="line">E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> ：返回列表中指定位置的元素。</span><br><span class="line"><span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span> ：返回此列表中第一次出现的指定元素的索引；如果此列表不包含该元素，则返回 -<span class="number">1</span>。</span><br><span class="line"><span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(Object o)</span> ：返回此列表中最后出现的指定元素的索引；如果列表不包含此元素，则返回 -<span class="number">1</span>。</span><br><span class="line">ListIterator <span class="title function_">listIterator</span><span class="params">()</span> ：返回此列表元素的列表迭代器（按适当顺序）。</span><br><span class="line">E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> ：移除列表中指定位置的元素（可选操作）。</span><br><span class="line">E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> ：用指定元素替换列表中指定位置的元素（可选操作）。</span><br><span class="line">List <span class="title function_">subList</span><span class="params">(<span class="type">int</span> fromIndex, <span class="type">int</span> toIndex)</span> ：返回列表中指定的 fromIndex （包括 ）和toIndex （不包括）之间的部分视图。</span><br><span class="line"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> E&gt; c)</span> ：分类列表使用提供的 Comparator比较元素。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>List Iterator介绍</strong> </p><p>在迭代过程中，使用了集合的方法对元素进行操作。导致迭代器并不知道集合中的变化，容易引发数据 的不确定性。解决：在迭代时，不要使用集合的方法操作元素。那么想要在迭代时对元素操作咋办？可 以使用迭代器的方法操作。可是很遗憾：迭代器Iterator的方式只有 hasNext() ,next(),remove();Iterator 有一个子接ListIterator可以完成该问题的解决。如何获取该子接口对象呢？通过List接口中的 listIterator()就可以获取。 </p><p><strong>List 实现子类</strong> </p><p>Collection接口：单列集合，用来存储一个一个的对象。 </p><p>List接口：存储有序的、可重复的数据。 –&gt;“动态”数组,替换原有的数组。 </p><p>ArrayList：作为List接口的主要实现类；线程不安全的，效率高；底层使用Object[] elem。entData存 储 </p><p>LinkedList：对于频繁的插入、删除操作，使用此类效率比ArrayList高；底层使用双向链表存储。 </p><p>Vector:作为List接口的古老实现类，线程安全的，效率低。底层使用Object[] elementData存储。</p><p> <strong>ArrayList</strong> List 接口的大小可变数组的实现。实现了所有可选列表操作，并允许包括 null 在内的所有元 素。 </p><p>每个 ArrayList 实例都有一个容量 。该容量是指用来存储列表元素的数组的大小。它总是至少等于列表 的大小。随着向 ArrayList 中不断添加元素，其容量也自动增长。此实现不是同步的。 </p><p><strong>ArrayList</strong>的JDK1.8之前与之后的实现区别？ </p><p>JDK1.7：ArrayList像饿汉式，直接创建一个初始容量为10的数组 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">this</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line"><span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">initialCapacity);</span><br><span class="line"><span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">ensureCapacityInternal(size + <span class="number">1</span>); <span class="comment">// Increments modCount!!</span></span><br><span class="line">elementData[size++] = e;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">modCount++;</span><br><span class="line"><span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> ArrayList list &#x3D; new ArrayList();&#x2F;&#x2F;底层创建了长度是10的Object[]数组elementData </p><p>list.add();&#x2F;如果此次的添加导致底层elementData数组容量不够，则扩容。 </p><p>默认情况下，扩容为原来的容量的1.5倍，同时需要将原有数组中的数据复制到新的数组中。 </p><p>结论：建议开发中使用带参的构造器：ArrayList list &#x3D; new ArrayList(int capacity)</p><p>JDK1.8：ArrayList像懒汉式，一开始创建一个长度为0的数组，当添加第一个元素时再创建一个始容量 为10的数组。默认扩容是原来的1.5倍。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>); <span class="comment">// Increments modCount!!</span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>LinkedList</strong> List 接口的链接列表实现。实现所有可选的列表操作，并且允许所有元素（包括 null ）。 除了实现 List 接口外， LinkedList 类还为在列表的开头及结尾 get 、 remove 和 insert 元素提供了统一 的命名方法。这些操作允许将链接列表用作堆栈、<strong>队列</strong>或<strong>双端队列</strong>。所有操作都是按照双重链接列表的 需要执行的。在列表中编索引的操作将从开头或结尾遍历列表（从靠近指定索引的一端）。 </p><p>LinkedList list &#x3D; new LinkedList(); 内部声明了Node类型的first和last属性，默认值为null。 </p><p>list.add(123);&#x2F;&#x2F;将123封装到Node中，创建了Node对象。</p><p>Node定义为：体现了LinkedList的双向链表的说法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">Node&lt;E&gt; next;</span><br><span class="line">Node&lt;E&gt; prev;</span><br><span class="line">    </span><br><span class="line">Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line"><span class="built_in">this</span>.item = element;</span><br><span class="line"><span class="built_in">this</span>.next = next;</span><br><span class="line"><span class="built_in">this</span>.prev = prev;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(E e)</span>:将指定元素插入此列表的开头。</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(E e)</span>:将指定元素添加到此列表的结尾。</span><br><span class="line">E <span class="title function_">removeFirst</span><span class="params">()</span>:移除并返回此列表的第一个元素。</span><br><span class="line">E <span class="title function_">removeLast</span><span class="params">()</span>:移除并返回此列表的最后一个元素。</span><br><span class="line">E <span class="title function_">getFirst</span><span class="params">()</span>:返回此列表的第一个元素。</span><br><span class="line">E <span class="title function_">getLast</span><span class="params">()</span>:返回此列表的最后一个元素。</span><br><span class="line"><span class="type">boolean</span> ow <span class="title function_">erFirst</span><span class="params">(E e)</span>:在此列表的开头插入指定的元素。</span><br><span class="line"><span class="type">boolean</span> ow <span class="title function_">erLast</span><span class="params">(E e)</span>:在此列表的末尾插入指定的元素。</span><br><span class="line">E <span class="title function_">pollFirst</span><span class="params">()</span>:获取并移除此列表的第一个元素；如果此列表为空，则返回 <span class="literal">null</span> 。 E</span><br><span class="line"><span class="title function_">pollLast</span><span class="params">()</span> ：获取并移除此列表的最后一个元素；如果此列表为空，则返回 <span class="literal">null</span> 。 E</span><br><span class="line"><span class="title function_">peekFirst</span><span class="params">()</span> ：获取但不移除此列表的第一个元素；如果此列表为空，则返回 <span class="literal">null</span> 。 E</span><br><span class="line"><span class="title function_">peekLast</span><span class="params">()</span> ：获取但不移除此列表的最后一个元素；如果此列表为空，则返回 <span class="literal">null</span> 。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Vector</strong> 是一个古老的集合，JDK1.0就有了。大多数操作与ArrayList相同，区别之处在于Vector是线程 安全的。 </p><p>在各种list中，最好把ArrayList作为缺省选择。当插入、删除频繁时，使用LinkedList；Vector总是比 ArrayList慢，所以尽量避免使用。 </p><p>请问ArrayList&#x2F;LinkedList&#x2F;Vector的异同？谈谈你的理解？ArrayList底层是什么？扩容机制？Vector和 ArrayList的最大区别?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ArrayList和LinkedList的异同</span><br><span class="line">二者都线程不安全，相对线程安全的Vector，执行效率高。</span><br><span class="line">此外，ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。对于新增和删除操作add(特指插入)和remove，LinkedList比较占优势，因为ArrayList要移动数据。</span><br><span class="line">ArrayList和Vector的区别</span><br><span class="line">Vector和ArrayList几乎是完全相同的,唯一的区别在于Vector是同步类(<span class="keyword">synchronized</span>)，属于强同步类。因此开销就比ArrayList要大，访问要慢。正常情况下,大多数的Java程序员使用ArrayList而不是Vector,因为同步完全可以由程序员自己来控制。Vector每次扩容请求其大小的<span class="number">2</span>倍空间而ArrayList是<span class="number">1.5</span>倍。Vector还有一个子类Stack。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>List接口的常用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">list.add(<span class="number">1</span>);</span><br><span class="line">list.add(<span class="number">2</span>);</span><br><span class="line">list.add(<span class="number">3</span>);</span><br><span class="line">list.remove(<span class="number">2</span>);<span class="comment">//索引</span></span><br><span class="line">list.remove(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">2</span>));<span class="comment">//2这个值</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>小结：</strong> </p><p>Collection接口：单列集合，用来存储一个一个的对象 </p><p>List接口：<strong>存储有序的、可重复的数据。</strong> –&gt;“<em>动态</em>**”数组,替换原有的数组</p><p>ArrayList：作为List接口的主要实现类；线程不安全的，效率高；底层使用Object[ ] elementData存 储 </p><p>LinkedList：对于频繁的插入、删除操作，使用此类效率较高；底层使用双向链表存储 </p><p>Vector：作为List接口的古老实现类；线程安全的，效率低；底层使用Object[ ] elementData存储 ArrayList list &#x3D; new ArrayList(); 底层在创建对象时就创建了长度是10的Object[ ]数组elementData list.add(123);&#x2F;&#x2F;elementData[0] &#x3D; new Integer(123); … </p><p>list.add(11);&#x2F;&#x2F;如果此次的添加导致底层elementData数组容量不够，则扩容。</p><p> 默认情况下，扩容为原来的容量的1.5倍，同时需要将原有数组中的数据复制到新的数组中。</p><p> <strong>结论</strong>：建议开发中使用带参的构造器：ArrayList list &#x3D; new ArrayList(int capacity) </p><p>2.2 jdk 8中ArrayList的变化： </p><p>ArrayList list &#x3D; new ArrayList();&#x2F;&#x2F;底层Object[ ] elementData初始化为{}.并没有创建长度为10的数组 源码分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested classaccess</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 如果是无参构造器时，实际也创建了对象，就是没有长度而已</span></span><br><span class="line"><span class="comment">    * 此时只是private static final Object[]DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span></span><br><span class="line"><span class="comment">    * 赋值给了Object数组</span></span><br><span class="line"><span class="comment">    * 当在第一次调用add方法添加元素时确定了数组长度</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 当为有参构造器时</span></span><br><span class="line"><span class="comment">    * 参数为想要创建数组的长度</span></span><br><span class="line"><span class="comment">    * 此时将会创建一个数组长度为传进来的长度</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+initialCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">list.add(<span class="number">123</span>);<span class="comment">//第一次调用add()时，底层才创建了长度10的数组，并将数据123添加到elementData[0]</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 此时数组在第一次添加元素时，而是通过扩容机制来给数组确定长度，而第一次给数组</span></span><br><span class="line"><span class="comment">    * 扩容的大小为10</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>); <span class="comment">// Increments modCount!!</span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220314205442157.png" alt="image-20220314205442157"></p><p>后续的添加和扩容操作与jdk 7 无异。</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220315173400374.png" alt="image-20220315173400374"></p><p><strong>小结</strong>：jdk7中的ArrayList的对象的创建类似于单例的饿汉式（以上来就创建），而jdk8中的ArrayList的 对象的创建类似于单例的懒汉式，延迟了数组的创建，节省内存。 </p><p>LinkedList源码分析 </p><p>LinkedList list &#x3D; new LinkedList(); 内部声明了Node类型的first和last属性，默认值为null </p><p>list.add(123);&#x2F;&#x2F;将123封装到Node中，创建了Node对象。 </p><p>其中，Node定义为：体现了LinkedList的双向链表的说法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">        E item;</span><br><span class="line">        Node&lt;E&gt; next;<span class="comment">//后</span></span><br><span class="line">        Node&lt;E&gt; prev;<span class="comment">//前</span></span><br><span class="line">        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="built_in">this</span>.item = element;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">        <span class="built_in">this</span>.prev = prev;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>Vector的源码分析</em>：jdk7和jdk8中通过Vector()构造器创建对象时，底层都创建了长度为10的数组。 </p><p>在扩容方面，默认扩容为原来的数组长度的2倍。 </p><p>源码分析：</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220314205635875.png" alt="image-20220314205635875"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">list.add(<span class="number">1</span>);</span><br><span class="line">list.add(<span class="number">2</span>);</span><br><span class="line">list.add(<span class="number">3</span>);</span><br><span class="line">list.remove(<span class="number">2</span>);<span class="comment">//2 是索引</span></span><br><span class="line">list.remove(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">2</span>));<span class="comment">//2是值</span></span><br></pre></td></tr></table></figure><h2 id="4、Set接口"><a href="#4、Set接口" class="headerlink" title="4、Set接口"></a>4、Set接口</h2><p>Set接口是Collection的子接口，set接口没有提供额外的方法 Set 集合不允许包含相同的元素，如果试把 两个相同的元素加入同一个Set 集合中，则添加操作失败。Set 判断两个对象是否相同不是使用 &#x3D;&#x3D; 运算 符，而是根据 equals() 方法。 </p><p><strong>HashSet：</strong>HashSet 是 Set 接口的典型实现，大多数时候使用 Set 集合时都使用这个实现类。HashSet 按 Hash 算法来存储集合中的元素，因此具有很好的存取、查找、删除性能。 </p><p><strong>HashSet 具有以下特点：</strong>不能保证元素的排列顺序。HashSet 不是线程安全的。集合元素可以是 null </p><p><strong>HashSet 集合判断两个元素相等的标准：</strong>两个对象通过 hashCode() 方法比较相等，并且两个对象的 equals() 方法返回值也相等。 对于存放在Set容器中的对象，对应的类一定要重写equals()和 hashCode(Object obj)方法，以实现对象相等规则。即：“相等的对象必须具有相等的散列码”。 </p><p>向HashSet中添加元素的过程：当向 HashSet 集合中存入一个元素时，HashSet 会调用该对象的 hashCode() 方法来得到该对象的 hashCode 值，然后根据 hashCode 值，通过某种散列函数决定该对 象在 HashSet 底层数组中的存储位置。（这个散列函数会与底层数组的长度相计算得到在数组中的下 标，并且这种散列函数计算还尽可能保证能均匀存储元素，越是散列分布，该散列函数设计的越好） </p><p>如果两个元素的hashCode()值相等，会再继续调用equals方法，如果equals方法结果为true，添加失 败；如果为false，那么会保存该元素，但是该数组的位置已经有元素了，那么会通过链表的方式继续链 接。 </p><p>如果两个元素的 equals() 方法返回 true，但它们的 hashCode() 返回值不相等，hashSet 将会把它们存 储在不同的位置，但依然可以添加成功。 </p><p>HashSet底层也是数组，初始容量为16，当如果使用率超过0.75，（16*0.75&#x3D;12）就会扩大容量为原来 的2倍。（16扩容为32，依次为64,128….等）。 </p><p>重写equals方法的基本原则： </p><p>当一个类有自己特有的“逻辑相等”概念,当改写equals()的时候，总是要改写hashCode()，根据一个类的 equals方法（改写后），两个截然不同的实例有可能在逻辑上是相等的，但是，根据 Object.hashCode()方法，它们仅仅是两个对象。违反了“相等的对象必须具有相等的散列码”。所以 复写 equals方法的时候一般都需要同时复写hashCode方法。通常参与计算hashCode的对象的属性也应该参 与到equals()中进行计算。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer pid;</span><br><span class="line">    <span class="keyword">private</span> String pname;</span><br><span class="line">    <span class="keyword">private</span> String psex;</span><br><span class="line">    <span class="keyword">private</span> Integer page;</span><br><span class="line">    ......</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) o;</span><br><span class="line">        <span class="keyword">if</span> (pid != <span class="literal">null</span> ? !pid.equals(person.pid) : person.pid != <span class="literal">null</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (pname != <span class="literal">null</span> ? !pname.equals(person.pname) : person.pname !=</span><br><span class="line">        <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (psex != <span class="literal">null</span> ? !psex.equals(person.psex) : person.psex != <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> page != <span class="literal">null</span> ? page.equals(person.page) : person.page ==</span><br><span class="line">        <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> pid != <span class="literal">null</span> ? pid.hashCode() : <span class="number">0</span>;</span><br><span class="line">    result = <span class="number">31</span> * result + (pname != <span class="literal">null</span> ? pname.hashCode() : <span class="number">0</span>);</span><br><span class="line">    result = <span class="number">31</span> * result + (psex != <span class="literal">null</span> ? psex.hashCode() : <span class="number">0</span>);</span><br><span class="line">    result = <span class="number">31</span> * result + (page != <span class="literal">null</span> ? page.hashCode() : <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1001</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;f&quot;</span>,<span class="number">23</span>);</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1000</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;m&quot;</span>,<span class="number">24</span>);</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1004</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;f&quot;</span>,<span class="number">18</span>);</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1003</span>,<span class="string">&quot;e&quot;</span>,<span class="string">&quot;m&quot;</span>,<span class="number">27</span>);</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1003</span>,<span class="string">&quot;e&quot;</span>,<span class="string">&quot;m&quot;</span>,<span class="number">27</span>);</span><br><span class="line">    System.out.println(p4);</span><br><span class="line">    System.out.println(p5);</span><br><span class="line">    HashSet&lt;Person&gt; hashSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    hashSet.add(p1);</span><br><span class="line">    hashSet.add(p2);</span><br><span class="line">    hashSet.add(p3);</span><br><span class="line">    hashSet.add(p4);</span><br><span class="line">    p4.setPid(<span class="number">1111</span>);</span><br><span class="line">    System.out.println(p4);</span><br><span class="line">    hashSet.add(p5);</span><br><span class="line">    System.out.println(<span class="string">&quot;------------------&quot;</span>);</span><br><span class="line">    System.out.println(p4);</span><br><span class="line">    System.out.println(p5);</span><br><span class="line">    hashSet.add(p4);</span><br><span class="line">    System.out.println(hashSet.size());<span class="comment">//6</span></span><br><span class="line">    System.out.println(p4.equals(p5));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220314220431423.png" alt="image-20220314220431423"></p><p><strong>LinkedHashSet：</strong>LinkedHashSet 是 HashSet 的子类。LinkedHashSet 根据元素的 hashCode 值来决 定元素的存储位置，但它同时使用双向链表维护元素的次序，这使得元素看起来是以插入顺序保存的。 </p><p>LinkedHashSet插入性能略低于 HashSet，但在迭代访问 Set 里的全部元素时有很好的性能。 </p><p>LinkedHashSet 不允许集合元素重复。 </p><p><strong>TreeSet:<strong>TreeSet 是 SortedSet 接口的实现类，TreeSet 可以确保集合元素处于排序状态。TreeSet底层 使用</strong>红黑树</strong>结构存储数据。 </p><p>排序：<strong>自然排序</strong>：TreeSet 会调用集合元素的 compareTo(Object obj) 方法来比较元 素之间的大小关系，然后将集合元素按升序(默认情况)排列如果试图把一个对象添加到 TreeSet 时，则 该对象的类必须实现 Comparable 接口。</p><p>实现 Comparable 的类必须实现 compareTo(Object obj) 方法，两个对象即通过compareTo(Object obj) 方法的返回值来比较大小。 </p><p>Comparable 的典型实现：BigDecimal、BigInteger 以及所有的数值型对应的包装类：按它们对应的数 值大小进行比较。Character：按字符的 unicode值来进行比较。Boolean：true 对应的包装类实例大于 false 对应的包装类实例。String：按字符串中字符的 unicode 值进行比较。Date、Time：后边的时 间、日期比前面的时间、日期大。</p><h2 id="5、Map接口"><a href="#5、Map接口" class="headerlink" title="5、Map接口"></a>5、Map接口</h2><p>Map与Collection并列存在。用于保存具有<strong>映射关系</strong>的数据:key-value。Map 中的 key 和 value 都可以 是任何引用类型的数据。Map 中的 key 用Set来存放，<strong>不允许重复</strong>，即同一个 Map 对象所对应的类，须 重写hashCode()和equals()方法。常用String类作为Map的“键”。key 和 value 之间存在单向一对一关 系，即通过指定的 key 总能找到唯一的确定的 value。Map接口的常用实现类：HashMap、TreeMap、 LinkedHashMap和Properties。其中，HashMap是 Map 接口使用频率最高的实现类。 </p><p>Map接口常用的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">添加、删除、修改操作：</span><br><span class="line">Object <span class="title function_">put</span><span class="params">(Object key,Object value)</span>：将指定key-value添加到(或修改)当前map对象中<span class="keyword">void</span> <span class="title function_">putAll</span><span class="params">(Map m)</span>:将m中的所有key-value对存放到当前map中</span><br><span class="line">Object <span class="title function_">remove</span><span class="params">(Object key)</span>：移除指定key的key-value对，并返回value</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>：清空当前map中的所有数据</span><br><span class="line">    </span><br><span class="line">元素查询的操作：</span><br><span class="line">Object <span class="title function_">get</span><span class="params">(Object key)</span>：获取指定key对应的value</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(Object key)</span>：是否包含指定的key</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">containsValue</span><span class="params">(Object value)</span>：是否包含指定的value</span><br><span class="line"><span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>：返回map中key-value对的个数</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>：判断当前map是否为空</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>：判断当前map和参数对象obj是否相等</span><br><span class="line">    </span><br><span class="line">元视图操作的方法：</span><br><span class="line">Set <span class="title function_">keySet</span><span class="params">()</span>：返回所有key构成的Set集合</span><br><span class="line">Collection <span class="title function_">values</span><span class="params">()</span>：返回所有value构成的Collection集合</span><br><span class="line">Set <span class="title function_">entrySet</span><span class="params">()</span>：返回所有key-value对构成的Set集合</span><br></pre></td></tr></table></figure><p><strong>HashMap:<strong>HashMap是 Map 接口</strong>使用频率最高</strong>的实现类。允许使用null键和null值，与HashSet一样， 不保证映射的顺序。所有的key构成的集合是Set:无序的、不可重复的。所以，key所在的类要重写： equals()和hashCode()所有的value构成的集合是Collection:无序的、可以重复的。所以，value所在的 类要重写：equals()一个key-value构成一个entry。所有的entry构成的集合是Set:无序的、不可重复 的。HashMap <strong>判断两个 key 相等的标准</strong>是：两个 key 通过 equals() 方法返回 true，hashCode 值也相 等。HashMap <strong>判断两个 value</strong>相等的标准是：两个 value 通过 equals() 方法返回 true。 </p><p>JDK 7及以前版本：HashMap是数组+链表结构(即为链地址法) </p><p>JDK 8版本发布以后：HashMap是数组+链表+红黑树实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HashMap的内部存储结构其实是数组和链表的结合。当实例化一个HashMap时，系统会创建一个长度为Capacity的Entry数组，这个长度在哈希表中被称为容量(Capacity)，在这个数组中可以存放元素的位置我们称之为“桶”(bucket)，每个bucket都有自己的索引，系统可以根据索引快速的查找bucket中的元素。</span><br><span class="line">每个bucket中存储一个元素，即一个Entry对象，但每一个Entry对象可以带一个引用变量，用于指向下一个元素，因此，在一个桶中，就有可能生成一个Entry链。而且新添加的元素作为链表的head。</span><br><span class="line">添加元素的过程：向HashMap中添加entry1(key，value)，需要首先计算entry1中key的哈希值(根据key所在类的hashCode()计算得到)，此哈希值经过处理以后，得到在底层Entry[]数组中要存储的位置i。如果位置i上没有元素，则entry1直接添加成功。如果位置i上已经存在entry2(或还有链表存在的entry3，entry4)，则需要通过循环的方法，依次比较entry1中key和其他的entry。如果彼此hash值不同，则直接添加成功。如果hash值不同，继续比较二者是否equals。如果返回值为<span class="literal">true</span>，则使用entry1的value去替换equals为<span class="literal">true</span>的entry的value。如果遍历一遍以后，发现所有的equals返回都为<span class="literal">false</span>,则entry1仍可添加成功。entry1指向原有的entry元素。</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">JDK1<span class="number">.8</span>之前</span><br><span class="line">HashMap的扩容</span><br><span class="line">当HashMap中的元素越来越多的时候，hash冲突的几率也就越来越高，因为数组的长度是固定的。所以为了提高查询的效率，就要对HashMap的数组进行扩容，而在HashMap数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算</span><br><span class="line">其在新数组中的位置，并放进去，这就是resize。那么HashMap什么时候进行扩容呢？ 当HashMap中的元素个数超过数组大小(数组总大小length,不是数组中个数size)*loadFactor 时 ， 就 会 进行 数 组 扩 容 ， loadFactor 的默认 值(DEFAULT_LOAD_FACTOR)为<span class="number">0.75</span>，这是一个折中的取值。也就是说，默认情况下，数组大(DEFAULT_INITIAL_CAPACITY)为<span class="number">16</span>，那么当HashMap中元素个数</span><br><span class="line">超过<span class="number">16</span>*<span class="number">0.75</span>=<span class="number">12</span>（这个值就是代码中的threshold值，也叫做临界值）的时候，就把数组的大小扩展为 <span class="number">2</span>*<span class="number">16</span>=<span class="number">32</span>，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知HashMap中元素的个数，那么预设元素的个数能够有效的提高HashMap的性能。</span><br><span class="line">JDK1<span class="number">.8</span>之后</span><br><span class="line">HashMap的内部存储结构其实是数组+链表+树的结合。当实例化一个HashMap时，会初始化</span><br><span class="line">initialCapacity和loadFactor，在put第一对映射关系时，系统会创建一个长度为initialCapacity的Node数组，这个长度在哈希表中被称为容量(Capacity)，在这个数组中可以存放元素的位置我们称之为“桶”(bucket)，每个bucket都有自己的索引，系统可以根据索引快速的查找bucket中的元素。每个bucket中存储一个元素，即一个Node对象，但每一个Node对象可以带一个引用变量next，用于指向下一个元素，因此，在一个桶中，就有可能生成一个Node链。也可能是一个一个TreeNode对象，每一个TreeNode对象可以有两个叶子结点left和right，因此，在一个桶中，就有可能生成一个TreeNode树。而新添加的元素作为链表的last，或树的叶子结点。</span><br><span class="line">那么HashMap什么时候进行扩容和树形化呢?</span><br><span class="line">当HashMap中的元素个数超过数组大小(数组总大小length,不是数组中个size)*loadFactor 时， 就会进行数组扩容 ，loadFactor 的默认 值 (DEFAULT_LOAD_FACTOR)为<span class="number">0.75</span>，这是一个折中的取值。也就是说，默认情况下，数组大小(DEFAULT_INITIAL_CAPACITY)为<span class="number">16</span>，那么当HashMap中元素个数超过<span class="number">16</span>*<span class="number">0.75</span>=<span class="number">12</span>（这个值就是代码中的threshold值，也叫做临界值）的时候，就把数组的大小扩展为 <span class="number">2</span>*<span class="number">16</span>=<span class="number">32</span>，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知HashMap中元素的个数，那么预设元素的个数能够有效的提高HashMap的性能。 当HashMap中的其中一个链的对象个数如果达到了<span class="number">8</span>个，此时如果capacity没有达到<span class="number">64</span>，那么HashMap会先扩容解决，如果已经达到了<span class="number">64</span>，那么这个链会变成树，结点类型由Node变成TreeNode类型。当然，如果当映射关系被移除后，下次resize方法时判断树的结点个数低于<span class="number">6</span>个，也会把树再转为链表。</span><br><span class="line">        </span><br><span class="line">总结：JDK1<span class="number">.8</span>相较于之前的变化：</span><br><span class="line"><span class="number">1.</span><span class="type">HashMap</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();<span class="comment">//默认情况下，先不创建长度为16的数组</span></span><br><span class="line"><span class="number">2.</span>当首次调用map.put()时，再创建长度为<span class="number">16</span>的数组</span><br><span class="line"><span class="number">3.</span>数组为Node类型，在jdk7中称为Entry类型</span><br><span class="line"><span class="number">4.</span>形成链表结构时，新添加的key-value对在链表的尾部（七上八下）</span><br><span class="line"><span class="number">5.</span>当数组指定索引位置的链表长度&gt;<span class="number">8</span>时，且map中的数组的长度&gt; <span class="number">64</span>时，此索引位置上的所有keyvalue对使用红黑树进行存储</span><br></pre></td></tr></table></figure><p><strong>LinkedHashMap：</strong>LinkedHashMap 是 HashMap 的子类在HashMap存储结构的基础上，使用了一对 双向链表来记录添加元素的顺序与LinkedHashSet类似，LinkedHashMap 可以维护 Map 的迭代顺序： 迭代顺序与 Key-Value 对的插入顺序一致。 </p><p><strong>TreeMap:</strong> TreeMap存储 Key-Value 对时，需要根据 key-value 对进行排序。TreeMap 可以保证所有的 Key-Value 对处于<strong>有序</strong>状态。TreeSet底层使用<strong>红黑树</strong>结构存储数据。TreeMap 的 Key 的排序：<strong>自然排 序</strong>：TreeMap 的所有的 Key 必须实现 Comparable 接口，而且所有的 Key 应该是同一个类的对象，否 则将会抛出ClasssCastException。<strong>定制排序</strong>：创建 TreeMap 时，传入一个 Comparator 对象，该对象 负责对TreeMap 中的所有 key 进行排序。此时不需要 Map 的 Key 实现Comparable 接口TreeMap判断 两个<strong>key相等的标准</strong>：两个key通过compareTo()方法或者compare()方法返回0。 </p><p>**Hashtable:**Hashtable是个古老的 Map 实现类，JDK1.0就提供了。不同于HashMap，Hashtable是线 程安全的。Hashtable实现原理和HashMap相同，功能相同。底层都使用哈希表结构，查询速度快，很 多情况下可以互用。 与HashMap不同，Hashtable 不允许使用 null 作为 key 和 value。与HashMap一 样，Hashtable 也不能保证其中 Key-Value 对的顺序。Hashtable判断两个key相等、两个value相等的 标准，与HashMap一致。 **Properties:**Properties 类是 Hashtable 的子类，该对象用于处理属性文件由于属性文件里的 key、 value 都是字符串类型，所以 Properties 里的 key 和 value 都是字符串类型存取数据时，建议使用 setProperty(String key,String value)方法和getProperty(String key)方法 </p><p>总结：Map集合 </p><p>一、Map的实现类的结构： </p><p>Map:双列数据，存储key-value对的数据 。 </p><p>HashMap:作为Map的主要实现类；线程不安全的，效率高；存储null的key和value </p><p>LinkedHashMap:保证在遍历map元素时，可以按照添加的顺序实现遍历。 </p><p>原因：在原有的HashMap底层结构基础上，添加了一对指针，指向前一个和后一个元素。对于频繁 的遍历操作，此类执行效率高于HashMap。 </p><p>源码分析</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220314220552497.png" alt="image-20220314220552497"></p><p>该构造方法中，并没有立即创建Entry数组。</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220314220613212.png" alt="image-20220314220613212"></p><p>调用put方法</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220314221430005.png" alt="image-20220314221430005"></p><p>Properties:Properties 类是 Hashtable 的子类，该对象用于处理属性文件由于属性文件里的 key、 value 都是字符串类型，所以 Properties 里的 key 和 value 都是字符串类型存取数据时，建议使用 setProperty(String key,String value)方法和getProperty(String key)方法。 </p><p>TreeMap:保证按照添加的key-value对进行排序，实现排序遍历。此时考虑key的自然排序或定制 排序。底层使用红黑树。 </p><p>代码实现排序：<strong>Comparator接口</strong>和<strong>Comparable接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 默认的从小到大</span></span><br><span class="line"><span class="comment">    * 如果想进行从大到小则this.name.compareTo(user.name)</span></span><br><span class="line"><span class="comment">    * 前加一个负号</span></span><br><span class="line"><span class="comment">    * compareTo比较并不是equals</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * Comparator接口下的方法是：（定制排序）</span></span><br><span class="line"><span class="comment">    * int compare(T o1, T o2);</span></span><br><span class="line"><span class="comment">    * Comparable接口下的方法是：（treeSet中默认的排序所实现的接口，也是自然排序）</span></span><br><span class="line"><span class="comment">    * int compareTo(Object o)</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * 共性：</span></span><br><span class="line"><span class="comment">    * Integer.compare(user1.age, user2.age);这种方式适合比较数字</span></span><br><span class="line"><span class="comment">    * 此方法是Comparator接口下的方法</span></span><br><span class="line"><span class="comment">    * user1.compareTo(user2.name);这种适合比较字符</span></span><br><span class="line"><span class="comment">    * 此方法是Comparable接口下的方法</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">compare</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Comparator&lt;Object&gt; comparator = <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Object&gt;() &#123;</span><br><span class="line">            <span class="comment">//匿名实现</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(o1 <span class="keyword">instanceof</span> User &amp;&amp; o2 <span class="keyword">instanceof</span> User) &#123;</span><br><span class="line">                    <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> (User)o1;</span><br><span class="line">                    <span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> (User)o1;</span><br><span class="line">                    <span class="comment">// return Integer.compare(user1.age, user2.age);</span></span><br><span class="line">                    <span class="keyword">return</span> user1.compareTo(user2.name);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span>(o <span class="keyword">instanceof</span> User) &#123;</span><br><span class="line">            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User)o;</span><br><span class="line">            compare = -<span class="built_in">this</span>.name.compareTo(user.name);</span><br><span class="line">            <span class="keyword">if</span>(compare == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// return this.age.compareTo(user.age);</span></span><br><span class="line">                <span class="comment">//compare方法是Integer包装类自己定义的，并非Comparable接口下的方法</span></span><br><span class="line">                <span class="keyword">return</span> Integer.compare(<span class="built_in">this</span>.age, user.age);</span><br><span class="line">          &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> compare;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="6-、Collections工具类"><a href="#6-、Collections工具类" class="headerlink" title="6.、Collections工具类"></a>6.、Collections工具类</h2><p>Collections 是一个操作 Set、List 和 Map 等集合的工具类 </p><p>Collections 中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作， </p><p>还提供了对集合对象设置不可变、对集合对象实现同步控制等方法 </p><p>排序操作：（均为<strong>static方法）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">reverse(List)：反转 List 中元素的顺序</span><br><span class="line">shuffle(List)：对 List 集合元素进行随机排序</span><br><span class="line">sort(List)：根据元素的自然顺序对指定 List 集合元素按升序排序</span><br><span class="line">sort(List，Comparator)：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序</span><br><span class="line">swap(List，<span class="type">int</span>， <span class="type">int</span>)：将指定 list 集合中的 i 处元素和 j 处元素进行交换</span><br></pre></td></tr></table></figure><p><strong>常用方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Object <span class="title function_">max</span><span class="params">(Collection)</span>：根据元素的自然顺序，返回给定集合中的最大元素</span><br><span class="line">Object <span class="title function_">max</span><span class="params">(Collection，Comparator)</span>：根据 Comparator 指定的顺序，返回</span><br><span class="line">给定集合中的最大元素</span><br><span class="line">Object <span class="title function_">min</span><span class="params">(Collection)</span></span><br><span class="line">Object <span class="title function_">min</span><span class="params">(Collection，Comparator)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">frequency</span><span class="params">(Collection，Object)</span>：返回指定集合中指定元素的出现次数</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">copy</span><span class="params">(List dest,List src)</span>：将src中的内容复制到dest中 <span class="type">boolean</span></span><br><span class="line"><span class="title function_">replaceAll</span><span class="params">(List list，Object oldVal，Object newVal)</span>：使用新值替换</span><br><span class="line">List 对象的所有旧值</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    ......</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) o;</span><br><span class="line">        <span class="keyword">if</span> (!id.equals(person.id)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> name.equals(person.name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> id.hashCode();</span><br><span class="line">        result = <span class="number">31</span> * result + name.hashCode();</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123; </span><br><span class="line">        <span class="type">HashSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>(); </span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1001</span>,<span class="string">&quot;AA&quot;</span>); </span><br><span class="line">        <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1002</span>,<span class="string">&quot;BB&quot;</span>); </span><br><span class="line">        set.add(p1); </span><br><span class="line">        set.add(p2); </span><br><span class="line">        System.out.println(set); </span><br><span class="line">        p1.setName(<span class="string">&quot;CC&quot;</span>); set.remove(p1); </span><br><span class="line">        System.out.println(set); </span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1001</span>,<span class="string">&quot;CC&quot;</span>)); </span><br><span class="line">        System.out.println(set); </span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1001</span>,<span class="string">&quot;AA&quot;</span>)); </span><br><span class="line">        System.out.println(set); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习-1"><a href="#练习-1" class="headerlink" title="练习:"></a>练习:</h2><p>1、集合Collection中存储的如果是自定义类的对象，需要自定义类重写哪个方法？为什么？ </p><p>2、ArrayList,LinkedList,Vector三者的相同点和不同点 </p><p>3、List接口的常用方法有哪些 </p><p>4、Set存储数据的特点是什么？有哪些实现类，简述各实现类的特点 </p><p>5、如何去除list中重复的数据 </p><p>6、创建一个List集合的对象，添加几个数字，反转对象中元素的顺序；根据元素的自然顺序排序 </p><p>7、一组数列A[25,36,17,23,14] ,一组数列B[10,8,25,36,14,72] 将两个数列合并，重复只出现一次， 并按照从小到打输出 </p><p>8、随机生成五组双色球彩票，双色球规则，是这样的 红号是1-33 取六个不重复的，蓝号是1-16 取一个。 </p><p>9、课堂演示是学生管理系统，分别采用三个集合实现 </p><p>10、发的业务图片尝试实现[]</p><h1 id="十六、泛型"><a href="#十六、泛型" class="headerlink" title="十六、泛型"></a>十六、泛型</h1><p> 集合容器类在设计阶段&#x2F;声明阶段不能确定这个容器到底实际存的是什么类型的对象，所以在JDK1.5之前 只能把元素类型设计为Object，JDK1.5之后使用泛型来解决。因为这个时候除了元素的类型不确定，其 他的部分是确定的，例如关于这个元素如何保存，如何管理等是确定的，因此此时把元素的类型设计成 一个参数，这个类型参数叫做泛型。Collection，List，ArrayList 这个就是类型参数，即泛型。</p><p>所谓泛型，就是允许在定义类、接口时通过一个标识表示类中某个属性的类型或者是某个方法的返回值 及参数类型。这个类型参数将在使用时（例如，继承或实现这个接口，用这个类型声明变量、创建对象 时）确定（即传入实际的类型参数，也称为类型实参）。</p><p> 从JDK1.5以后，Java引入了“参数化类型（Parameterized type）”的概念，允许我们在创建集合时再指 定集合元素的类型，正如：List，这表明该List只能保存字符串类型的对象。 JDK1.5改写了集合框架中的 全部接口和类，为这些接口、类增加了泛型支持，从而可以在声明集合变量、创建集合对象时传入类型 实参。 </p><p><strong>为什么要有泛型？</strong> </p><p>解决元素存储的安全性问题，解决获取数据元素时，需要类型强制转换的问题。 </p><p>只有指定类型才可以添加到集合中：<strong>类型安全</strong> 读取出来的对象不需要强转：<strong>便捷</strong>。</p><p>Java泛型可以保证如果程序在编译时没有发出警告，运行时就不会产生ClassCastException异常。同 时，代码更加简洁、健壮。 </p><p>1、集合中使用泛型 </p><p>2、自定义泛型： </p><p>泛型类：泛型类型用于类的定义中，被称为泛型类。通过泛型可以完成对一组类的操作对外开放相同的 接口。最典型的就是各种容器类，如：List、Set、Map。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//泛型类的最基本写法（这么看可能会有点晕，会在下面的例子中详解）：</span></span><br><span class="line">class 类名称 &lt;泛型标识：可以随便写任意标识号，标识指定的泛型的类型&gt;&#123;</span><br><span class="line"><span class="keyword">private</span> 泛型标识 <span class="comment">/*（成员变量类型）*/</span> <span class="keyword">var</span>; .....</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span></span><br><span class="line"><span class="comment">//在实例化泛型类时，必须指定T的具体类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Generic</span>&lt;T&gt;&#123;</span><br><span class="line"><span class="comment">//key这个成员变量的类型为T,T的类型由外部指定</span></span><br><span class="line"><span class="keyword">private</span> T key;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Generic</span><span class="params">(T key)</span> &#123; <span class="comment">//泛型构造方法形参key的类型也为T，T的类型由外部指定</span></span><br><span class="line"><span class="built_in">this</span>.key = key;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">getKey</span><span class="params">()</span>&#123; <span class="comment">//泛型方法getKey的返回值类型为T，T的类型由外部指定 return key;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//泛型的类型参数只能是类类型（包括自定义类），不能是简单类型</span></span><br><span class="line"><span class="comment">//传入的实参类型需与泛型的类型参数类型相同，即为Integer.</span></span><br><span class="line">Generic&lt;Integer&gt; genericInteger = <span class="keyword">new</span> <span class="title class_">Generic</span>&lt;Integer&gt;(<span class="number">123456</span>); <span class="comment">//传入的实参类型需与泛型的类型参数类型相同，即为String.</span></span><br><span class="line">Generic&lt;String&gt; genericString = <span class="keyword">new</span> <span class="title class_">Generic</span>&lt;String&gt;(<span class="string">&quot;key_vlaue&quot;</span>);</span><br></pre></td></tr></table></figure><p>泛型接口：泛型接口与泛型类的定义及使用基本相同。泛型接口常被用在各种类的生产器中，可以看一 个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个泛型接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Generator</span>&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*** 未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中</span></span><br><span class="line"><span class="comment">即：class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;&#123; &#125;</span></span><br><span class="line"><span class="comment">如果不声明泛型，如：</span></span><br><span class="line"><span class="comment">class FruitGenerator implements Generator&lt;T&gt;，编译器会报错：&quot;Unknown class&quot;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FruitGenerator</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Generator</span>&lt;T&gt;&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*** 传入泛型实参时：</span></span><br><span class="line"><span class="comment">定义一个生产器实现这个接口,虽然我们只创建了一个泛型接口Generator&lt;T&gt;</span></span><br><span class="line"><span class="comment">但是我们可以为T传入无数个实参，形成无数种类型的Generator接口。</span></span><br><span class="line"><span class="comment">在实现类实现泛型接口时，如已将泛型类型传入实参类型，则所有使用泛型的地方都要替换成传入的实</span></span><br><span class="line"><span class="comment">参类型</span></span><br><span class="line"><span class="comment">即：Generator&lt;T&gt;，public T next();中的的T都要替换成传入的String类型。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FruitGenerator</span> <span class="keyword">implements</span> <span class="title class_">Generator</span>&lt;String&gt; &#123;</span><br><span class="line"><span class="keyword">private</span> String[] fruits = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Pear&quot;</span>&#125;;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"><span class="keyword">return</span> fruits[rand.nextInt(<span class="number">3</span>)];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>泛型方法：</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220319095317417.png" alt="image-20220319095317417"></p><h1 id="十七、文件与IO"><a href="#十七、文件与IO" class="headerlink" title="十七、文件与IO"></a>十七、文件与IO</h1><h2 id="1、File类的使用"><a href="#1、File类的使用" class="headerlink" title="1、File类的使用"></a>1、File类的使用</h2><p>java.io.File类：文件和文件目录路径的抽象表示形式，与平台无关。 </p><p>File 能新建、删除、重命名文件和目录，但 File 不能访问文件内容本身。如果需要访问文件内容本身， 则需要使用输入&#x2F;输出流。 </p><p>想要在Java程序中表示一个真实存在的文件或目录，那么必须有一个File对 象，但是Java程序中的一个 File对象，可能没有一个真实存在的文件或目录。 </p><p><strong>构造方法：</strong></p><p><strong>public File(String pathname)</strong> 以pathname为路径创建File对象，可以是<strong>绝对路径或者相对路径</strong>，如 果pathname是相对路径，则默认的当前路径在系统属性user.dir中存储。 绝对路径：是一个固定的路 径,从盘符开始相对路径：是相对于某个位置开始 </p><p>**public File(String parent,String child)**以parent为父路径，child为子路径创建File对象。 </p><p>**public File(File parent,String child)**根据一个父File对象和子文件路径创建File对象。 </p><p><strong>常用方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">File类的获取功能</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getAbsolutePath</span><span class="params">()</span>：获取绝对路径</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getPath</span><span class="params">()</span> ：获取路径</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> ：获取名称</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getParent</span><span class="params">()</span>：获取上层文件目录路径。若无，返回<span class="literal">null</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">length</span><span class="params">()</span> ：获取文件长度（即：字节数）。不能获取目录的长度。</span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">lastModified</span><span class="params">()</span> ：获取最后一次的修改时间，毫秒值</span><br><span class="line"><span class="keyword">public</span> String[] list() ：获取指定目录下的所有文件或者文件目录的名称数组</span><br><span class="line"><span class="keyword">public</span> File[] listFiles() ：获取指定目录下的所有文件或者文件目录的File数组</span><br><span class="line">File类的重命名功能</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">renameTo</span><span class="params">(File dest)</span>:把文件重命名为指定的文件路径</span><br><span class="line">File类的判断功能</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isDirectory</span><span class="params">()</span>：判断是否是文件目录</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFile</span><span class="params">()</span> ：判断是否是文件</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">exists</span><span class="params">()</span> ：判断是否存在</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canRead</span><span class="params">()</span> ：判断是否可读</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canWrite</span><span class="params">()</span> ：判断是否可写</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHidden</span><span class="params">()</span> ：判断是否隐藏</span><br></pre></td></tr></table></figure><p>**listFiles():**方法介绍文件都存放在目录（文件夹）中，那么如何获取一个目录中的所有文件或者目录中 的文件夹呢？那么我们先想想，一个目录中可能有多个文件或者文件夹，那么如果File中有功能获取到一 个目录中的所有文件和文件夹，那么功能得到的结果要么是数组，要么是集合。 </p><p>**文件过滤器:**通过上述方法，我们可以获取到一个目录下的所有文件和文件夹，但能不能对其进行过滤 呢？比如我们只想要一个目录下的指定扩展名的文件，或者包含某些关键字的文件夹呢？我们是可以先 把一个目录下的所有文件和文件夹获取到，并遍历当前获取到所有内容，遍历过程中在进行筛选，但是 这个动作有点麻烦，Java给我们提供相应的功能来解决这个问题。查阅File类的API，在查阅时发现File类 中重载的listFiles方法，并且接受指定的过滤器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileDemo2</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//获取扩展名为.java所有文件</span></span><br><span class="line"><span class="comment">//创建File对象</span></span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\JavaSE1115\\code\\day11_code&quot;</span>);</span><br><span class="line"><span class="comment">//获取指定扩展名的文件,由于要对所有文件进行扩展名筛选，因此调用方法需要传递过滤器</span></span><br><span class="line">File[] files = file.listFiles(<span class="keyword">new</span> <span class="title class_">FileFilterBySuffix</span>()); <span class="comment">//遍历获取到的所有符合条件的文件</span></span><br><span class="line"><span class="keyword">for</span> (File f : files) &#123;</span><br><span class="line">System.out.println(f);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义类实现文件名称FilenameFilter过滤器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileFilterBySuffix</span> <span class="keyword">implements</span> <span class="title class_">FilenameFilter</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">accept</span><span class="params">(File dir, String name)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> name.endsWith(<span class="string">&quot;.java&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileFilterBySuffix</span> <span class="keyword">implements</span> <span class="title class_">FileFilter</span>&#123;</span><br><span class="line"><span class="keyword">private</span> String suffix;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FileFilterBySuffix</span><span class="params">(String suffix)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line"><span class="built_in">this</span>.suffix = suffix;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">accept</span><span class="params">(File pathname)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> pathname.getName().endsWith(suffix);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2、IO流"><a href="#2、IO流" class="headerlink" title="2、IO流"></a>2、IO流</h2><p>I&#x2F;O是Input&#x2F;Output的缩写， I&#x2F;O技术是非常实用的技术，用于处理设备之间的数据传输。如读&#x2F;写文 件，网络通讯等。 </p><p>Java程序中，对于数据的输入&#x2F;输出操作以“流(stream)”的方式进行。</p><p>IO原理：输入input:读取外部数据到程序(内存)中 </p><p>​输出output:将程序(内存)数据输出到磁盘、光盘等存储社保中。 </p><p>流的分类：按照数据单位来分：字节流，字符流 </p><p>​按照流向来分：输入流，输出流。</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220220202806515.png" alt="image-20220220202806515"></p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220220202815280.png" alt="image-20220220202815280"></p><p>流的体系：</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220220202827677.png" alt="image-20220220202827677"></p><h2 id="3、InputStream和Reader"><a href="#3、InputStream和Reader" class="headerlink" title="3、InputStream和Reader"></a>3、InputStream和Reader</h2><p>InputStream和Reader是所有输入流的基类 </p><p>InputStream典型实现是FileInputStream。常用方法read()方法【int read()； int read(byte[] b) ；int read(byte[] b, int off, int len) 】 </p><p>Reader典型实现是FileReader。常用方法read()方法【int read()； int read(byte[] b) ；int read(byte[] b, int off, int len) 】 </p><p>程序中打开的文件 IO 资源不属于内存里的资源，垃圾回收机制无法回收该资源，所以应该<strong>显式关闭文件 IO 资源。</strong> </p><p>FileInputStream 从文件系统中的某个文件中获得输入字节。FileInputStream 用于读取非文本数据之类 的原始字节流。要读取字符流，需要使用 FileReader。 </p><h3 id="InputStream方法介绍："><a href="#InputStream方法介绍：" class="headerlink" title="InputStream方法介绍："></a><strong>InputStream方法介绍：</strong></h3><p><strong>int read()：</strong>从输入流中读取数据的下一个字节。返回 0 到 255 范围内的 int 字节值。如果因为已经到 达流末尾而没有可用的字节，则返回值 -1。</p><p><strong>int read(byte[] b)：</strong>从此输入流中将最多 b.length 个字节的数据读入一个 byte 数组中。如果因为已经 到达流末尾而没有可用的字节，则返回值 -1。否则以整数形式返回实际读取的字节数。 </p><p><strong>int read(byte[] b, int off,int len)：</strong>将输入流中最多 len 个数据字节读入 byte 数组。尝试读取 len 个 字节，但读取的字节也可能小于该值。以整数形式返回实际读取的字节数。如果因为流位于文件末尾而 没有可用的字节，则返回值 -1。 </p><p><strong>public void close() throws IOException</strong>关闭此输入流并释放与该流关联的所有系统资源。 </p><h3 id="Reader方法介绍："><a href="#Reader方法介绍：" class="headerlink" title="Reader方法介绍："></a>Reader方法介绍：</h3><p>**int read()**读取单个字符。作为整数读取的字符，范围在 0 到 65535 之间 (0x00-0xffff)（2个字节的 Unicode码），如果已到达流的末尾，则返回 -1 </p><p>**int read(char[] cbuf)**将字符读入数组。如果已到达流的末尾，则返回 -1。否则返回本次读取的字符 数。</p><p>**int read(char[] cbuf,int off,int len)**将字符读入数组的某一部分。存到数组cbuf中，从off处开始存 储，最多读len个字符。如果已到达流的末尾，则返回 -1。否则返回本次读取的字符数。 </p><p><strong>public void close() throws IOException</strong>关闭此输入流并释放与该流关联的所有系统资源。 </p><h2 id="4、OutputStream和Writer"><a href="#4、OutputStream和Writer" class="headerlink" title="4、OutputStream和Writer"></a>4、OutputStream和Writer</h2><p> OutputStream 和 Writer 也非常相似： </p><p>void write(int b&#x2F;int c); </p><p>void write(byte[] b&#x2F;char[] cbuf); </p><p>void write(byte[] b&#x2F;char[] buff, int off, int len); </p><p>void flush(); </p><p>void close(); 需要先刷新，再关闭此流。 </p><p>因为字符流直接以字符作为操作单位，所以 Writer 可以用字符串来替换字符数组，即以 String 对象作 为参数</p><p> <strong>void write(String str);</strong> </p><p><strong>void write(String str, int off, int len);</strong> </p><p>FileOutputStream 从文件系统中的某个文件中获得输出字节。FileOutputStream 用于写出非文本数据 之类的原始字节流。要写出字符流，需要使用 FileWriter。 </p><h3 id="练习：-18"><a href="#练习：-18" class="headerlink" title="练习："></a>练习：</h3><p>将学生对象(姓名，语文分数，数学分数，英语分数，总分)按照总分从高到低排序，并将姓名和从 高到低总分写入文件中。 </p><h2 id="5、缓冲流"><a href="#5、缓冲流" class="headerlink" title="5、缓冲流"></a>5、缓冲流</h2><p>为了提高数据读写的速度，Java API提供了带缓冲功能的流类，在使用这些流类时，会创建一个内部缓 冲区数组，缺省使用8192个字节(8Kb)的缓冲区。 </p><p>缓冲流要“套接”在相应的节点流之上，根据数据操作单位可以把缓冲流分为：</p><p> <strong>BufferedInputStream 和 BufferedOutputStream</strong> </p><p><strong>BufferedReader 和 BufferedWriter</strong> </p><p>当读取数据时，数据按块读入缓冲区，其后的读操作则直接访问缓冲区 </p><p>当使用BufferedInputStream读取字节文件时，BufferedInputStream会一次性从文件中读取8192个 (8Kb)，存在缓冲区中，直到缓冲区装满了，才重新从文件中读取下一个8192个字节数组。 </p><p>向流中写入字节时，不会直接写到文件，先写到缓冲区中直到缓冲区写满，BufferedOutputStream才 会把缓冲区中的数据一次性写到文件里。使用方法flush()可以强制将缓冲区的内容全部写入输出流 </p><p>关闭流的顺序和打开流的顺序相反。只要关闭最外层流即可，关闭最外层流也会相应关闭内层节点流 </p><p>flush()方法的使用：手动将buffer中内容写入文件</p><p>如果是带缓冲区的流对象的close()方法，不但会关闭流，还会在关闭流之前刷新缓冲区，关闭后不能再 写出</p><h2 id="6、转换流"><a href="#6、转换流" class="headerlink" title="6、转换流"></a>6、转换流</h2><p>转换流提供了在字节流和字符流之间的转换。 </p><p>Java API提供了两个转换流： </p><p><strong>InputStreamReader</strong>：将InputStream转换为Reader </p><p><strong>OutputStreamWriter</strong>：将Writer转换为OutputStream </p><p>字节流中的数据都是字符时，转成字符流操作更高效。 </p><p>很多时候我们使用转换流来处理文件乱码问题。实现编码和解码的功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:\\test\\cn8.txt&quot;</span>);</span><br><span class="line"><span class="comment">//创建转换流对象</span></span><br><span class="line"><span class="comment">//InputStreamReader isr = new InputStreamReader(in);这样创建对象，会用本地默认码</span></span><br><span class="line">表 读取，将会发生错误解码的错误</span><br><span class="line"><span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(in,<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"><span class="comment">//使用转换流去读字节流中的字节</span></span><br><span class="line"><span class="type">int</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((ch = isr.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">System.out.println((<span class="type">char</span>)ch);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关闭流</span></span><br><span class="line">isr.close();</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建与文件关联的字节输出流对象</span></span><br><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;D:\\test\\cn8.txt&quot;</span>);</span><br><span class="line"><span class="comment">//创建可以把字符转成字节的转换流对象，并指定编码</span></span><br><span class="line"><span class="type">OutputStreamWriter</span> <span class="variable">osw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(fos,<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"><span class="comment">//调用转换流，把文字写出去，其实是写到转换流的缓冲区中</span></span><br><span class="line">osw.write(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line"><span class="comment">//写入缓冲区。</span></span><br><span class="line">osw.close();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>字符编码：<strong>常见的编码表</strong> </p><p>ASCII：美国标准信息交换码。用一个字节的7位可以表示。 </p><p>ISO8859-1：拉丁码表。欧洲码表用一个字节的8位表示。 </p><p>GB2312：中国的中文编码表。最多两个字节编码所有字符 </p><p>GBK：中国的中文编码表升级，融合了更多的中文文字符号。最多两个字节编码 </p><p>Unicode：国际标准码，融合了目前人类使用的所有字符。为每个字符分配唯一的字符码。所有的文字 都用两个字节来表示。 </p><p>UTF-8：变长的编码方式，可用1-4个字节来表示一个字符 </p><h2 id="7、标准输入、输出流"><a href="#7、标准输入、输出流" class="headerlink" title="7、标准输入、输出流"></a>7、标准输入、输出流</h2><p>System.in和System.out分别代表了系统标准的输入和输出设备 </p><p>默认输入设备是：键盘，输出设备是：显示器 </p><p>System.in的类型是InputStream </p><p>System.out的类型是PrintStream，其是OutputStream的子类</p><p>FilterOutputStream 的子类 </p><p>重定向：通过System类的setIn，setOut方法对默认设备进行改变。 </p><p>public static void <strong>setIn</strong>(InputStream in) </p><p>public static void <strong>setOut</strong>(PrintStream out)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">while</span>((s=br.readLine())!=<span class="literal">null</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="string">&quot;e&quot;</span>.equalsIgnoreCase(s)||<span class="string">&quot;exit&quot;</span>.equalsIgnoreCase(s))&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;安全退出&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;---&gt;&quot;</span>+s.toUpperCase());</span><br><span class="line">System.out.println(<span class="string">&quot;继续输入信息&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(br!=<span class="literal">null</span>)&#123;</span><br><span class="line">br.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">FileOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span></span><br><span class="line"><span class="title class_">File</span>(<span class="string">&quot;D:/out.txt&quot;</span>));</span><br><span class="line">ps = <span class="keyword">new</span> <span class="title class_">PrintStream</span>(out,<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">if</span>(ps!=<span class="literal">null</span>)&#123;</span><br><span class="line">System.setOut(ps);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">65</span>;i&lt;=<span class="number">91</span>;i++)&#123;</span><br><span class="line">System.out.print((<span class="type">char</span>)i);</span><br><span class="line"><span class="keyword">if</span>(i%<span class="number">50</span>==<span class="number">0</span>)&#123;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(ps!=<span class="literal">null</span>)&#123;</span><br><span class="line">ps.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="8、对象流"><a href="#8、对象流" class="headerlink" title="8、对象流"></a>8、对象流</h2><p>ObjectInputStream和OjbectOutputSteam:用于存储和读取基本数据类型数据或对象的处理流。它的强 大之处就是可以把Java中的对象写入到数据源中，也能把对象从数据源中还原回来。 </p><p><strong>序列化：</strong>用ObjectOutputStream类<strong>保存</strong>基本类型数据或对象的机制。 </p><p><strong>反序列化：</strong>用ObjectInputStream类<strong>读取</strong>基本类型数据或对象的机制。 </p><p><strong>对象的序列化：</strong>对象序列化机制允许把内存中的Java对象转换成平台无关的二进制流，从而允许把这种 二进制流持久地保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点。&#x2F;&#x2F;当其它程序获取 了这种二进制流，就可以恢复成原来的Java对象。序列化的好处在于可将任何实现了Serializable接口的 对象转换为字节数据，使其在保存和传输时可被还原。序列化是RMI(Remote Method Invoke-远程方法 调用)过程的参数和返回值都必须实现的机制。而RMI是javaEE的基础，因此序列化机制是JavaEE平台的 基础。如果需要让某个对象支持序列化机制，则必须让对象所属的类及其属性是可序列化的，为了让某 个类是可序列化的，该类必须实现如下两个接口之一，否则会抛出NotSerializableException。通常实现 <strong>Serializable</strong> </p><p>凡是实现Serializable接口的类都有一个表示序列化版本标识符的静态变量： </p><p><strong>private static final long serialVersionUID;</strong></p><p>serialVersionUID用来表明类的不同版本间的兼容性。简言之，其目的是以序列化对象进行版本控制， 有关各版本反序列化时是否兼容。 </p><p>如果类没有显示定义这个静态常量，它的值是Java运行时环境根据类的内部细节自动生成的。若类的实 例变量做了修改，serialVersionUID 可能发生变化。故建议，显式声明。 </p><p>简单来说，Java的序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的。在进行 反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体类的serialVersionUID进行比 较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常。 (InvalidCastException)。 </p><p>若某个类实现了 Serializable 接口，该类的对象就是可序列化的： </p><p>创建一个 ObjectOutputStream </p><p>调用 ObjectOutputStream 对象的 writeObject(对象) 方法输出可序列化对象 </p><p>注意写出一次，操作flush()一次。 </p><p>反序列化 </p><p>创建一个 ObjectInputStream </p><p>调用 readObject() 方法读取流中的对象 </p><p>强调：如果某个类的属性不是基本数据类型或 String 类型，而是另一个引用类型，那么这个引用类型必 须是可序列化的，否则拥有该类型的Field 的类也不能序列化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///序列化：将对象写入到磁盘或者进行网络传输</span></span><br><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span></span><br><span class="line"><span class="title class_">FileOutputStream</span>(“data.txt<span class="string">&quot;));</span></span><br><span class="line"><span class="string">Person p = new Person(&quot;</span>张三<span class="string">&quot;, 18, &quot;</span>太白小区<span class="string">&quot;);</span></span><br><span class="line"><span class="string">oos.writeObject(p);</span></span><br><span class="line"><span class="string">oos.flush();</span></span><br><span class="line"><span class="string">oos.close();</span></span><br><span class="line"><span class="string">//反序列化：将磁盘中的对象数据源读出.</span></span><br><span class="line"><span class="string">ObjectInputStream ois = new ObjectInputStream(new</span></span><br><span class="line"><span class="string">FileInputStream(“data.txt&quot;</span>));</span><br><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> (Person)ois.readObject();</span><br><span class="line">System.out.println(p1.toString());</span><br><span class="line">ois.close();</span><br></pre></td></tr></table></figure><p>谈谈你对Serializable接口的理解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">实现了Serializable接口的对象，可将它们转换成一系列字节，并可在以后完全恢复回原来的样子。这一过程亦可通过网络进行。这意味着序列化机制能自动补偿操作系统间的差异。换句话说，可以先在Windows机器上创建一个对象，对其序列化，然后通过网络发给一台Unix机器，然后在那里准确无误地重新“装配”。不必关心数据在不同机器上如何表示，也不必关心字节的顺序或者其他任何细节。</span><br><span class="line">由于大部分作为参数的类如String、Integer等都实现了java.io.Serializable的接口，也可以利用多态的性质，作为参数使接口更灵活</span><br></pre></td></tr></table></figure><p>瞬态关键字 </p><p>当一个类的对象需要被序列化时，某些属性不需要被序列化，这时不需要序列化的属性可以使用关键字 transient修饰。只要被transient修饰了，序列化时这个属性就不会琲序列化了。同时静态修饰也不会被 序列化，因为序列化是把对象数据进行持久化存储，而静态的属于类加载时的数据，不会被序列化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"><span class="comment">/** 给类显示声明一个序列版本号。 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span><span class="comment">/*瞬态*/</span> <span class="type">int</span> age;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line"><span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="十八、反射"><a href="#十八、反射" class="headerlink" title="十八、反射"></a>十八、反射</h1><p>Reflection（反射）是被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API取得任 何类的内部信息，并能直接操作任意对象的内部属性及方法。 </p><p>加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象（一个类只有一个Class对象），这 个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子， 透过这个镜子看到类的结构，所以，我们形象的称之为：<strong>反射。</strong></p><p><strong>动态语言</strong> </p><p>是一类在运行时可以改变其结构的语言：例如新的函数、对象、甚至代码可以被引进，已有的函数可以 被删除或是其他结构上的变化。通俗点说就是<strong>在运行时代码可以根据某些条件改变自身结构。</strong>主要 动态语言：Object-C、C#、JavaScript、PHP、Python、Erlang。 </p><p><strong>静态语言</strong>与动态语言相对应的，运行时结构不可变的语言就是静态语言。如Java、C、C++。 </p><p>Java不是动态语言，但Java可以称之为“准动态语言”。即Java有一定的动态性，我们可以利用反射机制、 字节码操作获得类似动态语言的特性。Java的动态性让编程的时候更加灵活！ </p><p>Java反射机制提供的功能： </p><p>在运行时判断任意一个对象所属的类 </p><p>在运行时构造任意一个类的对象 </p><p>在运行时判断任意一个类所具有的成员变量和方法 </p><p>在运行时获取泛型信息 </p><p>在运行时调用任意一个对象的成员变量和方法 </p><p>在运行时处理注解 </p><p>生成动态代理 </p><p>反射机制主要API </p><p>**java.lang.Class:**代表一个类 </p><p><strong>java.lang.reflect.Method</strong>:代表类的方法 </p><p>**java.lang.reflect.Field:**代表类的成员变量 </p><p>**java.lang.reflect.Constructor:**代表类的构造器 </p><h2 id="1、Class类"><a href="#1、Class类" class="headerlink" title="1、Class类"></a>1、Class类</h2><p>在Object类中定义了以下的方法，此方法将被所有子类继承 </p><p>以上的方法返回值的类型是一个Class类，此类是Java反射的源头，实际上所谓反射从程序的运行结果来 看也很好理解，即：可以通过对象反射求出类的名称。 </p><p>Class类：某个类的属性、方法和构造器、某个类到底实现了哪些接口。对于每个类而言，JRE 都为其保 留一个不变的 Class 类型的对象。一个 Class 对象包含了特定某个结构 (class&#x2F;interface&#x2F;enum&#x2F;annotation&#x2F;primitive type&#x2F;void&#x2F;[])的有关信息。 </p><p>Class本身也是一个类。Class对象只能由系统建立对象。 </p><p>一个加载的类再JVM中只会由一个Class实例。一个Class对象对应一个加载到JVM中的要给.class文件。 </p><p>每个类的实例都会记得自己是由哪个Class实例所生成。 </p><p>通过Class可以完整得到一个类中的所有被加载的结构。 Class类是Reflection的根源，针对任何你想动态加载，运行的类，必须先获取相应的Class对象。 </p><p>获取Class的几种方法： </p><p>1&gt;若已知具体的类，通过类的class属性获取，该方法最可靠，程序性能最高。 </p><p>Class clazz &#x3D; Person.class </p><p>2&gt;若已知某个类的对象，调用该对象的getClass方法获取class对象 </p><p>3&gt;知道类的全名，通过 Class.forName();获取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">类:获取类的方式 Class.forName(<span class="string">&quot;&quot;</span>);</span><br><span class="line">                 对象.getClass();</span><br><span class="line">                 类.class</span><br><span class="line">      加载类只会加载一次</span><br><span class="line">    获取类后才能获取类内部信息，属性，方法，构造方法</span><br><span class="line">    获取类后，newInstance方法创建对象，该方法默认会找无参构造,类中必须包含一个无参构造。【】</span><br><span class="line">    有了类后需要获取属性Field类型的对象</span><br><span class="line">    clazz.getFields();<span class="keyword">public</span>修饰的属性</span><br><span class="line">    对于属性的操作有哪些?赋值,取值</span><br><span class="line">       静态属性:可以通过类直接操作,直接获取值或直接赋值</span><br><span class="line">       非静态属性:依赖对象，通过对象. 给对象是属性赋值或取值</span><br><span class="line">       <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       dog.setXm();</span><br><span class="line">    getField(<span class="string">&quot;name&quot;</span>):通过属性名获取属性信息</span><br><span class="line">     field.set();</span><br><span class="line">     field.get();</span><br><span class="line">     field.setAccessible(<span class="literal">true</span>);可以访问私有化的属性 </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2、类的加载与ClassLoader的理解"><a href="#2、类的加载与ClassLoader的理解" class="headerlink" title="2、类的加载与ClassLoader的理解"></a>2、类的加载与ClassLoader的理解</h2><p> 当程序主动创建某个类时，如果该类还未被加载到内存中，则系统会通过以下三个步骤来对类进行初 始化。 </p><p>1&gt;类的加载:将类的class文件读入内存，并为之创建和一个java.lang.Class对象，该过程由类加载器完 成。 </p><p>类的加载与ClassLoader的理解：加载：将class文件字节码内容加载到内存中，并将这些静态数据转换 成方法区的运行时数据，然后生成一个代表这个类的Class对象，作为方法区中类数据的访问入口(地址 引用)。所有需要访问和使用类数据只能通过这个Class对象，这个加载的过程需要类加载器参与。 </p><p>2&gt;类的链接：将类的二进制数据合并到jre中。 </p><p>将java类的二进制代码合并到JVM的运行状态之中的过程。 </p><p>验证：确保加载的类信息符号JVM规范，利润，已cafe开头，没有安全方面的问题。</p><p>准备：正式为类变量static分配内存并设置类变量默认初始值的阶段，这些内存都将再方法区中进行 分配。 </p><p>解析：虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程 </p><p>3&gt;类的初始化：jvm负责对类进行初始化 </p><p>执行类构造器clinit()方法的过程，类构造器clinit()方法是由编译期自动收集类中所有类变量的赋值动 作和静态代码块中的语句合并产生的。类构造器是构造类信息，不说构造该类对象的构造器。 </p><p>当初始化一个类的时候，如果发现其父类还没进行初始化，则需要先触发其父类的初始化。 </p><p>虚拟机会保证一个类的clinit()方法在多线程环境中被正确加锁和同步。 </p><p><strong>ClassLoader:</strong></p><p> <a href="https://zhuanlan.zhihu.com/p/44670213">https://zhuanlan.zhihu.com/p/44670213</a></p><h2 id="3、创建运行时类的对象"><a href="#3、创建运行时类的对象" class="headerlink" title="3、创建运行时类的对象"></a>3、创建运行时类的对象</h2><p>有了Class对象，能做什么？ </p><p><strong>创建类的对象</strong>：调用Class对象的newInstance()方法 </p><p>要 求： 1）类必须有一个无参数的构造器。2）类的构造器的访问权限需要足够。</p><h2 id="4、获取运行时类的完整结构"><a href="#4、获取运行时类的完整结构" class="headerlink" title="4、获取运行时类的完整结构"></a>4、获取运行时类的完整结构</h2><p>通过反射获取运行时类的完整结构:Field、Method、Constructor、Superclass、Interface、 Annotation。 </p><p>使用反射可以取得： </p><h3 id="1-实现的全部接口"><a href="#1-实现的全部接口" class="headerlink" title="1.实现的全部接口"></a>1.实现的全部接口</h3><p>public Class[] getInterfaces() 确定此对象所表示的类或接口实现的接口。 </p><h3 id="2-所继承的父类"><a href="#2-所继承的父类" class="headerlink" title="2.所继承的父类"></a>2.所继承的父类</h3><p>public Class getSuperclass()返回表示此 Class 所表示的实体（类、接口、基本类型）的父 类的Class </p><h3 id="3-全部的构造器"><a href="#3-全部的构造器" class="headerlink" title="3.全部的构造器"></a>3.全部的构造器</h3><p>public Constructor[] getConstructors()返回此 Class 对象所表示的类的所有public构造方法。 </p><p>public Constructor[] getDeclaredConstructors()返回此 Class 对象表示的类声明的所有构造方法。 </p><p>Constructor类中：取得修饰符: public int getModifiers();取得方法名称: public String getName();取得 参数的类型：public Class[] getParameterTypes();</p><h3 id="4-全部的方法"><a href="#4-全部的方法" class="headerlink" title="4.全部的方法"></a>4.全部的方法</h3><p>public Method[] getDeclaredMethods()返回此Class对象所表示的类或接口的全部方法 </p><p>public Method[] getMethods() 返回此Class对象所表示的类或接口的public的方法 </p><p>Method类中：public Class getReturnType()取得全部的返回值 </p><p>public Class[] getParameterTypes()取得全部的参数 </p><p>public int getModifiers()取得修饰符 </p><p>public Class[] getExceptionTypes()取得异常信息。</p><p> <strong>调用指定的方法</strong></p><p>通过反射，调用类中的方法，通过Method类完成。步骤： </p><p>1&gt;通过Class类的**getMethod(String name,Class…parameterTypes)**方法取得一个Method对象，并 设置此方法操作时所需要的参数类型。 </p><p>2&gt;之后使用**Object invoke(Object obj, Object[] args)**进行调用，并向方法中传递要设置的obj对象的 参数信息 </p><p><strong>Object invoke(Object obj, Object … args):</strong> </p><p><strong>说明：</strong> </p><p>Object 对应原方法的返回值，若原方法无返回值，此时返回null </p><p>若原方法若为静态方法，此时形参Object obj可为null </p><p>若原方法形参列表为空，则Object[] args为null </p><p>若原方法声明为private,则需要在调用此invoke()方法前，显式调用方法对象的setAccessible(true)方 法，将可访问private的方法 </p><h3 id="5-全部的Field"><a href="#5-全部的Field" class="headerlink" title="5.全部的Field"></a>5.全部的Field</h3><p>public Field[] getFields() 返回此Class对象所表示的类或接口的public的Field。 </p><p>public Field[] getDeclaredFields() 返回此Class对象所表示的类或接口的全部Field。 </p><p>Field方法中：public int getModifiers() 以整数形式返回此Field的修饰符 </p><p>public Class getType() 得到Field的属性类型 </p><p>public String getName() 返回Field的名称。 </p><p><strong>调用指定属性</strong> </p><p>在反射机制中，可以直接通过Field类操作类中的属性，通过Field类提供的set()和get()方法就可以完成设 置和取得属性内容的操作。 </p><p>public Field getField(String name) 返回此Class对象表示的类或接口的指定的public的Field。 </p><p>public Field getDeclaredField(String name)返回此Class对象表示的类或接口的指定的Field。 </p><p>在Field中： </p><p>public Object get(Object obj) 取得指定对象obj上此Field的属性内容 </p><p>public void set(Object obj,Object value) 设置指定对象obj上此Field的属性内容 </p><h3 id="6-Annotation相关"><a href="#6-Annotation相关" class="headerlink" title="6.Annotation相关"></a>6.Annotation相关</h3><p>get Annotation(Class annotationClass) getDeclaredAnnotations() </p><h3 id="7-泛型相关"><a href="#7-泛型相关" class="headerlink" title="7.泛型相关"></a>7.泛型相关</h3><p>获取父类泛型类型：Type getGenericSuperclass() </p><p>泛型类型：ParameterizedType 获取实际的泛型类型参数数组：getActualTypeArguments() </p><h3 id="8-类所在的包"><a href="#8-类所在的包" class="headerlink" title="8.类所在的包"></a>8.类所在的包</h3><p>Package getPackage()</p><h2 id="5、动态代理"><a href="#5、动态代理" class="headerlink" title="5、动态代理"></a>5、动态代理</h2><p>创建接口与接口的实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">update</span><span class="params">(Users user)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl1</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;userDao中实现类1的save&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">update</span><span class="params">(Users user)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dao实现类1执行了。。。&quot;</span>+user);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dao实现类1执行了。。。。&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> ii.创建InvocationHandler</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyInvocationHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法执行之前执行....&quot;</span>+method.getName()+<span class="string">&quot;....&quot;</span>+ Arrays.toString(args));</span><br><span class="line">        <span class="type">Object</span> <span class="variable">res</span> <span class="operator">=</span> method.invoke(target,args);</span><br><span class="line">        System.out.println(<span class="string">&quot;方法执行之后执行&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testProxy</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">UserDaoImpl1</span> <span class="variable">dao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl1</span>();</span><br><span class="line">        Class[] classes = dao.getClass().getInterfaces();</span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">proxy</span> <span class="operator">=</span> (UserDao) Proxy.newProxyInstance(SpringTest.class.getClassLoader(),classes,<span class="keyword">new</span> <span class="title class_">MyInvocationHandler</span>(dao));</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> proxy.test(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">        System.out.println(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="十九、网络编程"><a href="#十九、网络编程" class="headerlink" title="十九、网络编程"></a>十九、网络编程</h1><p>Java是 Internet 上的语言，它从语言级上提供了对网络应用程序的支持，程序员能够很容易开发常见的 网络应用程序。 </p><p>Java提供的网络类库，可以实现无缝的网络连接，联网的底层细节被隐藏在 Java 的本机安装系统里，由 JVM 进行控制。并且 Java 实现了一个跨平台的网络库，程序员面对的是一个统一的网络编程环境。</p><p>网络编程的目的就是指直接或间接地通过网络协议与其它计算机进行通讯。 </p><p>网络编程中有两个主要的问题: </p><p>如何准确地定位网络上一台或多台主机 </p><p>找到主机后如何可靠高效地进行数据传输 </p><p>要想让处于网络中的主机互相通信，只是知道通信双方地址还是不够的，还必须遵循一定的规则。有两 套参考模型： </p><p>OSI参考模型：模型过于理想化，未能在因特网上进行广泛推广 </p><p>TCP&#x2F;IP参考模型(或TCP&#x2F;IP协议)：事实上的国际标准。 </p><ol><li>TCP&#x2F;IP协议</li></ol><p>TCP&#x2F;IP 以其两个主要协议：传输控制协议(TCP)和网络互联协议(IP)而得名，实际上是一组协议，包括多 个具有不同功能且互为关联的协议。</p><p> TCP&#x2F;IP协议模型从更实用的角度出发，形成了高效的四层体系结构，即网络接口层、IP层、传输层和应 用层。下图表示了TCP&#x2F;IP的分层结构和与OSI参考模型的对应关系。</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220323144147553.png" alt="image-20220323144147553"></p><p><strong>传输层协议中有两个非常重要的协议：</strong> </p><ul><li><p>传输控制协议TCP(Transmission Control Protocol) </p></li><li><p>用户数据报协议UDP(User Datagram Protocol)。</p></li></ul><p>传输控制协议TCP是面向连接的传输层协议。即应用进程(或程序)在使用TCP协议之前，必须先建立TCP 连接，在传输完毕后，释放已经建立的连接。利用TCP协议进行通信的两个应用进程，一个是服务器进 程。另一个是客户进程。</p><p>• 用户数据报协议UDP是面向无连接的运输层协议。即应用进程(或程序)在使用UDP协议之前，不必先建 立连接。自然，发送数据结束时也没有连接需要释放。因此，减少了开销和发送数据之前的时延。 Internet上的主机有两种方式表示地址：</p><p>域名：www. baidu.com </p><p>IP 地址：180.97.33.108（动态IP地址）</p><ol start="2"><li>InetAddress简介</li></ol><p>InetAddress 类对象含有一个 Internet 主机地址的域名和IP地址：<a href="http://www.baidu.com/180.97.33.108%E3%80%82">www.baidu.com/180.97.33.108。</a> </p><p>域名容易记忆，当在连接网络时输入一个主机的域名后，域名服务器（DNS）负责将域名转化成IP地 址，这样才能和主机建立连接。 </p><p>获取Internet上主机的地址：使用InetAddress类的静态方法：</p><p> getByName(String s)：将一个域名或 IP 地址传递给该方法的参数，获得一个 InetAddress对象，该对 象含有主机地址的域名和IP地址，该对象用如下格式表示它包含的信息： <a href="http://www.baidu.com/180.97.33.108">www.baidu.com/180.97.33.108</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">inter</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;www.baidu.com&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">add</span> <span class="operator">=</span> inter.getHostAddress();</span><br><span class="line">        System.out.println(add);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>端口号：标识正在计算机上运行的进程。公认端口:0-1023。注册端口：1024-49151 。 </p><h2 id="TCP程序设计："><a href="#TCP程序设计：" class="headerlink" title="TCP程序设计："></a>TCP程序设计：</h2><p>客户端－服务器模型是最常见的网络应用程序模型。当我们上网时，我们所使用的浏览器(例如IE)就是一 个客户端软件，而提供网页的站点必需运行一个WEB服务器。 </p><p>一般而言，主动发起通信的应用程序属于客户端。而服务器则是等待通信请求，当服务器收到客户端的 请求，执行需要的运算然后向客户端返回结果。</p><p> IP 地址标识 Internet 上的计算机，端口号标识正在计算机上运行的进程（程序）。 </p><p>端口号与IP地址的组合得出一个网络套接字。 </p><p>端口号被规定为一个 16 位的整数 0<del>65535。其中，0</del>1023被预先定义的服务通信占用（如telnet占用 端口23，http占用端口80等）。除非我们需要访问这些特定服务，否则，就应该使用 1024~65535 这些 端口中的某一个进行通信，以免发生端口冲突。 </p><p>利用套接字(Socket)接口开发网络应用程序早已被广泛的采用，以至于成为事实上的标准。套接字能执 行7种基本操作： </p><p>• 连接到远程主机 </p><p>• 绑定到端口 </p><p>• 接收从远程机器来的连接请求 </p><p>• 监听到达的数据 </p><p>• 发送数据</p><p>• 接收数据 </p><p>• 关闭连接 </p><ol><li>Socket简介</li></ol><p> 两个Java应用程序可通过一个双向的网络通信连接实现数据交换，这个双向链路的一段称为一个Socket (套接字)。Socket通常用来实现Client&#x2F;Server 连接。 </p><p>Java语言的基于套接字编程分为服务器编程和客户端编程，其通信模型如图所示： </p><p>一个简单的案例：服务器端与客户端之间是通过流进行交互的。请回顾，输入流与输出流 </p><p>该案例实现如下效果，客户端与服务器端进行交流，如果客户端输入的是hello,服务器端返回world. 传输普通 的文字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端启动&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;localhost&quot;</span>,<span class="number">8888</span>);</span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">            outputStream.write(<span class="string">&quot;你好，服务器&quot;</span>.getBytes());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;客户端已经启动&quot;</span>);</span><br><span class="line">            <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>);</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">            <span class="type">byte</span>[]bs = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            is.read(bs);</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bs);</span><br><span class="line">            System.out.println(<span class="string">&quot;接收到的信息：&quot;</span>+s.trim());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1_Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务开启&quot;</span>);</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">12456</span>);</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> server.accept();</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">byte</span>[] bs = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        inStream.read(bs);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bs);</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">null</span>!=s&amp;&amp;s.trim().equals(<span class="string">&quot;hello&quot;</span>)) &#123;</span><br><span class="line">            os = socket.getOutputStream();</span><br><span class="line">            os.write(<span class="string">&quot;world&quot;</span>.getBytes());</span><br><span class="line">        &#125;</span><br><span class="line">        inStream.close();</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">null</span>!=os) &#123;</span><br><span class="line">            os.close();</span><br><span class="line">        &#125;</span><br><span class="line">        socket.close();</span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1_Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入要传递的内容&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">words</span> <span class="operator">=</span> input.next();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">12456</span>);</span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">            os.write(words.getBytes());</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">inStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">            <span class="type">byte</span>[] bs=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            inStream.read(bs);</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bs);</span><br><span class="line">            System.out.println(s.trim());</span><br><span class="line">            os.close();</span><br><span class="line">            inStream.close();</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传输普通的图片</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientTest01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;localhost&quot;</span>,<span class="number">8888</span>);</span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">            <span class="type">FileInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:/info4.png&quot;</span>);</span><br><span class="line">            <span class="type">int</span> i;</span><br><span class="line">            <span class="keyword">while</span>((i=inputStream.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">                out.write(i);</span><br><span class="line">            &#125;</span><br><span class="line">            out.close();</span><br><span class="line">            inputStream.close();</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ServerTest01</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>);</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">            <span class="type">FileOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;bak.png&quot;</span>);</span><br><span class="line">            <span class="type">int</span> i ;</span><br><span class="line">            <span class="keyword">while</span>((i=inputStream.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">                out.write(i);</span><br><span class="line">            &#125;</span><br><span class="line">            out.close();</span><br><span class="line">            inputStream.close();</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.openlab.net;</span><br><span class="line"><span class="keyword">import</span> com.openlab.test.OtherClass;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientTest01</span> &#123;</span><br><span class="line">    <span class="comment">//客户端给服务器端发送图片，并收到服务器端的返回的信息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;localhost&quot;</span>,<span class="number">8888</span>);</span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> socket.getOutputStream();<span class="comment">//output</span></span><br><span class="line">            <span class="type">FileInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:/info4.png&quot;</span>);</span><br><span class="line">            <span class="type">int</span> i;</span><br><span class="line">            <span class="keyword">while</span>((i=inputStream.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">                out.write(i);</span><br><span class="line">            &#125;</span><br><span class="line">            socket.shutdownOutput();<span class="comment">//关闭output</span></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">inputStream1</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">            <span class="type">byte</span>[] bs = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            inputStream1.read(bs) ;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bs);</span><br><span class="line">            System.out.println(<span class="string">&quot;收到服务器端信息:&quot;</span>+s.trim());</span><br><span class="line">            out.close();</span><br><span class="line">            inputStream.close();</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ServerTest01</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>);</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">            <span class="type">FileOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;bak.png&quot;</span>);</span><br><span class="line">            <span class="type">int</span> i ;</span><br><span class="line">            <span class="keyword">while</span>((i=inputStream.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">                out.write(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">            outputStream.write(<span class="string">&quot;已经收到信息&quot;</span>.getBytes());</span><br><span class="line">            outputStream.close();</span><br><span class="line">            inputStream.close();</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP:"></a>UDP:</h2><p>和TCP编程相比，UDP编程就简单得多，因为UDP没有创建连接，数据包也是一次收发一个，所以没有 流的概念。在Java中使用UDP编程，仍然需要使用Socket，因为应用程序在使用UDP时必须指定网络接 口（IP）和端口号。注意：UDP端口和TCP端口虽然都使用0~65535，但他们是两套独立的端口，即一 个应用程序用TCP占用了端口1234，不影响另一个应用程序用UDP占用端口1234。在服务器端，使用 UDP也需要监听指定的端口。Java提供了 DatagramSocket 来实现这个功能。UDP数据报通过数据报套 接字DatagramSocket发送和接收，系统不保证UDP数据报一定能够安全送达目的地，也不能确定什么 时候可以抵达。DatagramPacket对象封装了UDP数据报，在数据报中包含了发送端的IP地址和端口号 以及接收端的IP地址和端口号。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Send</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">DatagramSocket</span> <span class="variable">datagramSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;我的UDP方式发送的信息&quot;</span>;</span><br><span class="line">            <span class="type">byte</span>[] bs = s.getBytes();</span><br><span class="line">            <span class="type">InetAddress</span> <span class="variable">inetAddress</span> <span class="operator">=</span> InetAddress.getLocalHost();</span><br><span class="line">            <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bs,<span class="number">0</span>,bs.length,inetAddress,<span class="number">8888</span>);</span><br><span class="line">            datagramSocket.send(packet);</span><br><span class="line">            datagramSocket.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Receive</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">DatagramSocket</span> <span class="variable">datagramSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">8888</span>);</span><br><span class="line">            <span class="type">byte</span>[] bs = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bs,<span class="number">0</span>,bs.length);</span><br><span class="line">            datagramSocket.receive(packet);</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(packet.getData(),<span class="number">0</span>,packet.getLength()));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>URL编程：URL（Uniform Resource Locator）统一资源定位符，它标识Internet上某一资源的地址。 它是一种具体的URL，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">HttpURLConnection</span> <span class="variable">urlConnection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://localhost:8080/jspdemo01_war_exploded/test.bmp&quot;</span>);</span><br><span class="line">        urlConnection = (HttpURLConnection) url.openConnection();</span><br><span class="line">        urlConnection.connect();</span><br><span class="line">        inputStream = urlConnection.getInputStream();</span><br><span class="line">        <span class="type">int</span> i ;</span><br><span class="line">        out = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;bak1.png&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>((i=inputStream.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">            out.write(i);</span><br><span class="line">        &#125;</span><br><span class="line">        out.close();</span><br><span class="line">        inputStream.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP:"></a>HTTP:</h2><p>什么是HTTP？HTTP就是目前使用最广泛的Web应用程序使用的基础协议，例如，浏览器访问网站，手 机App访问后台服务器，都是通过HTTP协议实现的。HTTP是HyperText Transfer Protocol的缩写，翻 译为超文本传输协议，它是基于TCP协议之上的一种请求-响应协议。</p><p>我们来看一下浏览器请求访问某个网站时发送的HTTP请求-响应。当浏览器希望访问某个网站时，浏览 器和网站服务器之间首先建立TCP连接，且服务器总是使用 80 端口和加密端口 443 ，然后，浏览器向 服务器发送一个HTTP请求，服务器收到后，返回一个HTTP响应，并且在响应中包含了HTML的网页内 容，这样，浏览器解析HTML后就可以给用户显示网页了。一个完整的HTTP请求-响应如下。</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220323145401697.png" alt="image-20220323145401697"></p><p>HTTP请求的格式是固定的，它由HTTP Header和HTTP Body两部分构成。第一行总是 请求方法 路径 HTTP版本 ，例如， GET &#x2F; HTTP&#x2F;1.1 表示使用 GET 请求，路径是 &#x2F; ，版本是 HTTP&#x2F;1.1 。 </p><p>后续的每一行都是固定的 Header: Value 格式，我们称为HTTP Header，服务器依靠某些特定的 Header来识别客户端请求，例如：</p><p> Host：表示请求的域名，因为一台服务器上可能有多个网站，因此有必要依靠Host来识别用于请求； </p><p>User-Agent：表示客户端自身标识信息，不同的浏览器有不同的标识，服务器依靠User-Agent判断客户 端类型； </p><p>Accept：表示客户端能处理的HTTP响应格式， &#x2F; 表示任意格式， text&#x2F;* 表示任意文本， image&#x2F;png 表 示PNG格式的图片； </p><p>Accept-Language：表示客户端接收的语言，多种语言按优先级排序，服务器依靠该字段给用户返回特 定语言的网页版本。 </p><p>如果是 GET 请求，那么该HTTP请求只有HTTP Header，没有HTTP Body。如果是 POST 请求，那么该 HTTP请求带有Body，以一个空行分隔。一个典型的带Body的HTTP请求如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST /login HTTP/<span class="number">1.1</span></span><br><span class="line">Host: www.example.com</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: <span class="number">30</span></span><br><span class="line">username=hello&amp;password=<span class="number">123456</span></span><br></pre></td></tr></table></figure><p>POST 请求通常要设置 Content-Type 表示Body的类型， Content-Length 表示Body的长度，这样服务 器就可以根据请求的Header和Body做出正确的响应。 </p><p>此外， GET 请求的参数必须附加在URL上，并以URLEncode方式编码，例如：<a href="http://www.example.co/">http://www.example.co</a> m&#x2F;?a&#x3D;1&amp;b&#x3D;K%26R ，参数分别是 a&#x3D;1 和 b&#x3D;K&amp;R 。因为URL的长度限制，GET 请求的参数不能太多， 而 POST 请求的参数就没有长度限制，因为 POST 请求的参数必须放到Body中。并且， POST 请求的参 数不一定是URL编码，可以按任意格式编码，只需要在 Content-Type中正确设置即可。常见的发送 JSON的 POST 请求如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /login HTTP/1.1</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Content-Length: 38</span><br><span class="line">&#123;&quot;username&quot;:&quot;bob&quot;,&quot;password&quot;:&quot;123456&quot;&#125;</span><br></pre></td></tr></table></figure><p>HTTP响应也是由Header和Body两部分组成，一个典型的HTTP响应如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 133251</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">    &lt;html&gt;&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;Hello&lt;/h1&gt;</span><br></pre></td></tr></table></figure><p>响应的第一行总是 HTTP版本 响应代码 响应说明 ，例如， HTTP&#x2F;1.1 200 OK 表示版本是HTTP&#x2F;1.1 ，响 应代码是 200 ，响应说明是 OK 。客户端只依赖响应代码判断HTTP响应是否成功。 </p><p>HTTP有固定的响应代码： </p><p>1xx：表示一个提示性响应，例如101表示将切换协议，常见于WebSocket连接； </p><p>2xx：表示一个成功的响应，例如200表示成功，206表示只发送了部分内容； </p><p>3xx：表示一个重定向的响应，例如301表示永久重定向，303表示客户端应该按指定路径重新发送请 求； </p><p>4xx：表示一个因为客户端问题导致的错误响应，例如400表示因为Content-Type等各种原因导致的无效 请求，404表示指定的路径不存在； </p><p>5xx：表示一个因为服务器问题导致的错误响应，例如500表示服务器内部故障，503表示服务器暂时无 法响应。 </p><p>当浏览器收到第一个HTTP响应后，它解析HTML后，又会发送一系列HTTP请求，例如， GET &#x2F;logo.jpg HTTP&#x2F;1.1 请求一个图片，服务器响应图片请求后，会直接把二进制内容的图片发送给浏览器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: image/jpeg</span><br><span class="line">Content-Length: 18391</span><br><span class="line">????JFIFHH??XExifMM?i&amp;??X?...(二进制的JPEG图片)</span><br></pre></td></tr></table></figure><p>因此，服务器总是被动地接收客户端的一个HTTP请求，然后响应它。客户端则根据需要发送若干个 HTTP请求。 </p><p>对于最早期的HTTP&#x2F;1.0协议，每次发送一个HTTP请求，客户端都需要先创建一个新的TCP连接，然后， 收到服务器响应后，关闭这个TCP连接。由于建立TCP连接就比较耗时，因此，为了提高效率， HTTP&#x2F;1.1协议允许在一个TCP连接中反复发送-响应，这样就能大大提高效率</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220323145619489.png" alt="image-20220323145619489"></p><p>因为HTTP协议是一个请求-响应协议，客户端在发送了一个HTTP请求后，必须等待服务器响应后，才能 发送下一个请求，这样一来，如果某个响应太慢，它就会堵住后面的请求。</p><p> 所以，为了进一步提速，HTTP&#x2F;2.0允许客户端在没有收到响应的时候，发送多个HTTP请求，服务器返 回响应的时候，不一定按顺序返回，只要双方能识别出哪个响应对应哪个请求，就可以做到并行发送和 接收：</p><p><img src="/post/2b32338b/Users\84750\AppData\Roaming\Typora\typora-user-images\image-20220323145640571.png" alt="image-20220323145640571"></p><p>可见，HTTP&#x2F;2.0进一步提高了效率。 </p><p><strong>HTTP编程</strong> </p><p>既然HTTP涉及到客户端和服务器端，和TCP类似，我们也需要针对客户端编程和针对服务器端编程。 </p><p>本节我们不讨论服务器端的HTTP编程，因为服务器端的HTTP编程本质上就是编写Web服务器，这是一 个非常复杂的体系，也是JavaEE开发的核心内容，我们在后面的章节再仔细研究。 </p><p>本节我们只讨论作为客户端的HTTP编程。 </p><p>因为浏览器也是一种HTTP客户端，所以，客户端的HTTP编程，它的行为本质上和浏览器是一样的，即 发送一个HTTP请求，接收服务器响应后，获得响应内容。只不过浏览器进一步把响应内容解析后渲染并 展示给了用户，而我们使用Java进行HTTP客户端编程仅限于获得响应内容。 </p><p>我们来看一下Java如果使用HTTP客户端编程。Java标准库提供了基于HTTP的包，但是要注意，早期的 JDK版本是通过 HttpURLConnection 访问 </p><p>HTTP，典型代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">HttpURLConnection</span> <span class="variable">urlConnection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://localhost:8080/jspdemo01_war_exploded/test.bmp&quot;</span>);</span><br><span class="line">        urlConnection = (HttpURLConnection) url.openConnection();</span><br><span class="line">        urlConnection.connect();</span><br><span class="line">        inputStream = urlConnection.getInputStream();</span><br><span class="line">        <span class="type">int</span> i ;</span><br><span class="line">        out = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;bak1.png&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>((i=inputStream.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">            out.write(i);</span><br><span class="line">        &#125;</span><br><span class="line">        out.close();</span><br><span class="line">        inputStream.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="二十、JDK8新特性"><a href="#二十、JDK8新特性" class="headerlink" title="二十、JDK8新特性"></a>二十、JDK8新特性</h1><h2 id="1、日期类型"><a href="#1、日期类型" class="headerlink" title="1、日期类型"></a>1、日期类型</h2><p>Java 8 吸收了 Joda-Time 的精华，以一个新的开始为 Java 创建优秀的 API。新的 java.time 中包含了所 有关于本地日期（LocalDate）、本地时间（LocalTime）、本地日期时间（LocalDateTime）、时区 （ZonedDateTime）和持续时间（Duration）的类。历史悠久的 Date 类新增了 toInstant() 方法，用 于把 Date 转换成新的表示形式。这些新增的本地化时间日期 API 大大简化了日期时间和本地化的管理 </p><p>LocalDate、LocalTime、LocalDateTime 类是其中较重要的几个类，它们的实例是不可变的对象，分别 表示使用 ISO-8601日历系统的日期、时间、日期和时间。它们提供了简单的本地日期或时间，并不包含 当前的时间信息，也不包含与时区相关的信息。 </p><p>LocalDate代表IOS格式（yyyy-MM-dd）的日期,可以存储 生日、纪念日等日期。 </p><p>LocalTime表示一个时间，而不是日期。</p><p>LocalDateTime是用来表示日期和时间的，这是一个最常用的类之一。 </p><p><strong>注：</strong>ISO-8601日历系统是国际标准化组织制定的现代公民的日期和时间的表示法，也就是公历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">time</span> <span class="operator">=</span> LocalDate.now();<span class="comment">// 获取系统当前的时间</span></span><br><span class="line">System.out.println(time);</span><br><span class="line">time = LocalDate.of(<span class="number">2018</span>, <span class="number">3</span>, <span class="number">25</span>);<span class="comment">//将整数转为为日期类型</span></span><br><span class="line">time = LocalDate.of(<span class="number">2018</span>, Month.JUNE, <span class="number">25</span>);<span class="comment">//将整数转换为日期类型</span></span><br><span class="line">System.out.println(time);</span><br><span class="line">time = LocalDate.parse(<span class="string">&quot;2018年04月08号&quot;</span>,</span><br><span class="line">DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy年MM月dd号&quot;</span>));<span class="comment">//将一个字符串转换为日期类型</span></span><br><span class="line">System.out.println(time.isLeapYear());<span class="comment">//是否是闰年</span></span><br><span class="line">System.out.println(time);</span><br><span class="line"><span class="type">Period</span> <span class="variable">p</span> <span class="operator">=</span> time.until(LocalDate.now());<span class="comment">//获取两个日期的时间差，得到的是Period类型</span></span><br><span class="line">        </span><br><span class="line">System.out.println(p.getYears()+<span class="string">&quot;年&quot;</span>+p.getMonths()+<span class="string">&quot;月&quot;</span>+p.getDays()+<span class="string">&quot;天&quot;</span>);<span class="comment">//可以通过period类型获取 年月日</span></span><br><span class="line">        </span><br><span class="line"><span class="type">long</span> <span class="variable">t</span> <span class="operator">=</span> ChronoUnit.DAYS.between(time, LocalDate.now());<span class="comment">//求两个日期差了多少天</span></span><br><span class="line">System.out.println(t);</span><br><span class="line"><span class="type">DayOfWeek</span> <span class="variable">d</span> <span class="operator">=</span> time.getDayOfWeek();<span class="comment">//获取该日期是星期几</span></span><br><span class="line">System.out.println(d.getValue());<span class="comment">//获取星期几的数字表示</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">LocalTime</span> <span class="variable">time</span> <span class="operator">=</span> LocalTime.now();<span class="comment">//系统当前的时间，时分秒毫秒</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> time.format(DateTimeFormatter.ofPattern(<span class="string">&quot;HH:mm:ss&quot;</span>));<span class="comment">//转换</span></span><br><span class="line">System.out.println(time);</span><br><span class="line">System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">time</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">System.out.println(time);</span><br><span class="line"><span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> time.getYear();</span><br><span class="line"><span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> time.getMonth().getValue();</span><br><span class="line"><span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> time.getDayOfMonth();</span><br><span class="line"><span class="type">int</span> <span class="variable">week</span> <span class="operator">=</span> time.getDayOfWeek().getValue();</span><br><span class="line">System.out.println(year+<span class="string">&quot;年&quot;</span>+month+<span class="string">&quot;月&quot;</span>+day+<span class="string">&quot;日\t&quot;</span>+week);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Instant</span> <span class="variable">instant</span> <span class="operator">=</span> Instant.now();</span><br><span class="line">System.out.println(instant);</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加时间的偏移量</span></span><br><span class="line"><span class="type">OffsetDateTime</span> <span class="variable">offsetDateTime</span> <span class="operator">=</span></span><br><span class="line">instant.atOffset(ZoneOffset.ofHours(<span class="number">8</span>));</span><br><span class="line">System.out.println(offsetDateTime);</span><br><span class="line"></span><br><span class="line"><span class="comment">//toEpochMilli():获取自1970年1月1日0时0分0秒（UTC）开始的毫秒数 ---&gt; Date类的getTime()</span></span><br><span class="line"><span class="type">long</span> <span class="variable">milli</span> <span class="operator">=</span> instant.toEpochMilli();</span><br><span class="line">System.out.println(milli);</span><br><span class="line"><span class="comment">//ofEpochMilli():通过给定的毫秒数，获取Instant实例 --&gt;Date(long millis)</span></span><br><span class="line"><span class="type">Instant</span> <span class="variable">instant1</span> <span class="operator">=</span> Instant.ofEpochMilli(<span class="number">1550475314878L</span>);</span><br><span class="line">System.out.println(instant1);</span><br></pre></td></tr></table></figure><h2 id="2、Lambda表达式"><a href="#2、Lambda表达式" class="headerlink" title="2、Lambda表达式"></a>2、Lambda表达式</h2><p> lambda 表达式，也可称为[闭包]，它是推动Java 8 发布的最重要新特性，允许把[函数]作为一个方法的 参数（函数作为参数传递进方法中），Java中的Lambda可以被当做是匿名内部类的“语法糖”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">run</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;run接口中的run方法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    run.run();</span><br><span class="line">    System.out.println(<span class="string">&quot;-----------------------------------&quot;</span>);</span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">run1</span> <span class="operator">=</span> ()-&gt;&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;run接口中的run方法&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    run1.run();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span>&#123;</span><br><span class="line">    Comparator&lt;Integer&gt; com = <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    com.compare(<span class="number">20</span>,<span class="number">35</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;--------------------&quot;</span>);</span><br><span class="line">    Comparator&lt;Integer&gt; com2 =(o1,o2)-&gt; &#123;<span class="keyword">return</span> o1.compareTo(o2);&#125;;</span><br><span class="line">    <span class="comment">//方法引用</span></span><br><span class="line">    Comparator&lt;Integer&gt; com3=Integer::compareTo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Lambda表达式的本质：作为函数式接口的实例。 </p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parameters) -&gt; expression</span><br><span class="line">或</span><br><span class="line">(parameters) -&gt;&#123; statements; &#125;</span><br></pre></td></tr></table></figure><p>( ) ：用来描述参数列表； </p><p>{ } ： 用来描述方法体； </p><p>-&gt; ：Lambda运算符，可以叫做箭头符号，或者goes to </p><p>3、函数式(Functional)接口：如果一个接口中，只声明了一个抽象方法，则此接口就称为函数式接口。</p><h1 id="二一、JSON"><a href="#二一、JSON" class="headerlink" title="二一、JSON"></a>二一、JSON</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串转换为json对象，以及java对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//字符串转换为json对象</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;name\&quot;:\&quot;zhangsan\&quot;,\&quot;sex\&quot;:\&quot;male\&quot;,\&quot;age\&quot;:\&quot;18\&quot;&#125;&quot;</span>;</span><br><span class="line">    <span class="type">JSONObject</span> <span class="variable">obj</span> <span class="operator">=</span>JSONObject.parseObject(str);</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> obj.get(<span class="string">&quot;name&quot;</span>).toString();</span><br><span class="line">    System.out.println(name);</span><br><span class="line">    <span class="type">String</span> <span class="variable">name2</span> <span class="operator">=</span> obj.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    System.out.println(name2);</span><br><span class="line">    <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> obj.getInteger(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">    System.out.println(age);</span><br><span class="line">    <span class="comment">//json字符串转换为普通java对象</span></span><br><span class="line">    <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person) JSONObject.parseObject(str,Person.class);</span><br><span class="line">    System.out.println(p.getSex());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java对象转换为json字符串以及json对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    p.setName(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">    p.setAge(<span class="number">18</span>);</span><br><span class="line">    p.setSex(<span class="string">&quot;男&quot;</span>);</span><br><span class="line">    <span class="comment">//java对象转换为json字符串</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> JSONObject.toJSONString(p);</span><br><span class="line">    System.out.println(s);</span><br><span class="line">    <span class="comment">//java对象转换为json对象</span></span><br><span class="line">    JSONObject json= (JSONObject) JSONObject.toJSON(p);</span><br><span class="line">    System.out.println(json.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通java集合转换为json数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;Person&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;A&quot;</span>,<span class="string">&quot;男&quot;</span> ,<span class="number">17</span>);</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;B&quot;</span>,<span class="string">&quot;女&quot;</span> ,<span class="number">16</span>);</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;C&quot;</span>,<span class="string">&quot;男&quot;</span> ,<span class="number">17</span>);</span><br><span class="line">    list.add(p1);</span><br><span class="line">    list.add(p2);</span><br><span class="line">    list.add(p3);</span><br><span class="line">    <span class="type">JSONArray</span> <span class="variable">arr</span> <span class="operator">=</span> (JSONArray) JSONArray.toJSON(list);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.size();i++)&#123;</span><br><span class="line">        <span class="type">JSONObject</span> <span class="variable">json</span> <span class="operator">=</span> (JSONObject) arr.get(i);</span><br><span class="line">        System.out.println(json.get(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line">    String s=<span class="string">&quot;[&#123;\&quot;name\&quot;:\&quot;zhangsan\&quot;,\&quot;sex\&quot;:\&quot;male\&quot;,\&quot;age\&quot;:\&quot;18\&quot;&#125;,&#123;\&quot;name\&quot;:\&quot;zhangsan1\&quot;,\&quot;sex\&quot;:\&quot;male1\&quot;,\&quot;age\&quot;:\&quot;17\&quot;&#125;]&quot;</span>;</span><br><span class="line">    List&lt;Person&gt; list = JSONObject.parseArray(s,Person.class);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> list.get(i);</span><br><span class="line">        System.out.println(p.getName()+<span class="string">&quot;\t&quot;</span>+p.getSex());</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;-------------------------------&quot;</span>);</span><br><span class="line">    <span class="type">JSONArray</span> <span class="variable">arr</span> <span class="operator">=</span> JSONObject.parseArray(s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.size();i++)&#123;</span><br><span class="line">        <span class="type">JSONObject</span> <span class="variable">json</span> <span class="operator">=</span> (JSONObject) arr.get(i);</span><br><span class="line">        System.out.println(json.get(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
